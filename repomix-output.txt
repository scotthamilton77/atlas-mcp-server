This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-26T20:11:39.961Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  config/
    index.ts
  errors/
    index.ts
  events/
    event-manager.ts
  logging/
    index.ts
  server/
    health-monitor.ts
    index.ts
    metrics-collector.ts
    rate-limiter.ts
    request-tracer.ts
  storage/
    core/
      connection/
        health.ts
        manager.ts
        pool.ts
        state.ts
      query/
        builder.ts
        executor.ts
        optimizer.ts
      schema/
        backup.ts
        migrations.ts
        validator.ts
      transactions/
        manager.ts
        scope.ts
      wal/
        manager.ts
      index.ts
    monitoring/
      health.ts
      index.ts
      metrics.ts
    sqlite/
      index.ts
      init.ts
      storage.ts
    connection-manager.ts
    factory.ts
    index.ts
    sqlite-storage.ts
  task/
    core/
      batch/
        common/
          batch-utils.ts
        base-batch-processor.ts
        dependency-aware-batch-processor.ts
        generic-batch-processor.ts
        index.ts
        status-update-batch.ts
        task-status-batch-processor.ts
      cache/
        cache-coordinator.ts
        cache-manager.ts
        cache-metrics.ts
        index.ts
      indexing/
        index-manager.ts
        index.ts
      transactions/
        index.ts
        transaction-manager.ts
      index.ts
      task-store.ts
    operations/
      index.ts
      task-operations.ts
    validation/
      index.ts
      task-validator.ts
  tools/
    handler.ts
    index.ts
    schemas.ts
    session-schemas.ts
    utils.ts
  types/
    batch.ts
    cache.ts
    config.ts
    error.ts
    events.ts
    index.ts
    indexing.ts
    logging.ts
    project.ts
    session.ts
    storage.ts
    task.ts
    transaction.ts
  utils/
    id-generator.ts
    path-utils.ts
    pattern-matcher.ts
  validation/
    config.ts
    id-schema.ts
    index.ts
    logging.ts
    path-validator.ts
  index.ts
  repomix-output.txt
  task-manager.ts
.eslintrc.json
.gitignore
jest.config.js
LICENSE
package.json
README.md
repo-tree.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/config/index.ts
================
/**
 * Configuration module
 * Handles application configuration management
 */

import { ConfigError, ErrorCodes } from '../errors/index.js';
import { LogLevel, LogLevels } from '../types/logging.js';
import { resolve, join } from 'path';
import { homedir } from 'os';

/**
 * Environment variable names
 */
export const EnvVars = {
    NODE_ENV: 'NODE_ENV',
    LOG_LEVEL: 'LOG_LEVEL',
    ATLAS_STORAGE_DIR: 'ATLAS_STORAGE_DIR',
    ATLAS_STORAGE_NAME: 'ATLAS_STORAGE_NAME'
} as const;

/**
 * Environment types
 */
export const Environments = {
    DEVELOPMENT: 'development',
    PRODUCTION: 'production',
    TEST: 'test'
} as const;

/**
 * Logging configuration type
 */
export interface LoggingConfig {
    level: LogLevel;
    console: boolean;
    file: boolean;
    dir?: string;
    maxFiles: number;
    maxSize: number;
}

/**
 * Storage configuration type
 */
export interface StorageConfig {
    baseDir: string;
    name: string;
    connection?: {
        maxRetries?: number;
        retryDelay?: number;
        busyTimeout?: number;
    };
    performance?: {
        checkpointInterval?: number;
        cacheSize?: number;
        mmapSize?: number;
        pageSize?: number;
    };
}

/**
 * Application configuration type
 */
export interface AppConfig {
    env: string;
    logging: LoggingConfig;
    storage: StorageConfig;  // Make storage required
}

export interface PartialAppConfig {
    env?: string;
    logging?: Partial<LoggingConfig>;
    storage?: Partial<StorageConfig>;
}

/**
 * Configuration schema
 */
export const configSchema = {
    env: {
        type: 'string',
        enum: [
            Environments.DEVELOPMENT,
            Environments.PRODUCTION,
            Environments.TEST
        ],
        default: Environments.DEVELOPMENT
    },
    logging: {
        type: 'object',
        properties: {
            level: {
                type: 'string',
                enum: Object.values(LogLevels),
                default: LogLevels.INFO
            },
            console: {
                type: 'boolean',
                default: true
            },
            file: {
                type: 'boolean',
                default: false
            },
            dir: {
                type: 'string',
                optional: true
            },
            maxFiles: {
                type: 'number',
                minimum: 1,
                default: 5
            },
            maxSize: {
                type: 'number',
                minimum: 1024,
                default: 5242880 // 5MB
            }
        },
        required: ['level']
    },
    storage: {
        type: 'object',
        properties: {
            baseDir: {
                type: 'string'
            },
            name: {
                type: 'string'
            },
            connection: {
                type: 'object',
                properties: {
                    maxRetries: {
                        type: 'number',
                        minimum: 1,
                        optional: true
                    },
                    retryDelay: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    busyTimeout: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    }
                },
                optional: true
            },
            performance: {
                type: 'object',
                properties: {
                    checkpointInterval: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    cacheSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    mmapSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    pageSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    }
                },
                optional: true
            }
        },
        required: ['baseDir', 'name']
    }
};

/**
 * Default logging configuration
 */
const defaultLoggingConfig: LoggingConfig = {
    level: LogLevels.INFO,
    console: true,
    file: true,
    dir: 'logs',
    maxFiles: 5,
    maxSize: 5242880
};

/**
 * Default configuration values
 */
export const defaultConfig: AppConfig = {
    env: Environments.DEVELOPMENT,
    logging: defaultLoggingConfig,
    storage: {
        baseDir: join(process.platform === 'win32' ? 
            process.env.LOCALAPPDATA || join(homedir(), 'AppData', 'Local') :
            process.env.XDG_DATA_HOME || join(homedir(), '.local', 'share'),
            'atlas-mcp', 'storage'
        ),
        name: 'atlas-tasks',
        connection: {
            maxRetries: 3,
            retryDelay: 1000,
            busyTimeout: 5000
        },
        performance: {
            checkpointInterval: 300000, // 5 minutes
            cacheSize: 2000,
            mmapSize: 30000000000, // 30GB
            pageSize: 4096
        }
    }
};

/**
 * Configuration manager class
 */
export class ConfigManager {
    private static instance: ConfigManager | null = null;
    private static initializationPromise: Promise<ConfigManager> | null = null;
    private config: AppConfig;
    private initialized = false;

    private constructor() {
        this.config = defaultConfig;
    }

    /**
     * Gets the configuration manager instance
     */
    static getInstance(): ConfigManager {
        if (!ConfigManager.instance || !ConfigManager.instance.initialized) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Configuration not initialized. Call ConfigManager.initialize() first.'
            );
        }
        return ConfigManager.instance;
    }

    /**
     * Initializes the configuration manager with custom config
     */
    static async initialize(config?: PartialAppConfig): Promise<ConfigManager> {
        // Return existing instance if available
        if (ConfigManager.instance && ConfigManager.instance.initialized) {
            return ConfigManager.instance;
        }

        // If initialization is in progress, wait for it
        if (ConfigManager.initializationPromise) {
            return ConfigManager.initializationPromise;
        }

        // Start new initialization with mutex
        ConfigManager.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (ConfigManager.instance && ConfigManager.instance.initialized) {
                    return ConfigManager.instance;
                }

                ConfigManager.instance = new ConfigManager();
                if (config) {
                    await ConfigManager.instance.updateConfig(config);
                }
                ConfigManager.instance.initialized = true;
                return ConfigManager.instance;
            } catch (error) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    `Failed to initialize configuration: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                ConfigManager.initializationPromise = null;
            }
        })();

        return ConfigManager.initializationPromise;
    }

    /**
     * Gets the current configuration
     */
    getConfig(): AppConfig {
        return { ...this.config };
    }

    /**
     * Updates the configuration
     */
    async updateConfig(updates: PartialAppConfig): Promise<void> {
        const newConfig = {
            ...this.config,
            ...updates,
            logging: {
                ...this.config.logging,
                ...(updates.logging || {})
            },
            storage: {
                ...this.config.storage,
                ...(updates.storage || {})
            }
        };

        // Load environment config and create directories
        const envConfig = await this.loadEnvConfig(newConfig);
        
        // Merge with environment config
        const finalConfig = {
            ...newConfig,
            storage: {
                ...newConfig.storage,
                ...envConfig.storage
            }
        };

        this.validateConfig(finalConfig);
        this.config = finalConfig;
    }

    /**
     * Gets platform-specific user data directory
     */
    private getUserDataDir(): string {
        // Try environment variables first
        if (process.env.LOCALAPPDATA) {
            return process.env.LOCALAPPDATA;
        }
        if (process.env.XDG_DATA_HOME) {
            return process.env.XDG_DATA_HOME;
        }

        // Fall back to platform-specific defaults
        const home = homedir();
        return process.platform === 'win32'
            ? join(home, 'AppData', 'Local')
            : join(home, '.local', 'share');
    }

    /**
     * Loads configuration from environment variables and ensures directories exist
     */
    private async loadEnvConfig(customConfig: PartialAppConfig): Promise<AppConfig> {
        const currentEnv = process.env[EnvVars.NODE_ENV];
        const currentLogLevel = process.env[EnvVars.LOG_LEVEL];
        
        // Handle storage directory with platform-agnostic paths
        let storageDir = customConfig.storage?.baseDir || process.env[EnvVars.ATLAS_STORAGE_DIR];
        let storageName = customConfig.storage?.name || process.env[EnvVars.ATLAS_STORAGE_NAME];
        
        // Use defaults if env vars not provided
        if (!storageDir) {
            const userDataDir = this.getUserDataDir();
            storageDir = join(userDataDir, 'atlas-mcp', 'storage');
        }

        if (!storageName) {
            storageName = 'atlas-tasks';
        }

        // Ensure absolute path and create directory if needed
        storageDir = resolve(storageDir);
        try {
            const fs = await import('fs/promises');
            await fs.mkdir(storageDir, { 
                recursive: true,
                // Skip mode on Windows as it's ignored
                ...(process.platform !== 'win32' && { mode: 0o755 })
            });
        } catch (error) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                `Failed to create storage directory: ${error instanceof Error ? error.message : String(error)}`
            );
        }

        const config: AppConfig = {
            env: currentEnv || Environments.DEVELOPMENT,
            storage: {
                baseDir: storageDir,
                name: storageName,
                connection: {
                    maxRetries: 3,
                    retryDelay: 1000,
                    busyTimeout: 5000
                },
                performance: {
                    checkpointInterval: 300000, // 5 minutes
                    cacheSize: 2000,
                    mmapSize: 30000000000, // 30GB
                    pageSize: 4096
                }
            },
            logging: { ...defaultLoggingConfig }
        };

        if (currentEnv) {
            if (!Object.values(Environments).includes(currentEnv as any)) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    'Invalid environment'
                );
            }
            config.env = currentEnv;
        }

        if (currentLogLevel) {
            const level = currentLogLevel.toLowerCase();
            if (!Object.values(LogLevels).includes(level as any)) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    'Invalid log level'
                );
            }
            config.logging.level = level as LogLevel;
        }

        return config;
    }

    /**
     * Validates configuration against schema
     */
    private validateConfig(config: AppConfig): void {
        if (!config.storage?.baseDir) {
            throw new ConfigError(
                ErrorCodes.CONFIG_MISSING,
                'Storage directory must be provided'
            );
        }

        if (!config.storage?.name) {
            throw new ConfigError(
                ErrorCodes.CONFIG_MISSING,
                'Storage name must be provided'
            );
        }

        if (config.logging?.level && !Object.values(LogLevels).includes(config.logging.level)) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Invalid log level'
            );
        }
    }
}

/**
 * Creates a default configuration manager
 */
export function createDefaultConfig(): ConfigManager {
    return ConfigManager.getInstance();
}

================
File: src/errors/index.ts
================
/**
 * Error codes and error creation utility
 */
export const ErrorCodes = {
    // Migration errors
    MIGRATION_ERROR: 'MIGRATION_1001',
    // Task errors (1000-1999)
    TASK_NOT_FOUND: 'TASK_1001',
    TASK_VALIDATION: 'TASK_1002',
    TASK_DEPENDENCY: 'TASK_1003',
    TASK_STATUS: 'TASK_1004',
    TASK_DUPLICATE: 'TASK_1005',
    TASK_CYCLE: 'TASK_1006',
    TASK_INVALID_PATH: 'TASK_1007',
    TASK_PARENT_NOT_FOUND: 'TASK_1008',
    TASK_PARENT_TYPE: 'TASK_1009',

    // Storage errors (2000-2999)
    STORAGE_ERROR: 'STORAGE_2001',
    STORAGE_READ: 'STORAGE_2002',
    STORAGE_WRITE: 'STORAGE_2003',
    STORAGE_DELETE: 'STORAGE_2004',
    STORAGE_INIT: 'STORAGE_2005',
    STORAGE_CLOSE: 'STORAGE_2006',

    // Transaction errors (3000-3999)
    TRANSACTION_ERROR: 'TRANSACTION_3001',
    TRANSACTION_TIMEOUT: 'TRANSACTION_3002',
    TRANSACTION_DEADLOCK: 'TRANSACTION_3003',
    TRANSACTION_ROLLBACK: 'TRANSACTION_3004',
    TRANSACTION_COMMIT: 'TRANSACTION_3005',
    TRANSACTION_ISOLATION: 'TRANSACTION_3006',
    TRANSACTION_NESTED: 'TRANSACTION_3007',

    // Connection errors (4000-4999)
    CONNECTION_ERROR: 'CONNECTION_4001',
    CONNECTION_TIMEOUT: 'CONNECTION_4002',
    CONNECTION_LIMIT: 'CONNECTION_4003',
    CONNECTION_CLOSED: 'CONNECTION_4004',
    CONNECTION_BUSY: 'CONNECTION_4005',

    // Operation errors (5000-5999)
    INVALID_INPUT: 'OPERATION_5001',
    INVALID_STATE: 'OPERATION_5002',
    CONCURRENT_MODIFICATION: 'OPERATION_5003',
    INTERNAL_ERROR: 'OPERATION_5004',
    TIMEOUT: 'OPERATION_5005',
    OPERATION_FAILED: 'OPERATION_5006',
    VALIDATION_ERROR: 'OPERATION_5007',

    // Configuration errors (6000-6999)
    CONFIG_INVALID: 'CONFIG_6001',
    CONFIG_MISSING: 'CONFIG_6002'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

export interface ErrorDetails {
    code: ErrorCode;
    message: string;
    operation?: string;
    cause?: string;
    details?: Record<string, unknown>;
}

export class BaseError extends Error {
    readonly code: ErrorCode;
    readonly operation?: string;
    readonly details?: Record<string, unknown>;

    constructor(details: ErrorDetails) {
        super(details.message);
        this.name = 'BaseError';
        this.code = details.code;
        this.operation = details.operation;
        this.details = details.details;
    }

    getUserMessage(): string {
        return this.message;
    }

    toJSON(): Record<string, unknown> {
        return {
            code: this.code,
            message: this.message,
            operation: this.operation,
            details: this.details
        };
    }
}

/**
 * Create a standardized error with proper code and context
 */
export class ConfigError extends BaseError {
    constructor(code: ErrorCode, message: string, details?: Record<string, unknown>) {
        super({
            code,
            message,
            details
        });
        this.name = 'ConfigError';
    }
}

export function createError(
    code: ErrorCode,
    message: string,
    operation?: string,
    cause?: string,
    details?: Record<string, unknown>
): BaseError {
    const fullMessage = cause ? `${message}: ${cause}` : message;
    return new BaseError({
        code,
        message: fullMessage,
        operation,
        details
    });
}

/**
 * Check if an error is a specific type
 */
export function isErrorType(error: unknown, code: ErrorCode): boolean {
    return error instanceof BaseError && error.code === code;
}

/**
 * Retryable error codes
 */
export const RetryableErrorCodes = {
    CONNECTION_BUSY: ErrorCodes.CONNECTION_BUSY,
    TRANSACTION_DEADLOCK: ErrorCodes.TRANSACTION_DEADLOCK,
    CONNECTION_TIMEOUT: ErrorCodes.CONNECTION_TIMEOUT,
    STORAGE_ERROR: ErrorCodes.STORAGE_ERROR
} as const;

export type RetryableErrorCode = typeof RetryableErrorCodes[keyof typeof RetryableErrorCodes];

/**
 * Check if an error is retryable
 */
export function isRetryableError(error: unknown): boolean {
    if (!(error instanceof BaseError)) return false;

    return Object.values(RetryableErrorCodes).includes(error.code as RetryableErrorCode);
}

/**
 * Format error for logging
 */
export function formatError(error: unknown): Record<string, unknown> {
    if (error instanceof BaseError) {
        return error.toJSON();
    }

    if (error instanceof Error) {
        return {
            message: error.message,
            name: error.name,
            stack: error.stack
        };
    }

    return {
        message: String(error)
    };
}

================
File: src/events/event-manager.ts
================
import { EventEmitter } from 'events';
import { Logger } from '../logging/index.js';
import {
  AtlasEvent,
  EventHandler,
  EventSubscription,
  EventTypes,
  TaskEvent,
  CacheEvent,
  ErrorEvent,
  BatchEvent,
  TransactionEvent,
  SystemEvent
} from '../types/events.js';

export class EventManager {
  private static instance: EventManager | null = null;
  private static initializationPromise: Promise<EventManager> | null = null;
  private readonly emitter: EventEmitter;
  private static logger: Logger;
  private readonly maxListeners: number = 100;
  private readonly debugMode: boolean;
  private initialized = false;

  private static initLogger(): void {
    if (!EventManager.logger) {
      EventManager.logger = Logger.getInstance().child({ component: 'EventManager' });
    }
  }

  private constructor() {
    EventManager.initLogger();
    this.emitter = new EventEmitter();
    this.emitter.setMaxListeners(this.maxListeners);
    this.debugMode = process.env.NODE_ENV === 'development';
    this.setupErrorHandling();
  }

  static async initialize(): Promise<EventManager> {
    // Return existing instance if available
    if (EventManager.instance) {
      return EventManager.instance;
    }

    // If initialization is in progress, wait for it
    if (EventManager.initializationPromise) {
      return EventManager.initializationPromise;
    }

    // Start new initialization with mutex
    EventManager.initializationPromise = (async () => {
      try {
        // Double-check instance hasn't been created while waiting
        if (EventManager.instance) {
          return EventManager.instance;
        }

        EventManager.instance = new EventManager();
        EventManager.instance.initialized = true;
        return EventManager.instance;
      } catch (error) {
        throw new Error(`Failed to initialize EventManager: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        EventManager.initializationPromise = null;
      }
    })();

    return EventManager.initializationPromise;
  }

  static getInstance(): EventManager {
    if (!EventManager.instance || !EventManager.instance.initialized) {
      throw new Error('EventManager not initialized. Call EventManager.initialize() first.');
    }
    return EventManager.instance;
  }

  emit<T extends AtlasEvent>(event: T): void {
    try {
      if (this.debugMode) {
        const debugInfo: Record<string, unknown> = {
          type: event.type,
          timestamp: event.timestamp
        };

        // Handle different event types' metadata/context
        if ('metadata' in event) {
          debugInfo.metadata = event.metadata;
        } else if ('context' in event) {
          debugInfo.context = event.context;
        }

        EventManager.logger.debug('Emitting event', debugInfo);
      }

      // Add timestamp if not present
      if (!event.timestamp) {
        event.timestamp = Date.now();
      }

      this.emitter.emit(event.type, event);

      // Emit to wildcard listeners
      this.emitter.emit('*', event);
    } catch (error) {
      EventManager.logger.error('Event emission failed', {
        error,
        event: {
          type: event.type,
          timestamp: event.timestamp
        }
      });

      // Emit error event
      this.emitError('event_emission_failed', error as Error, {
        eventType: event.type
      });
    }
  }

  on<T extends AtlasEvent>(
    type: EventTypes | '*',
    handler: EventHandler<T>
  ): EventSubscription {
    if (this.debugMode) {
      EventManager.logger.debug('Adding event listener', { type });
    }

    // Wrap handler to catch errors
    const wrappedHandler = async (event: T) => {
      try {
        await handler(event);
      } catch (error) {
        EventManager.logger.error('Event handler error', {
          error,
          eventType: type
        });
        this.emitError('event_handler_error', error as Error, {
          eventType: type
        });
      }
    };

    this.emitter.on(type, wrappedHandler);

    // Return subscription object
    return {
      unsubscribe: () => {
        this.emitter.off(type, wrappedHandler);
        if (this.debugMode) {
          EventManager.logger.debug('Removed event listener', { type });
        }
      }
    };
  }

  once<T extends AtlasEvent>(
    type: EventTypes | '*',
    handler: EventHandler<T>
  ): EventSubscription {
    if (this.debugMode) {
      EventManager.logger.debug('Adding one-time event listener', { type });
    }

    // Wrap handler to catch errors
    const wrappedHandler = async (event: T) => {
      try {
        await handler(event);
      } catch (error) {
        EventManager.logger.error('One-time event handler error', {
          error,
          eventType: type
        });
        this.emitError('event_handler_error', error as Error, {
          eventType: type,
          oneTime: true
        });
      }
    };

    this.emitter.once(type, wrappedHandler);

    // Return subscription object
    return {
      unsubscribe: () => {
        this.emitter.off(type, wrappedHandler);
        if (this.debugMode) {
          EventManager.logger.debug('Removed one-time event listener', { type });
        }
      }
    };
  }

  removeAllListeners(type?: EventTypes | '*'): void {
    if (type) {
      this.emitter.removeAllListeners(type);
      if (this.debugMode) {
        EventManager.logger.debug('Removed all listeners for event type', { type });
      }
    } else {
      this.emitter.removeAllListeners();
      if (this.debugMode) {
        EventManager.logger.debug('Removed all event listeners');
      }
    }
  }

  listenerCount(type: EventTypes | '*'): number {
    return this.emitter.listenerCount(type);
  }

  private setupErrorHandling(): void {
    // Handle emitter errors
    this.emitter.on('error', (error: Error) => {
      EventManager.logger.error('EventEmitter error', { error });
    });

    // Handle uncaught promise rejections in handlers
    process.on('unhandledRejection', (reason, promise) => {
      EventManager.logger.error('Unhandled promise rejection in event handler', {
        reason,
        promise
      });
    });
  }

  private emitError(
    context: string,
    error: Error,
    metadata?: Record<string, unknown>
  ): void {
    const errorEvent: ErrorEvent = {
      type: EventTypes.SYSTEM_ERROR,
      timestamp: Date.now(),
      error,
      context: {
        component: 'EventManager',
        operation: context,
        ...metadata
      }
    };

    try {
      this.emitter.emit(EventTypes.SYSTEM_ERROR, errorEvent);
    } catch (emitError) {
      // Last resort error logging
      EventManager.logger.error('Failed to emit error event', {
        originalError: error,
        emitError,
        context
      });
    }
  }

  // Typed event emission helpers
  emitTaskEvent(event: TaskEvent): void {
    this.emit(event);
  }

  emitCacheEvent(event: CacheEvent): void {
    this.emit(event);
  }

  emitErrorEvent(event: ErrorEvent): void {
    this.emit(event);
  }

  emitBatchEvent(event: BatchEvent): void {
    this.emit(event);
  }

  emitTransactionEvent(event: TransactionEvent): void {
    this.emit(event);
  }

  emitSystemEvent(event: SystemEvent): void {
    this.emit(event);
  }
}

================
File: src/logging/index.ts
================
/**
 * Logging module
 * Provides centralized logging functionality with structured output
 */

import { createLogger, format, transports, Logger as WinstonLogger, config as winstonConfig } from 'winston';
import { join } from 'path';
import { mkdirSync } from 'fs';
import { BaseError, ErrorCodes } from '../errors/index.js';
import { LogLevel, LogLevels, LoggerConfig } from '../types/logging.js';

/**
 * Logger class
 * Provides structured logging with context and error handling
 */
export class Logger {
    private static instance: Logger;
    private logger: WinstonLogger;

    private config: LoggerConfig;
    private isShuttingDown = false;

    private constructor(config: LoggerConfig) {
        this.config = config;
        this.logger = this.createLogger(config);
        
        // Handle process events
        process.on('SIGINT', () => this.handleShutdown());
        process.on('SIGTERM', () => this.handleShutdown());
        process.on('exit', () => this.handleShutdown());
    }

    /**
     * Handle graceful shutdown
     */
    private handleShutdown(): void {
        if (this.isShuttingDown) return;
        this.isShuttingDown = true;

        // Close transports
        this.logger.close();
    }

    /**
     * Recreate logger if needed
     */
    private lastHealthCheck = 0;
    private readonly HEALTH_CHECK_INTERVAL = 5000; // 5 seconds

    private ensureLogger(): void {
        if (this.isShuttingDown) return;

        const now = Date.now();
        // Only check every 5 seconds to reduce memory pressure
        if (now - this.lastHealthCheck < this.HEALTH_CHECK_INTERVAL) {
            return;
        }
        
        try {
            // Test if logger is working
            this.logger.log({
                level: 'debug',
                message: 'Logger health check'
            });
            this.lastHealthCheck = now;
        } catch (error) {
            const err = error as Error;
            if (err?.message?.includes('EPIPE')) {
                // Recreate logger with same config
                this.logger = this.createLogger(this.config);
                this.lastHealthCheck = now;
            }
        }
    }

    /**
     * Gets the logger instance
     */
    private static initializationPromise: Promise<Logger> | null = null;

    static getInstance(): Logger {
        if (!Logger.instance) {
            throw new BaseError({
                code: ErrorCodes.INVALID_STATE,
                message: 'Logger not initialized. Call Logger.initialize() first.'
            });
        }
        return Logger.instance;
    }

    /**
     * Initializes the logger with configuration
     */
    static async initialize(config: LoggerConfig): Promise<Logger> {
        // Return existing instance if available
        if (Logger.instance) {
            return Logger.instance;
        }

        // If initialization is in progress, wait for it
        if (Logger.initializationPromise) {
            return Logger.initializationPromise;
        }

        // Start new initialization with mutex
        Logger.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (Logger.instance) {
                    return Logger.instance;
                }

                Logger.instance = new Logger(config);
                return Logger.instance;
            } catch (error) {
                throw new BaseError({
                    code: ErrorCodes.STORAGE_INIT,
                    message: 'Failed to initialize logger',
                    details: { error: error instanceof Error ? error.message : String(error) }
                });
            } finally {
                Logger.initializationPromise = null;
            }
        })();

        return Logger.initializationPromise;
    }

    /**
     * Creates a child logger with additional context
     */
    child(context: Record<string, unknown>): Logger {
        const childLogger = new Logger({
            minLevel: LogLevels.INFO,
            console: true
        });
        childLogger.logger = this.logger.child(context);
        return childLogger;
    }

    /**
     * Logs a debug message
     */
    debug(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.DEBUG, message, context);
    }

    /**
     * Logs an info message
     */
    info(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.INFO, message, context);
    }

    /**
     * Logs a warning message
     */
    warn(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.WARN, message, context);
    }

    /**
     * Logs an error message
     */
    error(message: string, error?: unknown, context?: Record<string, unknown>): void {
        const errorInfo = this.formatError(error);
        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
    }

    /**
     * Logs a fatal error message (maps to error level for Winston compatibility)
     */
    fatal(message: string, error?: unknown, context?: Record<string, unknown>): void {
        const errorInfo = this.formatError(error);
        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
    }

    /**
     * Creates the Winston logger instance
     */
    private createLogger(config: LoggerConfig): WinstonLogger {
        const loggerTransports = [];

        // Console transport
        if (config.console) {
            const formats = [format.simple()];
            if (!config.noColors) {
                formats.unshift(format.colorize());
            }
            loggerTransports.push(
                new transports.Console({
                    format: format.combine(...formats)
                })
            );
        }

        // File transport
        if (config.file && config.logDir) {
            // Ensure log directory exists with platform-appropriate permissions
            mkdirSync(config.logDir, { 
                recursive: true, 
                // Skip mode on Windows as it's ignored
                ...(process.platform !== 'win32' && { mode: 0o755 })
            });

            const errorLogPath = join(config.logDir, 'error.log');
            const combinedLogPath = join(config.logDir, 'combined.log');

            loggerTransports.push(
                new transports.File({
                    filename: errorLogPath,
                    level: LogLevels.ERROR,
                    maxsize: config.maxFileSize,
                    maxFiles: config.maxFiles,
                    tailable: true // Ensure logs can be read while being written
                }),
                new transports.File({
                    filename: combinedLogPath,
                    maxsize: config.maxFileSize,
                    maxFiles: config.maxFiles,
                    tailable: true
                })
            );
        }

        return createLogger({
            level: config.minLevel,
            format: format.combine(
                format.timestamp(),
                format.json()
            ),
            transports: loggerTransports,
            levels: winstonConfig.npm.levels // Use standard npm levels
        });
    }

    /**
     * Formats an error for logging
     */
    private formatError(error: unknown): Record<string, unknown> | undefined {
        if (!error) return undefined;

        if (error instanceof BaseError) {
            return {
                name: error.name,
                message: error.message,
                code: error.code,
                details: error.details,
                stack: error.stack,
                operation: error.operation,
                timestamp: Date.now()
            };
        }

        if (error instanceof Error) {
            return {
                name: error.name,
                message: error.message,
                stack: error.stack,
                timestamp: Date.now()
            };
        }

        if (error && typeof error === 'object') {
            try {
                return {
                    name: 'ObjectError',
                    message: JSON.stringify(error, null, 2),
                    raw: error,
                    timestamp: Date.now()
                };
            } catch (e) {
                return {
                    name: 'UnserializableError',
                    message: 'Error object could not be stringified',
                    type: typeof error,
                    timestamp: Date.now()
                };
            }
        }

        return {
            name: 'UnknownError',
            message: String(error),
            type: typeof error,
            timestamp: Date.now()
        };
    }

    /**
     * Internal log method
     */
    private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {
        if (this.isShuttingDown) return;

        try {
            // Ensure logger is working
            this.ensureLogger();

            // Ensure context is properly stringified
            const safeContext = context ? this.sanitizeContext(context) : undefined;
            
            this.logger.log({
                level,
                message,
                timestamp: Date.now(),
                ...safeContext
            });
        } catch (error) {
            // If logging fails, write to stderr as fallback
            const fallbackMessage = JSON.stringify({
                level,
                message,
                timestamp: Date.now(),
                error: this.formatError(error)
            });
            process.stderr.write(fallbackMessage + '\n');
        }
    }

    /**
     * Sanitizes context objects for logging
     */
    private sanitizeContext(context: Record<string, unknown>): Record<string, unknown> {
        const sanitized: Record<string, unknown> = {};
        
        for (const [key, value] of Object.entries(context)) {
            if (value instanceof Error || (value && typeof value === 'object')) {
                sanitized[key] = this.formatError(value);
            } else {
                sanitized[key] = value;
            }
        }
        
        return sanitized;
    }
}

/**
 * Creates a logger instance with default configuration
 */
export function createDefaultLogger(): Logger {
    try {
        return Logger.getInstance();
    } catch (error) {
        throw new BaseError({
            code: ErrorCodes.STORAGE_INIT,
            message: 'Failed to create default logger',
            details: { error: error instanceof Error ? error.message : String(error) }
        });
    }
}

/**
 * Re-export types
 */
export type { LogLevel, LoggerConfig } from '../types/logging.js';
export { LogLevels } from '../types/logging.js';

================
File: src/server/health-monitor.ts
================
/**
 * Health monitoring for system components
 */
import { Logger } from '../logging/index.js';
import { StorageMetrics } from '../types/storage.js';
import { Metrics } from './metrics-collector.js';
import { TaskStatus } from '../types/task.js';

export interface HealthConfig {
    checkInterval?: number;      // How often to run health checks (ms)
    failureThreshold?: number;   // How many consecutive failures before shutdown
    shutdownGracePeriod?: number; // How long to wait before force shutdown (ms)
    clientPingTimeout?: number;  // How long to wait for client ping (ms)
}

export interface HealthStatus {
    healthy: boolean;
    components: {
        storage: boolean;
        rateLimiter: boolean;
        metrics: boolean;
        clientConnected: boolean;
    };
    details?: Record<string, unknown>;
    timestamp: number;
    consecutiveFailures?: number;
    [key: string]: unknown;
}

export interface ComponentStatus {
    storage: StorageMetrics;
    rateLimiter: {
        current: number;
        limit: number;
        windowMs: number;
    };
    metrics: Metrics;
}

export class HealthMonitor {
    private logger: Logger;
    private checkInterval: NodeJS.Timeout | null = null;
    private lastClientPing: number = Date.now();
    private consecutiveFailures: number = 0;
    private readonly config: Required<HealthConfig>;
    private shutdownCallback?: () => Promise<void>;

    constructor(config: HealthConfig = {}) {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
        this.config = {
            checkInterval: config.checkInterval || 30000,      // 30 seconds
            failureThreshold: config.failureThreshold || 3,    // 3 strikes
            shutdownGracePeriod: config.shutdownGracePeriod || 5000, // 5 seconds
            clientPingTimeout: config.clientPingTimeout || 60000 // 1 minute
        };
    }

    /**
     * Start periodic health monitoring
     */
    start(shutdownCallback: () => Promise<void>): void {
        this.shutdownCallback = shutdownCallback;
        this.checkInterval = setInterval(() => this.runHealthCheck(), this.config.checkInterval);
        this.logger.info('Health monitoring started', {
            interval: this.config.checkInterval,
            failureThreshold: this.config.failureThreshold
        });
    }

    /**
     * Stop health monitoring
     */
    stop(): void {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
            this.checkInterval = null;
        }
        this.logger.info('Health monitoring stopped');
    }

    /**
     * Record a client ping
     */
    recordClientPing(): void {
        this.lastClientPing = Date.now();
        this.consecutiveFailures = 0; // Reset failures on successful ping
    }

    /**
     * Run a health check and handle failures
     */
    private async runHealthCheck(): Promise<void> {
        try {
            const status = await this.getCurrentStatus();
            const health = await this.check(status);

            if (!health.healthy) {
                this.consecutiveFailures++;
                this.logger.warn('Health check failed', {
                    consecutiveFailures: this.consecutiveFailures,
                    threshold: this.config.failureThreshold,
                    details: health.details
                });

                if (this.consecutiveFailures >= this.config.failureThreshold) {
                    await this.initiateShutdown();
                }
            } else {
                this.consecutiveFailures = 0;
            }
        } catch (error) {
            this.logger.error('Health check error', { error });
            this.consecutiveFailures++;
            if (this.consecutiveFailures >= this.config.failureThreshold) {
                await this.initiateShutdown();
            }
        }
    }

    /**
     * Get current status of all components
     */
    private async getCurrentStatus(): Promise<ComponentStatus> {
        return {
            storage: {
                tasks: {
                    total: 0,
                    byStatus: {
                        [TaskStatus.PENDING]: 0,
                        [TaskStatus.IN_PROGRESS]: 0,
                        [TaskStatus.COMPLETED]: 0,
                        [TaskStatus.FAILED]: 0,
                        [TaskStatus.BLOCKED]: 0
                    },
                    noteCount: 0,
                    dependencyCount: 0
                },
                storage: {
                    totalSize: 0,
                    pageSize: 4096,
                    pageCount: 0,
                    walSize: 0,
                    cache: {
                        hitRate: 0,
                        memoryUsage: 0,
                        entryCount: 0
                    }
                }
            },
            rateLimiter: { current: 0, limit: 100, windowMs: 60000 },
            metrics: {
                requests: {
                    total: 0,
                    success: 0,
                    failed: 0,
                    avgDuration: 0
                },
                tools: {}
            }
        };
    }

    /**
     * Initiate graceful shutdown
     */
    private async initiateShutdown(): Promise<void> {
        this.logger.error('Initiating shutdown due to health check failures', {
            consecutiveFailures: this.consecutiveFailures
        });

        if (this.shutdownCallback) {
            try {
                const shutdownTimeout = setTimeout(() => {
                    this.logger.error('Force shutdown due to timeout');
                    process.exit(1);
                }, this.config.shutdownGracePeriod);

                await this.shutdownCallback();
                clearTimeout(shutdownTimeout);
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during shutdown', { error });
                process.exit(1);
            }
        } else {
            process.exit(1);
        }
    }

    /**
     * Check system health
     */
    async check(status: ComponentStatus): Promise<HealthStatus> {
        const now = Date.now();
        const health: HealthStatus = {
            healthy: true,
            components: {
                storage: true,
                rateLimiter: true,
                metrics: true,
                clientConnected: true
            },
            details: {},
            timestamp: now,
            consecutiveFailures: this.consecutiveFailures
        };

        // Check client connectivity
        const timeSinceLastPing = now - this.lastClientPing;
        if (timeSinceLastPing > this.config.clientPingTimeout) {
            health.components.clientConnected = false;
            health.healthy = false;
            health.details!.client = `No ping received for ${Math.round(timeSinceLastPing / 1000)}s`;
        }

        try {
            try {
                // Check storage health with safe access
                const hasStorageMetrics = status.storage?.tasks && status.storage?.storage;
                if (!hasStorageMetrics) {
                    health.components.storage = false;
                    health.healthy = false;
                    health.details!.storage = 'Storage metrics unavailable';
                }

                // Check rate limiter with safe defaults
                const rateLimiter = status.rateLimiter || { current: 0, limit: 100 };
                if (rateLimiter.current >= rateLimiter.limit) {
                    health.components.rateLimiter = false;
                    health.healthy = false;
                    health.details!.rateLimiter = 'Rate limit reached';
                }

                // Check metrics with safe calculation
                const metrics = status.metrics?.requests || { failed: 0, total: 0 };
                const errorRate = metrics.total > 0 ? metrics.failed / metrics.total : 0;
                if (errorRate > 0.1) { // More than 10% error rate
                    health.components.metrics = false;
                    health.healthy = false;
                    health.details!.metrics = `High error rate: ${(errorRate * 100).toFixed(2)}%`;
                }
            } catch (error) {
                // Log specific component check errors but continue
                this.logger.error('Component check error', { error });
                health.healthy = false;
                health.details!.error = error instanceof Error ? error.message : String(error);
            }

            this.logger.debug('Health check completed', { health });
            return health;
        } catch (error) {
            this.logger.error('Health check failed', { error });
            return {
                healthy: false,
                components: {
                    storage: false,
                    rateLimiter: false,
                    metrics: false,
                    clientConnected: false
                },
                details: {
                    error: error instanceof Error ? error.message : String(error)
                },
                timestamp: Date.now()
            };
        }
    }
}

================
File: src/server/index.ts
================
/**
 * Server module for Atlas MCP Server
 * Handles server initialization, transport setup, and graceful shutdown
 */
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
    CallToolRequestSchema,
    ErrorCode,
    ListToolsRequestSchema,
    McpError,
    Request
} from '@modelcontextprotocol/sdk/types.js';
import { Logger } from '../logging/index.js';
import { RateLimiter } from './rate-limiter.js';
import { HealthMonitor, ComponentStatus } from './health-monitor.js';
import { MetricsCollector, MetricEvent } from './metrics-collector.js';
import { RequestTracer, TraceEvent } from './request-tracer.js';

export interface ServerConfig {
    name: string;
    version: string;
    maxRequestsPerMinute?: number;
    requestTimeout?: number;
    shutdownTimeout?: number;
}

export interface ToolHandler {
    listTools: () => Promise<any>;
    handleToolCall: (request: Request) => Promise<any>;
    getStorageMetrics: () => Promise<any>;
    clearCaches?: () => Promise<void>;
    cleanup?: () => Promise<void>;
}

/**
 * AtlasServer class encapsulates MCP server functionality
 * Handles server lifecycle, transport, and error management
 */
export class AtlasServer {
    private static instance: AtlasServer;
    private static isInitializing: boolean = false;
    private static serverPromise: Promise<void> | null = null;
    private static logger: Logger;
    private readonly server: Server;

    private static initLogger(): void {
        if (!AtlasServer.logger) {
            AtlasServer.logger = Logger.getInstance().child({ component: 'AtlasServer' });
        }
    }
    private readonly rateLimiter: RateLimiter;
    private readonly healthMonitor: HealthMonitor;
    private readonly metricsCollector: MetricsCollector;
    private readonly requestTracer: RequestTracer;
    private isShuttingDown: boolean = false;
    private isInitialized: boolean = false;
    private readonly activeRequests: Set<string> = new Set();
    private memoryMonitor?: NodeJS.Timeout;
    private readonly MAX_MEMORY_USAGE = 2 * 1024 * 1024 * 1024; // 2GB threshold
    private readonly MEMORY_CHECK_INTERVAL = 30000; // 30 seconds

    /**
     * Gets the singleton instance of AtlasServer
     */
    public static async getInstance(config: ServerConfig, toolHandler: ToolHandler): Promise<AtlasServer> {
        AtlasServer.initLogger();

        // Return existing instance if available
        if (AtlasServer.instance?.isInitialized) {
            AtlasServer.logger?.debug('Returning existing server instance');
            return AtlasServer.instance;
        }

        // If initialization is in progress, wait for it
        if (AtlasServer.isInitializing) {
            AtlasServer.logger?.debug('Server initialization in progress, waiting...');
            await AtlasServer.serverPromise;
            return AtlasServer.instance;
        }

        AtlasServer.isInitializing = true;
        AtlasServer.serverPromise = (async () => {
            try {
                AtlasServer.logger?.info('Starting server initialization');
                if (!AtlasServer.instance) {
                    AtlasServer.instance = new AtlasServer(config, toolHandler);
                }
                await AtlasServer.instance.initializeServer();
            } catch (error) {
                throw new McpError(
                    ErrorCode.InternalError,
                    `Failed to initialize AtlasServer: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                AtlasServer.isInitializing = false;
                AtlasServer.serverPromise = null;
            }
        })();

        await AtlasServer.serverPromise;
        return AtlasServer.instance;
    }

    /**
     * Creates a new AtlasServer instance
     */
    private constructor(
        private readonly config: ServerConfig,
        private readonly toolHandler: ToolHandler
    ) {
        // Initialize components
        this.rateLimiter = new RateLimiter(config.maxRequestsPerMinute || 600);
        this.healthMonitor = new HealthMonitor({
            checkInterval: 30000,
            failureThreshold: 3,
            shutdownGracePeriod: config.shutdownTimeout || 30000,
            clientPingTimeout: 60000
        });
        this.metricsCollector = new MetricsCollector();
        this.requestTracer = new RequestTracer();

        // Initialize MCP server
        this.server = new Server(
            {
                name: config.name,
                version: config.version,
            },
            {
                capabilities: {
                    tools: {
                        create_task: {},
                        update_task: {},
                        delete_task: {},
                        get_tasks_by_status: {},
                        get_tasks_by_path: {},
                        get_subtasks: {},
                        bulk_task_operations: {},
                        clear_all_tasks: {},
                        vacuum_database: {},
                        repair_relationships: {}
                    },
                },
            }
        );

        this.setupErrorHandling();
        this.setupToolHandlers();
        this.setupHealthCheck();
        this.setupMemoryMonitoring();
    }

    /**
     * Sets up error handling for the server
     */
    private setupErrorHandling(): void {
        this.server.onerror = (error: unknown) => {
            const metricEvent: MetricEvent = {
                type: 'error',
                timestamp: Date.now(),
                error: error instanceof Error ? error.message : String(error)
            };
            this.metricsCollector.recordError(metricEvent);
            
            const errorContext = {
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                } : error,
                metrics: this.metricsCollector.getMetrics()
            };

            AtlasServer.logger.error('[MCP Error]', errorContext);
        };

        process.on('SIGINT', async () => {
            await this.shutdown();
        });

        process.on('SIGTERM', async () => {
            await this.shutdown();
        });

        process.on('unhandledRejection', (reason, promise) => {
            AtlasServer.logger.error('Unhandled Rejection:', {
                reason,
                promise,
                metrics: this.metricsCollector.getMetrics()
            });
        });

        process.on('uncaughtException', (error) => {
            const errorMessage = error instanceof Error 
                ? { name: error.name, message: error.message, stack: error.stack }
                : error && typeof error === 'object'
                    ? JSON.stringify(error)
                    : String(error);
            
            AtlasServer.logger.error('Uncaught Exception:', {
                error: errorMessage,
                metrics: this.metricsCollector.getMetrics()
            });
            this.shutdown().finally(() => process.exit(1));
        });
    }

    /**
     * Sets up tool request handlers with middleware
     */
    private setupToolHandlers(): void {
        // Handler for listing available tools
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const traceEvent: TraceEvent = {
                type: 'list_tools',
                timestamp: Date.now()
            };
            
            try {
                await this.rateLimiter.checkLimit();
                this.activeRequests.add(requestId);
                
                // Record client activity
                this.recordClientActivity();
                
                this.requestTracer.startTrace(requestId, traceEvent);
                const response = await this.toolHandler.listTools();
                
                const metricEvent: MetricEvent = {
                    type: 'list_tools',
                    timestamp: Date.now(),
                    duration: Date.now() - traceEvent.timestamp
                };
                this.metricsCollector.recordSuccess(metricEvent);

                return response;
            } catch (error) {
                this.handleToolError(error);
                throw error; // Ensure error propagation
            } finally {
                this.activeRequests.delete(requestId);
                this.requestTracer.endTrace(requestId, {
                    ...traceEvent,
                    timestamp: Date.now()
                });
            }
        });

        // Handler for tool execution requests
        this.server.setRequestHandler(CallToolRequestSchema, async (request: Request) => {
            if (!request.params?.name) {
                throw new McpError(ErrorCode.InvalidRequest, 'Missing tool name');
            }
            const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const traceEvent: TraceEvent = {
                type: 'tool_execution',
                tool: String(request.params.name),
                timestamp: Date.now()
            };
            
            try {
                if (this.isShuttingDown) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        'Server is shutting down'
                    );
                }

                await this.rateLimiter.checkLimit();
                this.activeRequests.add(requestId);
                
                // Record client activity
                this.recordClientActivity();
                
                this.requestTracer.startTrace(requestId, traceEvent);
                const response = await Promise.race([
                    this.toolHandler.handleToolCall(request),
                    this.createTimeout(this.config.requestTimeout || 30000)
                ]);
                
                const metricEvent: MetricEvent = {
                    type: 'tool_execution',
                    tool: String(request.params.name),
                    timestamp: Date.now(),
                    duration: Date.now() - traceEvent.timestamp
                };
                this.metricsCollector.recordSuccess(metricEvent);

                return response;
            } catch (error) {
                this.handleToolError(error);
                throw error; // Ensure error propagation
            } finally {
                this.activeRequests.delete(requestId);
                this.requestTracer.endTrace(requestId, {
                    ...traceEvent,
                    timestamp: Date.now()
                });
            }
        });
    }

    /**
     * Sets up health check endpoint
     */
    private setupHealthCheck(): void {
        // Start health monitor with shutdown callback
        this.healthMonitor.start(async () => {
            AtlasServer.logger.info('Health monitor triggered shutdown');
            await this.shutdown();
        });

        // Set up periodic status checks
        setInterval(async () => {
            try {
                const status: ComponentStatus = {
                    storage: await this.toolHandler.getStorageMetrics(),
                    rateLimiter: this.rateLimiter.getStatus(),
                    metrics: this.metricsCollector.getMetrics()
                };
                await this.healthMonitor.check(status);
            } catch (error) {
                AtlasServer.logger.error('Health check error:', { error });
            }
        }, 30000);
    }

    /**
     * Record client activity
     */
    private recordClientActivity(): void {
        this.healthMonitor.recordClientPing();
    }

    /**
     * Creates a timeout promise
     */
    private createTimeout(ms: number): Promise<never> {
        return new Promise((_, reject) => {
            setTimeout(() => {
                reject(new McpError(
                    ErrorCode.InternalError,
                    `Request timed out after ${ms}ms`
                ));
            }, ms);
        });
    }

    /**
     * Transforms errors into McpErrors
     */
    private handleToolError(error: unknown): void {
        const errorMessage = error instanceof Error 
            ? error.message 
            : error && typeof error === 'object'
                ? JSON.stringify(error)
                : String(error);

        const metricEvent: MetricEvent = {
            type: 'error',
            timestamp: Date.now(),
            error: errorMessage
        };
        this.metricsCollector.recordError(metricEvent);

        if (error instanceof McpError) {
            return;
        }

        const errorDetails = error instanceof Error 
            ? { name: error.name, message: error.message, stack: error.stack }
            : error && typeof error === 'object'
                ? JSON.stringify(error)
                : String(error);

        AtlasServer.logger.error('Unexpected error in tool handler:', {
            error: errorDetails,
            metrics: this.metricsCollector.getMetrics()
        });
        
        throw new McpError(
            ErrorCode.InternalError,
            error instanceof Error ? error.message : 'An unexpected error occurred',
            error instanceof Error ? error.stack : undefined
        );
    }

    /**
     * Starts the server
     */
    private async initializeServer(): Promise<void> {
        if (this.isInitialized) {
            AtlasServer.logger.debug('Server already initialized');
            return;
        }

        try {
            const transport = new StdioServerTransport();
            await this.server.connect(transport);
            
            this.isInitialized = true;
            AtlasServer.logger.info(`${this.config.name} v${this.config.version} running on stdio`, {
                metrics: this.metricsCollector.getMetrics()
            });
        } catch (error) {
            AtlasServer.logger.error('Failed to start server:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            throw error;
        }
    }

    /**
     * Sets up memory monitoring to prevent leaks
     */
    private setupMemoryMonitoring(): void {
        this.memoryMonitor = setInterval(() => {
            const memUsage = process.memoryUsage();
            
            // Log memory stats
            AtlasServer.logger.debug('Memory usage:', {
                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`
            });

            // Trigger cleanup if memory usage is too high
            if (memUsage.heapUsed > this.MAX_MEMORY_USAGE) {
                AtlasServer.logger.warn('High memory usage detected, triggering cleanup', {
                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                    threshold: `${Math.round(this.MAX_MEMORY_USAGE / 1024 / 1024)}MB`
                });
                
                // Force garbage collection if available
                if (global.gc) {
                    AtlasServer.logger.info('Forcing garbage collection');
                    global.gc();
                }

                // Clear caches
                this.toolHandler.clearCaches?.();
            }
        }, this.MEMORY_CHECK_INTERVAL);
    }

    /**
     * Gracefully shuts down the server and cleans up resources
     */
    async shutdown(): Promise<void> {
        if (this.isShuttingDown) {
            return;
        }

        this.isShuttingDown = true;
        AtlasServer.logger.info('Starting graceful shutdown...');

        try {
            // Wait for active requests to complete
            const timeout = this.config.shutdownTimeout || 30000;
            const shutdownStart = Date.now();

            while (this.activeRequests.size > 0) {
                if (Date.now() - shutdownStart > timeout) {
                    AtlasServer.logger.warn('Shutdown timeout reached, forcing shutdown', {
                        activeRequests: this.activeRequests.size
                    });
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Clear monitoring intervals
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
            }
            
            // Clean up resources
            await this.toolHandler.cleanup?.();
            
            // Close server
            await this.server.close();
            
            // Force final garbage collection
            if (global.gc) {
                global.gc();
            }
            AtlasServer.logger.info('Server closed successfully', {
                metrics: this.metricsCollector.getMetrics()
            });
        } catch (error) {
            AtlasServer.logger.error('Error during shutdown:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            throw error;
        }
    }
}

================
File: src/server/metrics-collector.ts
================
/**
 * Metrics collection for monitoring and analysis
 */
import { Logger } from '../logging/index.js';

export interface MetricEvent {
    type: string;
    tool?: string;
    timestamp: number;
    duration?: number;
    success?: boolean;
    error?: string;
    [key: string]: unknown;
}

export interface Metrics {
    requests: {
        total: number;
        success: number;
        failed: number;
        avgDuration: number;
    };
    tools: Record<string, {
        total: number;
        success: number;
        failed: number;
        avgDuration: number;
        errors: Record<string, number>;
    }>;
}

export class MetricsCollector {
    private events: MetricEvent[] = [];
    private logger: Logger;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'MetricsCollector' });
    }

    recordSuccess(event: MetricEvent): void {
        this.events.push({
            ...event,
            success: true,
            timestamp: event.timestamp || Date.now()
        });
        this.logger.debug('Recorded success metric', { event });
    }

    recordError(event: MetricEvent): void {
        this.events.push({
            ...event,
            success: false,
            timestamp: event.timestamp || Date.now()
        });
        this.logger.debug('Recorded error metric', { event });
    }

    getMetrics(): Metrics {
        const now = Date.now();
        const recentEvents = this.events.filter(e => now - e.timestamp < 3600000); // Last hour

        const metrics: Metrics = {
            requests: {
                total: recentEvents.length,
                success: recentEvents.filter(e => e.success).length,
                failed: recentEvents.filter(e => !e.success).length,
                avgDuration: this.calculateAvgDuration(recentEvents)
            },
            tools: {}
        };

        // Calculate per-tool metrics
        const toolEvents = recentEvents.filter(e => e.tool);
        const tools = new Set(toolEvents.map(e => e.tool!));

        for (const tool of tools) {
            const toolMetrics = toolEvents.filter(e => e.tool === tool);
            metrics.tools[tool] = {
                total: toolMetrics.length,
                success: toolMetrics.filter(e => e.success).length,
                failed: toolMetrics.filter(e => !e.success).length,
                avgDuration: this.calculateAvgDuration(toolMetrics),
                errors: this.calculateErrorFrequency(toolMetrics)
            };
        }

        return metrics;
    }

    private calculateAvgDuration(events: MetricEvent[]): number {
        const eventsWithDuration = events.filter(e => e.duration);
        if (eventsWithDuration.length === 0) return 0;
        
        const total = eventsWithDuration.reduce((sum, e) => sum + (e.duration || 0), 0);
        return total / eventsWithDuration.length;
    }

    private calculateErrorFrequency(events: MetricEvent[]): Record<string, number> {
        const errors: Record<string, number> = {};
        
        for (const event of events) {
            if (!event.success && event.error) {
                errors[event.error] = (errors[event.error] || 0) + 1;
            }
        }
        
        return errors;
    }

    clearMetrics(): void {
        this.events = [];
        this.logger.debug('Cleared metrics');
    }
}

================
File: src/server/rate-limiter.ts
================
/**
 * Rate limiter for request throttling
 */
export class RateLimiter {
    private requests: number[] = [];
    private readonly windowMs = 60000; // 1 minute window

    constructor(private readonly maxRequests: number) {}

    /**
     * Checks if request is within rate limit
     * @throws Error if rate limit exceeded
     */
    async checkLimit(): Promise<void> {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.windowMs);

        if (this.requests.length >= this.maxRequests) {
            throw new Error('Rate limit exceeded');
        }

        this.requests.push(now);
    }

    /**
     * Gets current rate limiter status
     */
    getStatus(): { current: number; limit: number; windowMs: number } {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.windowMs);

        return {
            current: this.requests.length,
            limit: this.maxRequests,
            windowMs: this.windowMs
        };
    }

    /**
     * Resets rate limiter
     */
    reset(): void {
        this.requests = [];
    }
}

================
File: src/server/request-tracer.ts
================
/**
 * Request tracing for monitoring and debugging with memory management
 */
import { Logger } from '../logging/index.js';

export interface TracerConfig {
    maxTraces?: number;           // Maximum number of traces to store
    maxEventsPerTrace?: number;   // Maximum events per trace
    traceRetentionMs?: number;    // How long to keep traces
    cleanupIntervalMs?: number;   // How often to run cleanup
}

const DEFAULT_CONFIG: TracerConfig = {
    maxTraces: 1000,
    maxEventsPerTrace: 100,
    traceRetentionMs: 24 * 60 * 60 * 1000, // 24 hours
    cleanupIntervalMs: 60 * 60 * 1000      // 1 hour
};

export interface TraceEvent {
    type: string;
    tool?: string;
    timestamp: number;
    success?: boolean;
    error?: string;
    duration?: number;
    [key: string]: unknown;
}

export class RequestTracer {
    private traces: Map<string, TraceEvent[]> = new Map();
    private startTimes: Map<string, number> = new Map();
    private logger: Logger;
    private config: TracerConfig;
    private cleanupTimer!: NodeJS.Timeout;

    constructor(config: TracerConfig = {}) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.logger = Logger.getInstance().child({ component: 'RequestTracer' });

        // Start cleanup timer
        this.cleanupTimer = setInterval(
            () => this.cleanup(),
            this.config.cleanupIntervalMs ?? DEFAULT_CONFIG.cleanupIntervalMs!
        ) as unknown as NodeJS.Timeout;

        // Bind cleanup to process events
        process.on('SIGINT', () => this.destroy());
        process.on('SIGTERM', () => this.destroy());
    }

    /**
     * Cleanup old traces and enforce size limits
     */
    private cleanup(): void {
        const now = Date.now();
        const cutoff = now - (this.config.traceRetentionMs ?? DEFAULT_CONFIG.traceRetentionMs!);
        
        // Remove old traces
        for (const [requestId, _] of this.traces.entries()) {
            const startTime = this.startTimes.get(requestId);
            if (startTime && startTime < cutoff) {
                this.traces.delete(requestId);
                this.startTimes.delete(requestId);
                this.logger.debug('Cleaned up old trace', { requestId, age: now - startTime });
            }
        }

        // Enforce maximum traces limit
        const maxTraces = this.config.maxTraces ?? DEFAULT_CONFIG.maxTraces!;
        if (this.traces.size > maxTraces) {
            const sortedTraces = Array.from(this.startTimes.entries())
                .sort(([, a], [, b]) => b - a);
            
            const tracesToRemove = sortedTraces.slice(maxTraces);
            for (const [requestId] of tracesToRemove) {
                this.traces.delete(requestId);
                this.startTimes.delete(requestId);
                this.logger.debug('Removed excess trace', { requestId });
            }
        }
    }

    startTrace(requestId: string, event: TraceEvent): void {
        // Cleanup if we're at the limit
        if (this.traces.size >= (this.config.maxTraces ?? DEFAULT_CONFIG.maxTraces!)) {
            this.cleanup();
        }

        this.traces.set(requestId, [event]);
        this.startTimes.set(requestId, event.timestamp);
        this.logger.debug('Started trace', { requestId, event });
    }

    addEvent(requestId: string, event: TraceEvent): void {
        const events = this.traces.get(requestId) || [];
        
        // Enforce maximum events per trace
        const maxEvents = this.config.maxEventsPerTrace ?? DEFAULT_CONFIG.maxEventsPerTrace!;
        if (events.length >= maxEvents) {
            this.logger.warn('Maximum events per trace reached', { 
                requestId, 
                limit: maxEvents
            });
            return;
        }

        events.push(event);
        this.traces.set(requestId, events);
        this.logger.debug('Added trace event', { requestId, event });
    }

    endTrace(requestId: string, event: TraceEvent): void {
        const events = this.traces.get(requestId) || [];
        const startTime = this.startTimes.get(requestId);
        
        if (startTime) {
            event.duration = event.timestamp - startTime;
        }
        
        events.push(event);
        this.traces.set(requestId, events);
        this.logger.debug('Ended trace', { requestId, event });
    }

    getTrace(requestId: string): TraceEvent[] {
        return this.traces.get(requestId) || [];
    }

    getStartTime(requestId: string): number | undefined {
        return this.startTimes.get(requestId);
    }

    clearTrace(requestId: string): void {
        this.traces.delete(requestId);
        this.startTimes.delete(requestId);
        this.logger.debug('Cleared trace', { requestId });
    }

    /**
     * Get memory usage statistics
     */
    getStats(): {
        traceCount: number;
        totalEvents: number;
        memoryUsage: NodeJS.MemoryUsage;
    } {
        let totalEvents = 0;
        for (const events of this.traces.values()) {
            totalEvents += events.length;
        }

        return {
            traceCount: this.traces.size,
            totalEvents,
            memoryUsage: process.memoryUsage()
        };
    }

    /**
     * Cleanup resources and stop timers
     */
    destroy(): void {
        clearInterval(this.cleanupTimer);
        this.traces.clear();
        this.startTimes.clear();
        this.logger.info('Request tracer destroyed');
    }
}

================
File: src/storage/core/connection/health.ts
================
/**
 * Database connection health monitoring
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';

export interface ConnectionHealth {
    isHealthy: boolean;
    lastChecked: number;
    errorCount: number;
    avgResponseTime: number;
    lastError?: string;
}

export interface HealthMetrics {
    totalConnections: number;
    activeConnections: number;
    idleConnections: number;
    errorRate: number;
    avgResponseTime: number;
    healthyConnections: number;
    unhealthyConnections: number;
}

export class HealthMonitor {
    private readonly logger: Logger;
    private readonly healthChecks: Map<string, ConnectionHealth>;
    private readonly checkInterval: number;
    private readonly errorThreshold: number;
    private readonly responseTimeThreshold: number;
    private monitorInterval: NodeJS.Timeout | null;

    constructor(options: {
        checkInterval?: number;
        errorThreshold?: number;
        responseTimeThreshold?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
        this.healthChecks = new Map();
        this.checkInterval = options.checkInterval || 30000; // 30 seconds
        this.errorThreshold = options.errorThreshold || 5;
        this.responseTimeThreshold = options.responseTimeThreshold || 1000; // 1 second
        this.monitorInterval = null;
    }

    /**
     * Start health monitoring
     */
    start(): void {
        if (!this.monitorInterval) {
            this.monitorInterval = setInterval(
                () => this.runHealthChecks(),
                this.checkInterval
            );
            this.logger.info('Health monitoring started', {
                checkInterval: this.checkInterval,
                errorThreshold: this.errorThreshold,
                responseTimeThreshold: this.responseTimeThreshold
            });
        }
    }

    /**
     * Stop health monitoring
     */
    stop(): void {
        if (this.monitorInterval) {
            clearInterval(this.monitorInterval);
            this.monitorInterval = null;
            this.logger.info('Health monitoring stopped');
        }
    }

    /**
     * Register a connection for health monitoring
     */
    registerConnection(id: string): void {
        this.healthChecks.set(id, {
            isHealthy: true,
            lastChecked: Date.now(),
            errorCount: 0,
            avgResponseTime: 0
        });
        this.logger.debug('Connection registered for health monitoring', { id });
    }

    /**
     * Unregister a connection from health monitoring
     */
    unregisterConnection(id: string): void {
        this.healthChecks.delete(id);
        this.logger.debug('Connection unregistered from health monitoring', { id });
    }

    /**
     * Check health of a specific connection
     */
    async checkConnectionHealth(id: string, db: Database): Promise<ConnectionHealth> {
        const startTime = Date.now();
        let health = this.healthChecks.get(id) || {
            isHealthy: true,
            lastChecked: startTime,
            errorCount: 0,
            avgResponseTime: 0
        };

        try {
            // Run basic query to check connection
            await db.get('SELECT 1');

            // Update response time
            const responseTime = Date.now() - startTime;
            health.avgResponseTime = (health.avgResponseTime + responseTime) / 2;

            // Check if response time is acceptable
            const isResponseTimeOk = health.avgResponseTime <= this.responseTimeThreshold;

            // Update health status
            health = {
                ...health,
                isHealthy: isResponseTimeOk && health.errorCount < this.errorThreshold,
                lastChecked: Date.now(),
                errorCount: Math.max(0, health.errorCount - 1) // Slowly reduce error count on success
            };

            if (!isResponseTimeOk) {
                this.logger.warn('Connection response time exceeds threshold', {
                    id,
                    avgResponseTime: health.avgResponseTime,
                    threshold: this.responseTimeThreshold
                });
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            health = {
                ...health,
                isHealthy: false,
                lastChecked: Date.now(),
                errorCount: health.errorCount + 1,
                lastError: errorMessage
            };

            this.logger.error('Connection health check failed', {
                id,
                error: errorMessage,
                errorCount: health.errorCount
            });
        }

        this.healthChecks.set(id, health);
        return health;
    }

    /**
     * Run health checks on all registered connections
     */
    private async runHealthChecks(): Promise<void> {
        this.logger.debug('Running health checks', {
            connections: this.healthChecks.size
        });

        const metrics = this.getMetrics();
        this.logger.info('Health check metrics', { metrics });
    }

    /**
     * Get health metrics
     */
    getMetrics(): HealthMetrics {
        let totalResponseTime = 0;
        let totalErrors = 0;
        let healthyCount = 0;
        let unhealthyCount = 0;

        for (const health of this.healthChecks.values()) {
            totalResponseTime += health.avgResponseTime;
            totalErrors += health.errorCount;
            if (health.isHealthy) {
                healthyCount++;
            } else {
                unhealthyCount++;
            }
        }

        const totalConnections = this.healthChecks.size;
        return {
            totalConnections,
            activeConnections: 0, // Updated by connection pool
            idleConnections: 0,   // Updated by connection pool
            errorRate: totalConnections > 0 ? totalErrors / totalConnections : 0,
            avgResponseTime: totalConnections > 0 ? totalResponseTime / totalConnections : 0,
            healthyConnections: healthyCount,
            unhealthyConnections: unhealthyCount
        };
    }

    /**
     * Get health status for a specific connection
     */
    getConnectionHealth(id: string): ConnectionHealth | undefined {
        return this.healthChecks.get(id);
    }

    /**
     * Record an error for a connection
     */
    recordError(id: string, error: Error | string): void {
        const health = this.healthChecks.get(id);
        if (health) {
            health.errorCount++;
            health.lastError = error instanceof Error ? error.message : error;
            health.isHealthy = health.errorCount < this.errorThreshold;
            this.healthChecks.set(id, health);

            this.logger.warn('Connection error recorded', {
                id,
                errorCount: health.errorCount,
                isHealthy: health.isHealthy,
                error: health.lastError
            });
        }
    }

    /**
     * Reset error count for a connection
     */
    resetErrors(id: string): void {
        const health = this.healthChecks.get(id);
        if (health) {
            health.errorCount = 0;
            health.isHealthy = true;
            health.lastError = undefined;
            this.healthChecks.set(id, health);
            this.logger.debug('Connection errors reset', { id });
        }
    }
}

================
File: src/storage/core/connection/manager.ts
================
/**
 * Enhanced database connection manager with connection pooling
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { StorageConfig } from '../../../types/storage.js';
import { ConnectionPool } from './pool.js';

export interface ConnectionOptions {
    maxRetries?: number;
    retryDelay?: number;
    busyTimeout?: number;
    minConnections?: number;
    maxConnections?: number;
    idleTimeout?: number;
}

export class ConnectionManager {
    private readonly logger: Logger;
    private readonly maxRetries: number;
    private readonly retryDelay: number;
    private readonly busyTimeout: number;
    private readonly pool: ConnectionPool;

    constructor(config: StorageConfig, options: ConnectionOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionManager' });
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.busyTimeout = options.busyTimeout || 5000;
        
        this.pool = new ConnectionPool(config, {
            minConnections: options.minConnections,
            maxConnections: options.maxConnections,
            idleTimeout: options.idleTimeout
        });
    }

    /**
     * Initialize the connection manager and pool
     */
    async initialize(): Promise<void> {
        await this.pool.initialize();
    }

    /**
     * Execute a database operation with retries and connection management
     */
    async execute<T>(
        operation: (db: Database) => Promise<T>,
        context: string
    ): Promise<T> {
        let lastError: Error | undefined;
        let retryCount = 0;
        let db: Database | null = null;

        while (retryCount < this.maxRetries) {
            try {
                // Get connection from pool
                db = await this.pool.getConnection();

                // Execute operation
                const result = await operation(db);

                // Operation succeeded
                if (retryCount > 0) {
                    this.logger.info(`Operation succeeded after ${retryCount} retries`, {
                        context
                    });
                }

                return result;
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                retryCount++;

                // Log detailed error info
                const errorDetails = lastError instanceof Error ? {
                    name: lastError.name,
                    message: lastError.message,
                    code: (lastError as any).code,
                    errno: (lastError as any).errno
                } : lastError;

                this.logger.warn(`Operation failed${retryCount < this.maxRetries ? ', retrying' : ''}`, {
                    attempt: retryCount,
                    maxRetries: this.maxRetries,
                    error: errorDetails,
                    context
                });

                // Check if error is WAL-related
                const isWalError = lastError instanceof Error && 
                    (lastError.message.includes('WAL') || 
                     lastError.message.includes('journal_mode') ||
                     lastError.message.includes('Safety level'));

                if (retryCount < this.maxRetries) {
                    // Longer delay for WAL-related errors
                    const baseDelay = isWalError ? 1000 : this.retryDelay;
                    const delay = Math.min(
                        baseDelay * Math.pow(2, retryCount - 1) * (0.5 + Math.random()),
                        isWalError ? 10000 : 5000 // Higher cap for WAL errors
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            } finally {
                // Always release connection back to pool
                if (db) {
                    this.pool.releaseConnection(db);
                }
            }
        }

        // All retries failed
        throw createError(
            ErrorCodes.STORAGE_ERROR,
            'Operation failed',
            `Failed after ${this.maxRetries} retries: ${lastError?.message}`,
            lastError?.message
        );
    }

    /**
     * Execute a database operation with busy handling
     */
    async handleBusy(
        operation: () => Promise<void>,
        context: string
    ): Promise<void> {
        const startTime = Date.now();

        while (true) {
            try {
                await operation();
                return;
            } catch (error) {
                const elapsed = Date.now() - startTime;
                if (elapsed >= this.busyTimeout) {
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Operation timed out',
                        `Timed out after ${elapsed}ms: ${error instanceof Error ? error.message : String(error)}`
                    );
                }

                this.logger.warn('Database busy, waiting...', {
                    elapsed,
                    timeout: this.busyTimeout,
                    context
                });

                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }

    /**
     * Execute a database operation with retries
     */
    async executeWithRetry<T>(
        operation: () => Promise<T>,
        context: string
    ): Promise<T> {
        return this.execute(async () => operation(), context);
    }

    /**
     * Close the connection manager and pool
     */
    async close(): Promise<void> {
        await this.pool.close();
    }
}

================
File: src/storage/core/connection/pool.ts
================
/**
 * Database connection pool implementation
 */
import { Database, open } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { StorageConfig } from '../../../types/storage.js';
import { MonitoringConfig } from '../../monitoring/index.js';
import { ConnectionStateManager } from './state.js';
import { WALManager } from '../wal/manager.js';
import { join } from 'path';
import crypto from 'crypto';

interface PoolConnection {
    db: Database;
    id: string;
    inUse: boolean;
    lastUsed: number;
    createdAt: number;
    errorCount: number;
}

export class ConnectionPool {
    private readonly logger: Logger;
    private readonly config: StorageConfig;
    private readonly connections: Map<string, PoolConnection>;
    private readonly minConnections: number;
    private readonly maxConnections: number;
    private readonly idleTimeout: number;
    private readonly stateManager: ConnectionStateManager;
    private cleanupInterval: NodeJS.Timeout | null;
    private readonly dbPath: string;
    private readonly connectionIds = new WeakMap<Database, string>();
    private readonly verifiedConnections = new Set<string>();
    private isInitialized = false;

    constructor(config: StorageConfig & { monitoring?: MonitoringConfig }, options: {
        minConnections?: number;
        maxConnections?: number;
        idleTimeout?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionPool' });
        this.config = config;
        this.connections = new Map();
        this.minConnections = options.minConnections || 1;  // Minimum connections
        this.maxConnections = options.maxConnections || 5;  // Reduced maximum
        this.idleTimeout = options.idleTimeout || 30000;   // 30 seconds
        this.cleanupInterval = null;
        this.dbPath = join(config.baseDir, `${config.name}.db`);
        
        // Initialize state manager with monitoring config
        this.stateManager = ConnectionStateManager.getInstance({
            errorThreshold: config.monitoring?.healthCheck?.errorThreshold,
            responseTimeThreshold: config.monitoring?.healthCheck?.responseTimeThreshold
        });
    }

    /**
     * Get the unique ID for a database connection
     */
    getConnectionId(db: Database): string {
        let id = this.connectionIds.get(db);
        if (!id) {
            id = crypto.randomUUID();
            this.connectionIds.set(db, id);
        }
        return id;
    }

    /**
     * Initialize the connection pool
     */
    async initialize(): Promise<void> {
        try {
            if (this.isInitialized) {
                // On reconnect, just verify and warm up connections
                await this.warmupConnections();
                return;
            }

            // First-time initialization
            const sqlite3 = await import('sqlite3');
            const initDb = await open({
                filename: this.dbPath,
                driver: sqlite3.default.Database,
                mode: sqlite3.default.OPEN_READWRITE | sqlite3.default.OPEN_CREATE
            });

            try {
                // Enable WAL mode before creating any connections
                const walManager = WALManager.getInstance(this.dbPath);
                await walManager.enableWAL(initDb);
            } finally {
                await initDb.close();
            }

            // Create and warm up initial connections
            await this.warmupConnections();
            this.isInitialized = true;

            // Start monitoring
            this.stateManager.startMonitoring();
            this.cleanupInterval = setInterval(
                () => this.cleanupIdleConnections(),
                this.idleTimeout
            );

            this.logger.info('Connection pool initialized', {
                minConnections: this.minConnections,
                maxConnections: this.maxConnections,
                idleTimeout: this.idleTimeout
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to initialize connection pool', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize connection pool',
                errorMessage
            );
        }
    }

    /**
     * Get a connection from the pool
     */
    async getConnection(): Promise<Database> {
        // First try to find a healthy available connection
        for (const [id, conn] of this.connections.entries()) {
            if (!conn.inUse) {
                if (this.stateManager.isHealthy(id) && !this.stateManager.hasActiveTransaction(id)) {
                    conn.inUse = true;
                    conn.lastUsed = Date.now();
                    this.stateManager.markInUse(id);
                    this.logger.debug('Reusing healthy connection', { id });
                    return conn.db;
                }
            }
        }

        // If we haven't reached max connections, create a new one
        if (this.connections.size < this.maxConnections) {
            const conn = await this.createConnection();
            conn.inUse = true;
            this.stateManager.markInUse(conn.id);
            return conn.db;
        }

        // Otherwise wait for a connection to become available
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Connection timeout',
                    'Timed out waiting for available connection'
                ));
            }, this.config.connection?.busyTimeout || 2000);

            const checkConnection = async () => {
                for (const [id] of this.connections.entries()) {
                    const conn = this.connections.get(id);
                    if (conn && !conn.inUse) {
                        if (this.stateManager.isHealthy(id) && !this.stateManager.hasActiveTransaction(id)) {
                            clearTimeout(timeout);
                            conn.inUse = true;
                            conn.lastUsed = Date.now();
                            this.stateManager.markInUse(id);
                            this.logger.debug('Connection became available', { id });
                            resolve(conn.db);
                            return;
                        }
                    }
                }
                setTimeout(checkConnection, 100);
            };

            checkConnection();
        });
    }

    /**
     * Release a connection back to the pool
     */
    releaseConnection(db: Database): void {
        const id = this.getConnectionId(db);
        const conn = Array.from(this.connections.values()).find(c => c.id === id);
        
        if (conn) {
            conn.inUse = false;
            conn.lastUsed = Date.now();
            this.stateManager.markAvailable(id);
            this.logger.debug('Connection released', { id });
        }
    }

    /**
     * Create a new connection
     */
    private async createConnection(): Promise<PoolConnection> {
        const sqlite3 = await import('sqlite3');
        const id = crypto.randomUUID();
        
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.default.Database,
                mode: sqlite3.default.OPEN_READWRITE | sqlite3.default.OPEN_CREATE
            });

            // Store connection ID
            this.connectionIds.set(db, id);

            // Skip verification if already verified
            if (!this.verifiedConnections.has(id)) {
                try {
                    await db.get('SELECT 1');
                    this.verifiedConnections.add(id);
                    this.logger.debug('Connection verified', { id });
                } catch (error) {
                    const msg = error instanceof Error ? error.message : String(error);
                    this.logger.error('Failed to verify connection', { error: msg, id });
                    await db.close().catch(() => {}); // Attempt to close on error
                    throw error;
                }
            }

            const conn: PoolConnection = {
                db,
                id,
                inUse: false,
                lastUsed: Date.now(),
                createdAt: Date.now(),
                errorCount: 0
            };
            this.connections.set(id, conn);
            this.stateManager.registerConnection(id);
            this.logger.debug('Created new connection', { id });
            return conn;
        } catch (error) {
            this.logger.error('Failed to create connection', {
                id,
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    /**
     * Warm up connections by creating and verifying them
     */
    private async warmupConnections(): Promise<void> {
        const promises: Promise<void>[] = [];
        
        // Create minimum number of connections
        while (this.connections.size < this.minConnections) {
            promises.push(this.createConnection().then(() => {}));
        }

        // Wait for all connections to be created
        await Promise.all(promises);
    }

    /**
     * Clean up idle connections but maintain minimum
     */
    private async cleanupIdleConnections(): Promise<void> {
        const now = Date.now();
        const idsToRemove: string[] = [];

        // Find connections to remove
        for (const [id, conn] of this.connections.entries()) {
            if (!conn.inUse && 
                now - conn.lastUsed > this.idleTimeout &&
                this.connections.size > this.minConnections) {
                idsToRemove.push(id);
            }
        }

        // Remove connections
        for (const id of idsToRemove) {
            const conn = this.connections.get(id);
            if (conn) {
                try {
                    await conn.db.close();
                    this.connections.delete(id);
                    this.stateManager.unregisterConnection(id);
                    this.connectionIds.delete(conn.db);
                    this.logger.debug('Removed idle connection', { id });
                } catch (error) {
                    this.logger.error('Failed to close idle connection', {
                        id,
                        error: error instanceof Error ? error.message : String(error)
                    });
                }
            }
        }
    }

    /**
     * Get current pool metrics
     */
    getMetrics() {
        const metrics = this.stateManager.getMetrics();
        return metrics;
    }

    /**
     * Close all connections
     */
    async close(): Promise<void> {
        this.stateManager.stopMonitoring();
        
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }

        for (const [id, conn] of this.connections.entries()) {
            try {
                await conn.db.close();
                this.stateManager.unregisterConnection(id);
                this.connectionIds.delete(conn.db);
                this.logger.debug('Closed connection', { id });
            } catch (error) {
                this.logger.error('Failed to close connection', {
                    id,
                    error: error instanceof Error ? error.message : String(error)
                });
            }
        }

        this.connections.clear();
        this.logger.info('Connection pool closed');
    }
}

================
File: src/storage/core/connection/state.ts
================
/**
 * Connection state management
 */
import { Logger } from '../../../logging/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { ConnectionStats, MonitoringMetrics } from '../../../types/storage.js';

interface ConnectionState {
    id: string;
    inUse: boolean;
    hasActiveTransaction: boolean;
    lastUsed: number;
    createdAt: number;
    errorCount: number;
    totalQueries: number;
    totalResponseTime: number;
    lastError?: Error;
}

interface StateManagerOptions {
    errorThreshold?: number;
    responseTimeThreshold?: number;
}

export class ConnectionStateManager {
    private static instance: ConnectionStateManager;
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly states: Map<string, ConnectionState>;
    private readonly errorThreshold: number;
    private readonly responseTimeThreshold: number;
    private monitoringInterval: NodeJS.Timeout | null = null;
    private readonly DEFAULT_ERROR_THRESHOLD = 5;
    private readonly DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second
    private readonly MONITORING_INTERVAL = 30000; // 30 seconds

    private constructor(options: StateManagerOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionStateManager' });
        this.eventManager = EventManager.getInstance();
        this.states = new Map();
        this.errorThreshold = options.errorThreshold || this.DEFAULT_ERROR_THRESHOLD;
        this.responseTimeThreshold = options.responseTimeThreshold || this.DEFAULT_RESPONSE_TIME_THRESHOLD;
    }

    static getInstance(options?: StateManagerOptions): ConnectionStateManager {
        if (!ConnectionStateManager.instance) {
            ConnectionStateManager.instance = new ConnectionStateManager(options);
        }
        return ConnectionStateManager.instance;
    }

    /**
     * Register a new connection
     */
    registerConnection(id: string): void {
        this.states.set(id, {
            id,
            inUse: false,
            hasActiveTransaction: false,
            lastUsed: Date.now(),
            createdAt: Date.now(),
            errorCount: 0,
            totalQueries: 0,
            totalResponseTime: 0
        });
        this.logger.debug('Connection registered', { id });
    }

    /**
     * Unregister a connection
     */
    unregisterConnection(id: string): void {
        this.states.delete(id);
        this.logger.debug('Connection unregistered', { id });
    }

    /**
     * Mark connection as in use
     */
    markInUse(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.inUse = true;
            state.lastUsed = Date.now();
        }
    }

    /**
     * Mark connection as available
     */
    markAvailable(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.inUse = false;
            state.lastUsed = Date.now();
        }
    }

    /**
     * Start transaction on connection
     */
    startTransaction(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.hasActiveTransaction = true;
        }
    }

    /**
     * End transaction on connection
     */
    endTransaction(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.hasActiveTransaction = false;
        }
    }

    /**
     * Record query execution
     */
    recordQuery(id: string, duration: number, error?: Error): void {
        const state = this.states.get(id);
        if (state) {
            state.totalQueries++;
            state.totalResponseTime += duration;
            if (error) {
                state.errorCount++;
                state.lastError = error;
            }
        }
    }

    /**
     * Check if connection is healthy
     */
    isHealthy(id: string): boolean {
        const state = this.states.get(id);
        if (!state) return false;

        const avgResponseTime = state.totalQueries > 0
            ? state.totalResponseTime / state.totalQueries
            : 0;

        return state.errorCount < this.errorThreshold &&
               avgResponseTime < this.responseTimeThreshold;
    }

    /**
     * Get connection state
     */
    getState(id: string): ConnectionState | undefined {
        return this.states.get(id);
    }

    /**
     * Check if connection has active transaction
     */
    hasActiveTransaction(id: string): boolean {
        const state = this.states.get(id);
        return state?.hasActiveTransaction || false;
    }

    /**
     * Get connection metrics
     */
    getMetrics(): MonitoringMetrics {
        let totalActive = 0;
        let totalErrors = 0;
        let totalQueries = 0;
        let totalResponseTime = 0;

        for (const state of this.states.values()) {
            if (state.inUse) totalActive++;
            totalErrors += state.errorCount;
            totalQueries += state.totalQueries;
            totalResponseTime += state.totalResponseTime;
        }

        const connectionStats: ConnectionStats = {
            total: this.states.size,
            active: totalActive,
            idle: this.states.size - totalActive,
            errors: totalErrors,
            avgResponseTime: totalQueries > 0 ? totalResponseTime / totalQueries : 0
        };

        return {
            cache: {
                hits: 0,
                misses: 0,
                hitRate: 0,
                size: 0,
                memoryUsage: process.memoryUsage().heapUsed
            },
            connections: connectionStats,
            queries: {
                total: totalQueries,
                errors: totalErrors,
                avgExecutionTime: totalQueries > 0 ? totalResponseTime / totalQueries : 0,
                slowQueries: 0 // TODO: Track slow queries
            },
            timestamp: Date.now()
        };
    }

    /**
     * Start monitoring connections
     */
    startMonitoring(): void {
        if (this.monitoringInterval) return;

        this.monitoringInterval = setInterval(() => {
            this.checkConnections();
        }, this.MONITORING_INTERVAL);

        // Don't prevent process exit
        this.monitoringInterval.unref();

        this.logger.info('Connection monitoring started', {
            interval: this.MONITORING_INTERVAL,
            errorThreshold: this.errorThreshold,
            responseTimeThreshold: this.responseTimeThreshold
        });
    }

    /**
     * Stop monitoring connections
     */
    stopMonitoring(): void {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        this.logger.info('Connection monitoring stopped');
    }

    /**
     * Check connection health
     */
    private checkConnections(): void {
        const metrics = this.getMetrics();
        const unhealthyConnections: string[] = [];

        for (const [id, state] of this.states.entries()) {
            if (!this.isHealthy(id)) {
                unhealthyConnections.push(id);
                this.logger.warn('Unhealthy connection detected', {
                    id,
                    errorCount: state.errorCount,
                    avgResponseTime: state.totalQueries > 0
                        ? state.totalResponseTime / state.totalQueries
                        : 0,
                    lastError: state.lastError
                });
            }
        }

        // Emit monitoring event
        this.eventManager.emitSystemEvent({
            type: EventTypes.STORAGE_ANALYZE,
            timestamp: Date.now(),
            metadata: {
                component: 'ConnectionStateManager',
                memoryUsage: process.memoryUsage(),
                metrics: {
                    cache: metrics.cache,
                    connections: metrics.connections,
                    queries: metrics.queries,
                    timestamp: metrics.timestamp
                },
                operation: 'health_check',
                unhealthyConnections,
                healthStatus: {
                    isHealthy: unhealthyConnections.length === 0,
                    errorCount: metrics.connections.errors,
                    avgResponseTime: metrics.connections.avgResponseTime
                }
            }
        });

        // Log monitoring summary
        this.logger.info('Connection health check completed', {
            total: metrics.connections.total,
            active: metrics.connections.active,
            idle: metrics.connections.idle,
            errors: metrics.connections.errors,
            avgResponseTime: metrics.connections.avgResponseTime,
            unhealthyCount: unhealthyConnections.length
        });
    }

    /**
     * Clean up resources
     */
    cleanup(): void {
        this.stopMonitoring();
        this.states.clear();
    }
}

================
File: src/storage/core/query/builder.ts
================
/**
 * Type-safe SQL query builder
 */
import { Logger } from '../../../logging/index.js';

type SqlValue = string | number | boolean | null | undefined;
type SqlValues = Record<string, SqlValue>;

interface QueryPart {
    sql: string;
    values: SqlValue[];
}

export class QueryBuilder {
    private parts: QueryPart[] = [];
    private readonly logger: Logger;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'QueryBuilder' });
    }

    /**
     * Start SELECT query
     */
    select(columns: string | string[] = '*'): this {
        const cols = Array.isArray(columns) ? columns.join(', ') : columns;
        this.parts.push({
            sql: `SELECT ${cols}`,
            values: []
        });
        return this;
    }

    /**
     * Add FROM clause
     */
    from(table: string): this {
        this.parts.push({
            sql: `FROM ${table}`,
            values: []
        });
        return this;
    }

    /**
     * Add WHERE clause with parameterized values
     */
    where(conditions: SqlValues): this {
        const entries = Object.entries(conditions).filter(([_, value]) => value !== undefined);
        if (entries.length === 0) return this;

        const clauses = entries.map(([key]) => `${key} = ?`);
        const values = entries.map(([_, value]) => value);

        this.parts.push({
            sql: `WHERE ${clauses.join(' AND ')}`,
            values
        });
        return this;
    }

    /**
     * Add raw WHERE clause
     */
    whereRaw(sql: string, values: SqlValue[] = []): this {
        this.parts.push({
            sql: `WHERE ${sql}`,
            values
        });
        return this;
    }

    /**
     * Add ORDER BY clause
     */
    orderBy(column: string, direction: 'ASC' | 'DESC' = 'ASC'): this {
        this.parts.push({
            sql: `ORDER BY ${column} ${direction}`,
            values: []
        });
        return this;
    }

    /**
     * Add LIMIT clause
     */
    limit(limit: number): this {
        this.parts.push({
            sql: 'LIMIT ?',
            values: [limit]
        });
        return this;
    }

    /**
     * Add OFFSET clause
     */
    offset(offset: number): this {
        this.parts.push({
            sql: 'OFFSET ?',
            values: [offset]
        });
        return this;
    }

    /**
     * Start INSERT query
     */
    insertInto(table: string, data: SqlValues): this {
        const columns = Object.keys(data);
        const values = Object.values(data);
        const placeholders = Array(values.length).fill('?').join(', ');

        this.parts.push({
            sql: `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${placeholders})`,
            values
        });
        return this;
    }

    /**
     * Start UPDATE query
     */
    update(table: string, data: SqlValues): this {
        const entries = Object.entries(data).filter(([_, value]) => value !== undefined);
        const setClause = entries.map(([key]) => `${key} = ?`).join(', ');
        const values = entries.map(([_, value]) => value);

        this.parts.push({
            sql: `UPDATE ${table} SET ${setClause}`,
            values
        });
        return this;
    }

    /**
     * Start DELETE query
     */
    deleteFrom(table: string): this {
        this.parts.push({
            sql: `DELETE FROM ${table}`,
            values: []
        });
        return this;
    }

    /**
     * Add JOIN clause
     */
    join(table: string, condition: string): this {
        this.parts.push({
            sql: `JOIN ${table} ON ${condition}`,
            values: []
        });
        return this;
    }

    /**
     * Add LEFT JOIN clause
     */
    leftJoin(table: string, condition: string): this {
        this.parts.push({
            sql: `LEFT JOIN ${table} ON ${condition}`,
            values: []
        });
        return this;
    }

    /**
     * Add GROUP BY clause
     */
    groupBy(columns: string | string[]): this {
        const cols = Array.isArray(columns) ? columns.join(', ') : columns;
        this.parts.push({
            sql: `GROUP BY ${cols}`,
            values: []
        });
        return this;
    }

    /**
     * Add HAVING clause
     */
    having(conditions: SqlValues): this {
        const entries = Object.entries(conditions).filter(([_, value]) => value !== undefined);
        if (entries.length === 0) return this;

        const clauses = entries.map(([key]) => `${key} = ?`);
        const values = entries.map(([_, value]) => value);

        this.parts.push({
            sql: `HAVING ${clauses.join(' AND ')}`,
            values
        });
        return this;
    }

    /**
     * Build the final query
     */
    build(): { sql: string; values: SqlValue[] } {
        const sql = this.parts.map(p => p.sql).join(' ');
        const values = this.parts.flatMap(p => p.values);

        this.logger.debug('Built query', { sql, values });

        return { sql, values };
    }

    /**
     * Reset the builder
     */
    reset(): this {
        this.parts = [];
        return this;
    }

    /**
     * Create a new builder instance
     */
    static create(): QueryBuilder {
        return new QueryBuilder();
    }
}

================
File: src/storage/core/query/executor.ts
================
/**
 * SQL query executor with caching and performance monitoring
 */
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { QueryBuilder } from './builder.js';
import { ConnectionPool } from '../connection/pool.js';

interface QueryMetrics {
    queryCount: number;
    totalTime: number;
    avgTime: number;
    slowQueries: number;
    errors: number;
    cacheHits: number;
    cacheMisses: number;
}

interface QueryCacheEntry {
    result: any;
    timestamp: number;
    hits: number;
}

interface QueryCacheOptions {
    ttl?: number;
    key?: string;
}

export class QueryExecutor {
    private readonly logger: Logger;
    private readonly pool: ConnectionPool;
    private readonly queryCache: Map<string, QueryCacheEntry>;
    private readonly metrics: QueryMetrics;
    private readonly slowQueryThreshold: number;
    private readonly maxCacheSize: number;
    private readonly defaultCacheTTL: number;

    constructor(pool: ConnectionPool, options: {
        slowQueryThreshold?: number;
        maxCacheSize?: number;
        defaultCacheTTL?: number;
    } = {}) {  
        this.logger = Logger.getInstance().child({ component: 'QueryExecutor' });
        this.pool = pool;
        this.queryCache = new Map();
        this.metrics = {
            queryCount: 0,
            totalTime: 0,
            avgTime: 0,
            slowQueries: 0,
            errors: 0,
            cacheHits: 0,
            cacheMisses: 0
        };
        this.slowQueryThreshold = options.slowQueryThreshold || 100; // 100ms
        this.maxCacheSize = options.maxCacheSize || 1000;
        this.defaultCacheTTL = options.defaultCacheTTL || 60000; // 1 minute
    }

    /**
     * Execute a query with optional caching
     */
    async execute<T>(
        query: QueryBuilder | { sql: string; values: any[] },
        cache?: QueryCacheOptions
    ): Promise<T> {
        const { sql, values } = query instanceof QueryBuilder ? query.build() : query;
        const startTime = Date.now();
        const cacheKey = this.getCacheKey(sql, values, cache?.key);

        try {
            // Check cache first if enabled
            if (cache) {
                const cached = this.queryCache.get(cacheKey);
                if (cached && Date.now() - cached.timestamp < (cache.ttl || this.defaultCacheTTL)) {
                    cached.hits++;
                    this.metrics.cacheHits++;
                    return cached.result;
                }
                this.metrics.cacheMisses++;
            }

            // Get connection from pool
            const db = await this.pool.getConnection();

            try {
                // Execute query
                const result = await db.all(sql, ...values);

                // Update metrics
                const duration = Date.now() - startTime;
                this.updateMetrics(duration);

                // Log slow queries
                if (duration > this.slowQueryThreshold) {
                    this.logger.warn('Slow query detected', {
                        sql,
                        values,
                        duration,
                        threshold: this.slowQueryThreshold
                    });
                }

                // Cache result if enabled
                if (cache) {
                    this.cacheResult(cacheKey, result);
                }

                // Type assertion since we know the shape matches T
                return result as unknown as T;
            } finally {
                // Always release connection back to pool
                this.pool.releaseConnection(db);
            }
        } catch (error) {
            this.metrics.errors++;
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Query execution failed', {
                sql,
                values,
                error: errorMessage,
                duration: Date.now() - startTime
            });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Query execution failed',
                errorMessage
            );
        }
    }

    /**
     * Execute a query that returns a single row
     */
    async get<T>(
        query: QueryBuilder | { sql: string; values: any[] },
        cache?: QueryCacheOptions
    ): Promise<T | null> {
        const result = await this.execute<T[]>(query, cache);
        return result[0] || null;
    }

    /**
     * Execute a write query (INSERT, UPDATE, DELETE)
     */
    async run(
        query: QueryBuilder | { sql: string; values: any[] }
    ): Promise<void> {
        const { sql, values } = query instanceof QueryBuilder ? query.build() : query;
        const startTime = Date.now();

        try {
            const db = await this.pool.getConnection();

            try {
                await db.run(sql, ...values);

                // Update metrics
                const duration = Date.now() - startTime;
                this.updateMetrics(duration);

                // Log slow queries
                if (duration > this.slowQueryThreshold) {
                    this.logger.warn('Slow write query detected', {
                        sql,
                        values,
                        duration,
                        threshold: this.slowQueryThreshold
                    });
                }
            } finally {
                this.pool.releaseConnection(db);
            }
        } catch (error) {
            this.metrics.errors++;
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Write query failed', {
                sql,
                values,
                error: errorMessage,
                duration: Date.now() - startTime
            });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Write query failed',
                errorMessage
            );
        }
    }

    /**
     * Execute multiple queries in a transaction
     */
    async transaction<T>(callback: (executor: QueryExecutor) => Promise<T>): Promise<T> {
        const db = await this.pool.getConnection();

        try {
            await db.run('BEGIN IMMEDIATE');
            const result = await callback(this);
            await db.run('COMMIT');
            return result;
        } catch (error) {
            try {
                await db.run('ROLLBACK');
            } catch (rollbackError) {
                this.logger.error('Failed to rollback transaction', {
                    error: rollbackError instanceof Error ? rollbackError.message : String(rollbackError),
                    originalError: error instanceof Error ? error.message : String(error)
                });
            }
            throw error;
        } finally {
            this.pool.releaseConnection(db);
        }
    }

    /**
     * Get query execution metrics
     */
    getMetrics(): QueryMetrics {
        return { ...this.metrics };
    }

    /**
     * Clear query cache
     */
    clearCache(): void {
        this.queryCache.clear();
        this.logger.debug('Query cache cleared');
    }

    /**
     * Reset metrics
     */
    resetMetrics(): void {
        Object.assign(this.metrics, {
            queryCount: 0,
            totalTime: 0,
            avgTime: 0,
            slowQueries: 0,
            errors: 0,
            cacheHits: 0,
            cacheMisses: 0
        });
        this.logger.debug('Query metrics reset');
    }

    private updateMetrics(duration: number): void {
        this.metrics.queryCount++;
        this.metrics.totalTime += duration;
        this.metrics.avgTime = this.metrics.totalTime / this.metrics.queryCount;
        if (duration > this.slowQueryThreshold) {
            this.metrics.slowQueries++;
        }
    }

    private getCacheKey(sql: string, values: any[], key?: string): string {
        return key || `${sql}:${JSON.stringify(values)}`;
    }

    private cacheResult(key: string, result: any): void {
        // Evict oldest entry if cache is full
        if (this.queryCache.size >= this.maxCacheSize) {
            let oldestKey = '';
            let oldestTime = Date.now();

            for (const [k, entry] of this.queryCache.entries()) {
                if (entry.timestamp < oldestTime) {
                    oldestTime = entry.timestamp;
                    oldestKey = k;
                }
            }

            if (oldestKey) {
                this.queryCache.delete(oldestKey);
            }
        }

        // Add new entry
        this.queryCache.set(key, {
            result,
            timestamp: Date.now(),
            hits: 1
        });
    }
}

================
File: src/storage/core/query/optimizer.ts
================
/**
 * SQL query optimizer for better performance
 */
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { Database } from 'sqlite';

interface QueryPlan {
    details: string[];
    cost: number;
    rows: number;
    indexes: string[];
}

interface OptimizationSuggestion {
    type: 'index' | 'rewrite' | 'schema';
    description: string;
    impact: 'high' | 'medium' | 'low';
    suggestion: string;
}

export class QueryOptimizer {
    private readonly logger: Logger;
    private readonly costThreshold: number;
    private readonly indexStats: Map<string, {
        usage: number;
        lastUsed: number;
    }>;

    constructor(options: {
        costThreshold?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'QueryOptimizer' });
        this.costThreshold = options.costThreshold || 1000;
        this.indexStats = new Map();
    }

    /**
     * Analyze a query and get its execution plan
     */
    async analyzeQuery(
        db: Database,
        sql: string,
        values: any[] = []
    ): Promise<QueryPlan> {
        try {
            // Get query plan
            const plan = await db.all(`EXPLAIN QUERY PLAN ${sql}`, ...values);
            
            // Parse plan details
            const details = plan.map(row => row.detail);
            const indexes = this.extractIndexes(details);
            
            // Estimate cost and rows
            const cost = this.estimateCost(details);
            const rows = this.estimateRows(details);

            // Update index usage stats
            this.updateIndexStats(indexes);

            return { details, cost, rows, indexes };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to analyze query', {
                sql,
                values,
                error: errorMessage
            });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to analyze query',
                errorMessage
            );
        }
    }

    /**
     * Get optimization suggestions for a query
     */
    async optimizeQuery(
        db: Database,
        sql: string,
        values: any[] = []
    ): Promise<OptimizationSuggestion[]> {
        const suggestions: OptimizationSuggestion[] = [];
        const plan = await this.analyzeQuery(db, sql, values);

        // Check if query cost is above threshold
        if (plan.cost > this.costThreshold) {
            // Check for missing indexes
            const missingIndexes = this.findMissingIndexes(plan.details);
            if (missingIndexes.length > 0) {
                suggestions.push({
                    type: 'index',
                    description: 'Missing indexes detected',
                    impact: 'high',
                    suggestion: `Consider adding indexes for: ${missingIndexes.join(', ')}`
                });
            }

            // Check for table scans
            if (this.hasTableScan(plan.details)) {
                suggestions.push({
                    type: 'rewrite',
                    description: 'Full table scan detected',
                    impact: 'high',
                    suggestion: 'Add WHERE clause or index to avoid table scan'
                });
            }

            // Check for suboptimal joins
            if (this.hasSuboptimalJoin(plan.details)) {
                suggestions.push({
                    type: 'rewrite',
                    description: 'Suboptimal join detected',
                    impact: 'medium',
                    suggestion: 'Consider rewriting join or adding index on join columns'
                });
            }
        }

        // Check for unused indexes
        const unusedIndexes = await this.findUnusedIndexes(db);
        if (unusedIndexes.length > 0) {
            suggestions.push({
                type: 'schema',
                description: 'Unused indexes detected',
                impact: 'low',
                suggestion: `Consider removing unused indexes: ${unusedIndexes.join(', ')}`
            });
        }

        return suggestions;
    }

    /**
     * Get index usage statistics
     */
    getIndexStats() {
        return new Map(this.indexStats);
    }

    /**
     * Reset index usage statistics
     */
    resetIndexStats(): void {
        this.indexStats.clear();
    }

    private extractIndexes(details: string[]): string[] {
        const indexes: string[] = [];
        for (const detail of details) {
            const match = detail.match(/USING (?:INDEX|COVERING INDEX) (\w+)/i);
            if (match) {
                indexes.push(match[1]);
            }
        }
        return indexes;
    }

    private estimateCost(details: string[]): number {
        let cost = 0;
        for (const detail of details) {
            // Estimate cost based on operations
            if (detail.includes('SCAN')) cost += 100;
            if (detail.includes('SEARCH')) cost += 10;
            if (detail.includes('TEMP')) cost += 50;
            if (detail.includes('SORT')) cost += 30;
        }
        return cost;
    }

    private estimateRows(details: string[]): number {
        let maxRows = 0;
        for (const detail of details) {
            const match = detail.match(/~(\d+) rows/);
            if (match) {
                maxRows = Math.max(maxRows, parseInt(match[1], 10));
            }
        }
        return maxRows;
    }

    private updateIndexStats(indexes: string[]): void {
        const now = Date.now();
        for (const index of indexes) {
            const stats = this.indexStats.get(index) || { usage: 0, lastUsed: now };
            stats.usage++;
            stats.lastUsed = now;
            this.indexStats.set(index, stats);
        }
    }

    private findMissingIndexes(details: string[]): string[] {
        const missing: string[] = [];
        for (const detail of details) {
            // Look for operations that could benefit from an index
            if (detail.includes('SCAN') && !detail.includes('COVERING INDEX')) {
                const match = detail.match(/ON (\w+)/);
                if (match) {
                    const table = match[1];
                    const cols = this.extractFilterColumns(detail);
                    if (cols.length > 0) {
                        missing.push(`${table}(${cols.join(', ')})`);
                    }
                }
            }
        }
        return missing;
    }

    private extractFilterColumns(detail: string): string[] {
        const cols: string[] = [];
        // Extract columns from WHERE/JOIN conditions
        const matches = detail.match(/(?:WHERE|ON|USING|ORDER BY) (\w+)/g);
        if (matches) {
            for (const match of matches) {
                const col = match.split(' ')[1];
                if (col && !cols.includes(col)) {
                    cols.push(col);
                }
            }
        }
        return cols;
    }

    private hasTableScan(details: string[]): boolean {
        return details.some(d => 
            d.includes('SCAN') && !d.includes('INDEX') && !d.includes('PRIMARY KEY')
        );
    }

    private hasSuboptimalJoin(details: string[]): boolean {
        return details.some(d => 
            d.includes('NESTED LOOP') || 
            (d.includes('JOIN') && !d.includes('USING INDEX'))
        );
    }

    private async findUnusedIndexes(db: Database): Promise<string[]> {
        const unused: string[] = [];
        
        // Get all indexes
        const indexes = await db.all(`
            SELECT name FROM sqlite_master 
            WHERE type = 'index' 
            AND sql IS NOT NULL
        `);

        const now = Date.now();
        const threshold = 7 * 24 * 60 * 60 * 1000; // 7 days

        for (const { name } of indexes) {
            const stats = this.indexStats.get(name);
            if (!stats || 
                stats.usage === 0 || 
                (now - stats.lastUsed > threshold && stats.usage < 10)) {
                unused.push(name);
            }
        }

        return unused;
    }
}

================
File: src/storage/core/schema/backup.ts
================
/**
 * Database backup and recovery system
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { promises as fs } from 'fs';
import { join, basename } from 'path';

export interface BackupMetadata {
    timestamp: number;
    version: number;
    size: number;
    checksum: string;
    comment?: string;
}

export interface BackupOptions {
    compress?: boolean;
    vacuum?: boolean;
    comment?: string;
}

export interface RestoreOptions {
    force?: boolean;
    verify?: boolean;
}

export class BackupManager {
    private readonly logger: Logger;
    private readonly backupDir: string;
    private readonly maxBackups: number;

    constructor(options: {
        backupDir: string;
        maxBackups?: number;
    }) {
        this.logger = Logger.getInstance().child({ component: 'BackupManager' });
        this.backupDir = options.backupDir;
        this.maxBackups = options.maxBackups || 10;
    }

    /**
     * Initialize backup system
     */
    async initialize(): Promise<void> {
        try {
            // Create backup directory if it doesn't exist with platform-appropriate permissions
            await fs.mkdir(this.backupDir, { 
                recursive: true,
                // Skip mode on Windows as it's ignored
                ...(process.platform !== 'win32' && { mode: 0o755 })
            });

            // Verify backup directory is writable
            await fs.access(this.backupDir, fs.constants.W_OK);

            this.logger.info('Backup system initialized', {
                backupDir: this.backupDir,
                maxBackups: this.maxBackups
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to initialize backup system', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize backup system',
                errorMessage
            );
        }
    }

    /**
     * Create a backup
     */
    async createBackup(
        db: Database,
        dbPath: string,
        options: BackupOptions = {}
    ): Promise<string> {
        const timestamp = Date.now();
        const backupName = `backup_${timestamp}.db`;
        const backupPath = join(this.backupDir, backupName);

        try {
            // Ensure database is in a consistent state
            await db.run('PRAGMA wal_checkpoint(TRUNCATE)');

            // Vacuum database if requested
            if (options.vacuum) {
                await db.run('VACUUM');
            }

            // Create backup
            await this.copyDatabase(dbPath, backupPath);

            // Calculate checksum
            const checksum = await this.calculateChecksum(backupPath);

            // Save metadata
            const metadata: BackupMetadata = {
                timestamp,
                version: await this.getCurrentVersion(db),
                size: (await fs.stat(backupPath)).size,
                checksum,
                comment: options.comment
            };
            await this.saveMetadata(backupName, metadata);

            // Compress if requested
            if (options.compress) {
                await this.compressBackup(backupPath);
            }

            // Clean up old backups
            await this.cleanupOldBackups();

            this.logger.info('Backup created successfully', {
                backup: backupName,
                size: metadata.size,
                compressed: options.compress
            });

            return backupPath;
        } catch (error) {
            // Clean up failed backup
            try {
                await fs.unlink(backupPath);
            } catch {
                // Ignore cleanup errors
            }

            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to create backup', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to create backup',
                errorMessage
            );
        }
    }

    /**
     * Restore from backup
     */
    async restoreBackup(
        db: Database,
        dbPath: string,
        backupPath: string,
        options: RestoreOptions = {}
    ): Promise<void> {
        try {
            // Verify backup exists
            await fs.access(backupPath);

            // Get backup metadata
            const backupName = basename(backupPath);
            const metadata = await this.getMetadata(backupName);

            if (!metadata) {
                throw new Error('Backup metadata not found');
            }

            // Verify backup if requested
            if (options.verify) {
                const checksum = await this.calculateChecksum(backupPath);
                if (checksum !== metadata.checksum) {
                    throw new Error('Backup checksum verification failed');
                }
            }

            // Close database connection
            await db.close();

            // Create backup of current database
            const currentBackupPath = `${dbPath}.bak`;
            await this.copyDatabase(dbPath, currentBackupPath);

            try {
                // Restore backup
                await this.copyDatabase(backupPath, dbPath);

                this.logger.info('Backup restored successfully', {
                    backup: backupName,
                    version: metadata.version
                });
            } catch (error) {
                // Restore failed, revert to original
                await this.copyDatabase(currentBackupPath, dbPath);
                throw error;
            } finally {
                // Clean up temporary backup
                try {
                    await fs.unlink(currentBackupPath);
                } catch {
                    // Ignore cleanup errors
                }
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to restore backup', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to restore backup',
                errorMessage
            );
        }
    }

    /**
     * List available backups
     */
    async listBackups(): Promise<{
        name: string;
        metadata: BackupMetadata;
    }[]> {
        try {
            const files = await fs.readdir(this.backupDir);
            const backups = [];

            for (const file of files) {
                if (file.startsWith('backup_') && file.endsWith('.db')) {
                    const metadata = await this.getMetadata(file);
                    if (metadata) {
                        backups.push({ name: file, metadata });
                    }
                }
            }

            return backups.sort((a, b) => b.metadata.timestamp - a.metadata.timestamp);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to list backups', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to list backups',
                errorMessage
            );
        }
    }

    /**
     * Delete a backup
     */
    async deleteBackup(backupName: string): Promise<void> {
        try {
            const backupPath = join(this.backupDir, backupName);
            await fs.unlink(backupPath);

            // Delete metadata
            const metadataPath = `${backupPath}.meta`;
            try {
                await fs.unlink(metadataPath);
            } catch {
                // Ignore metadata deletion errors
            }

            this.logger.info('Backup deleted', { backup: backupName });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to delete backup', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to delete backup',
                errorMessage
            );
        }
    }

    private async getCurrentVersion(db: Database): Promise<number> {
        const result = await db.get<{ version: number }>(
            'SELECT MAX(version) as version FROM migrations'
        );
        return result?.version || 0;
    }

    private async copyDatabase(source: string, destination: string): Promise<void> {
        // On Windows, ensure source file handle is closed before copying
        if (process.platform === 'win32') {
            try {
                await fs.access(destination);
                // If destination exists, ensure it's not locked
                await fs.unlink(destination).catch(() => {});
            } catch (error) {
                // Ignore if destination doesn't exist
            }
        }
        await fs.copyFile(source, destination);
    }

    private async calculateChecksum(filePath: string): Promise<string> {
        const { createHash } = await import('crypto');
        const content = await fs.readFile(filePath);
        return createHash('sha256').update(content).digest('hex');
    }

    private async saveMetadata(backupName: string, metadata: BackupMetadata): Promise<void> {
        const metadataPath = join(this.backupDir, `${backupName}.meta`);
        await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    }

    private async getMetadata(backupName: string): Promise<BackupMetadata | null> {
        try {
            const metadataPath = join(this.backupDir, `${backupName}.meta`);
            const content = await fs.readFile(metadataPath, 'utf8');
            return JSON.parse(content);
        } catch {
            return null;
        }
    }

    private async compressBackup(backupPath: string): Promise<void> {
        const { gzip } = await import('zlib');
        const { promisify } = await import('util');
        const gzipAsync = promisify(gzip);

        const content = await fs.readFile(backupPath);
        const compressed = await gzipAsync(content);
        await fs.writeFile(`${backupPath}.gz`, compressed);
        await fs.unlink(backupPath);
    }

    private async cleanupOldBackups(): Promise<void> {
        const backups = await this.listBackups();
        
        if (backups.length > this.maxBackups) {
            // Keep newest backups, delete oldest
            const toDelete = backups.slice(this.maxBackups);
            for (const backup of toDelete) {
                await this.deleteBackup(backup.name);
            }
        }
    }
}

================
File: src/storage/core/schema/migrations.ts
================
/**
 * Schema migration management
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';

export interface Migration {
    version: number;
    description: string;
    up: (db: Database) => Promise<void>;
    down: (db: Database) => Promise<void>;
}

export class SchemaManager {
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly migrations: Migration[] = [];

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'SchemaManager' });
        this.eventManager = EventManager.getInstance();

        // Register migrations
        this.registerMigrations();
    }

    private registerMigrations(): void {
        // Migration 1: Initial schema
        this.migrations.push({
            version: 1,
            description: 'Initial schema',
            up: async (db: Database) => {
                // Create tables one at a time with error handling
                await db.exec('BEGIN IMMEDIATE');
                
                try {
                    // Create schema_migrations table first
                    await db.exec(`
                        CREATE TABLE IF NOT EXISTS schema_migrations (
                            version INTEGER PRIMARY KEY,
                            description TEXT NOT NULL,
                            applied_at INTEGER NOT NULL
                        )
                    `);

                    // Create tasks table with proper column types
                    await db.exec(`
                        CREATE TABLE IF NOT EXISTS tasks (
                            path TEXT PRIMARY KEY,
                            name TEXT NOT NULL,
                            description TEXT,
                            type TEXT NOT NULL CHECK(type IN ('TASK', 'GROUP', 'MILESTONE')),
                            status TEXT NOT NULL CHECK(status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED')),
                            parent_path TEXT REFERENCES tasks(path) ON DELETE CASCADE,
                            notes TEXT,
                            reasoning TEXT,
                            dependencies TEXT CHECK(json_valid(COALESCE(dependencies, '[]'))),
                            subtasks TEXT CHECK(json_valid(COALESCE(subtasks, '[]'))),
                            metadata TEXT CHECK(json_valid(COALESCE(metadata, '{}'))),
                            created_at INTEGER NOT NULL,
                            updated_at INTEGER NOT NULL
                        )
                    `);

                    // Create indexes with proper syntax
                    await db.exec(`CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path) WHERE parent_path IS NOT NULL`);
                    await db.exec(`CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)`);
                    await db.exec(`CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type)`);
                    
                    await db.exec('COMMIT');
                } catch (error) {
                    await db.exec('ROLLBACK');
                    throw error;
                }
            },
            down: async (db: Database) => {
                await db.exec(`
                    DROP TABLE IF EXISTS tasks;
                    DROP TABLE IF EXISTS schema_migrations;
                `);
            }
        });

        // Migration 2: Add indexes for performance
        this.migrations.push({
            version: 2,
            description: 'Add performance indexes',
            up: async (db: Database) => {
                await db.exec(`
                    CREATE INDEX IF NOT EXISTS idx_tasks_created ON tasks(created_at);
                    CREATE INDEX IF NOT EXISTS idx_tasks_updated ON tasks(updated_at);
                    CREATE INDEX IF NOT EXISTS idx_tasks_dependencies ON tasks(dependencies) WHERE json_array_length(dependencies) > 0;
                `);
            },
            down: async (db: Database) => {
                await db.exec(`
                    DROP INDEX IF EXISTS idx_tasks_created;
                    DROP INDEX IF EXISTS idx_tasks_updated;
                    DROP INDEX IF EXISTS idx_tasks_dependencies;
                `);
            }
        });
    }

    /**
     * Apply pending migrations
     */
    async applyMigrations(db: Database): Promise<void> {
        try {
            // Ensure migrations table exists
            await db.exec(`
                CREATE TABLE IF NOT EXISTS schema_migrations (
                    version INTEGER PRIMARY KEY,
                    description TEXT NOT NULL,
                    applied_at INTEGER NOT NULL
                );
            `);

            // Get current version
            const result = await db.get<{ version: number }>(
                'SELECT MAX(version) as version FROM schema_migrations'
            );
            const currentVersion = result?.version || 0;

            // Apply pending migrations
            for (const migration of this.migrations) {
                if (migration.version > currentVersion) {
                    this.logger.info('Applying migration', {
                        version: migration.version,
                        description: migration.description
                    });

                    await db.run('BEGIN IMMEDIATE');
                    try {
                        await migration.up(db);
                        await db.run(
                            'INSERT INTO schema_migrations (version, description, applied_at) VALUES (?, ?, ?)',
                            migration.version,
                            migration.description,
                            Date.now()
                        );
                        await db.run('COMMIT');

                        // Emit migration event
                        this.eventManager.emitSystemEvent({
                            type: EventTypes.SYSTEM_STARTUP,
                            timestamp: Date.now(),
                            metadata: {
                                component: 'SchemaManager',
                                operation: 'migration',
                                version: String(migration.version),
                                reason: migration.description
                            }
                        });
                    } catch (error) {
                        await db.run('ROLLBACK');
                        throw error;
                    }
                }
            }

            this.logger.info('Schema migrations complete', {
                fromVersion: currentVersion,
                toVersion: this.migrations[this.migrations.length - 1]?.version || currentVersion
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to apply migrations', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to apply migrations',
                errorMessage
            );
        }
    }

    /**
     * Rollback migrations to a specific version
     */
    async rollbackTo(db: Database, targetVersion: number): Promise<void> {
        try {
            // Get current version
            const result = await db.get<{ version: number }>(
                'SELECT MAX(version) as version FROM schema_migrations'
            );
            const currentVersion = result?.version || 0;

            if (targetVersion >= currentVersion) {
                return;
            }

            // Apply rollbacks in reverse order
            for (let i = this.migrations.length - 1; i >= 0; i--) {
                const migration = this.migrations[i];
                if (migration.version > targetVersion && migration.version <= currentVersion) {
                    this.logger.info('Rolling back migration', {
                        version: migration.version,
                        description: migration.description
                    });

                    await db.run('BEGIN IMMEDIATE');
                    try {
                        await migration.down(db);
                        await db.run(
                            'DELETE FROM schema_migrations WHERE version = ?',
                            migration.version
                        );
                        await db.run('COMMIT');

                        // Emit rollback event
                        this.eventManager.emitSystemEvent({
                            type: EventTypes.SYSTEM_STARTUP,
                            timestamp: Date.now(),
                            metadata: {
                                component: 'SchemaManager',
                                operation: 'rollback',
                                version: String(migration.version),
                                reason: migration.description
                            }
                        });
                    } catch (error) {
                        await db.run('ROLLBACK');
                        throw error;
                    }
                }
            }

            this.logger.info('Schema rollback complete', {
                fromVersion: currentVersion,
                toVersion: targetVersion
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to rollback migrations', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to rollback migrations',
                errorMessage
            );
        }
    }

    /**
     * Get current schema version
     */
    async getCurrentVersion(db: Database): Promise<number> {
        const result = await db.get<{ version: number }>(
            'SELECT MAX(version) as version FROM schema_migrations'
        );
        return result?.version || 0;
    }

    /**
     * Get migration history
     */
    async getMigrationHistory(db: Database): Promise<Array<{
        version: number;
        description: string;
        appliedAt: number;
    }>> {
        return db.all(`
            SELECT version, description, applied_at as appliedAt
            FROM schema_migrations
            ORDER BY version DESC
        `);
    }
}

================
File: src/storage/core/schema/validator.ts
================
/**
 * Database schema validation system
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';

export interface ColumnDefinition {
    name: string;
    type: string;
    nullable?: boolean;
    defaultValue?: any;
    primaryKey?: boolean;
    unique?: boolean;
    references?: {
        table: string;
        column: string;
    };
}

export interface TableDefinition {
    name: string;
    columns: ColumnDefinition[];
    indexes?: {
        name: string;
        columns: string[];
        unique?: boolean;
    }[];
}

export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
}

export class SchemaValidator {
    private readonly logger: Logger;
    private readonly schema: Map<string, TableDefinition>;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'SchemaValidator' });
        this.schema = new Map();
    }

    /**
     * Register a table schema
     */
    registerTable(table: TableDefinition): void {
        if (this.schema.has(table.name)) {
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Duplicate table definition',
                `Table ${table.name} is already registered`
            );
        }

        this.schema.set(table.name, table);
        this.logger.debug('Registered table schema', { table: table.name });
    }

    /**
     * Validate database schema
     */
    async validateSchema(db: Database): Promise<ValidationResult> {
        const result: ValidationResult = {
            isValid: true,
            errors: [],
            warnings: []
        };

        try {
            // Get actual database schema
            const tables = await this.getDatabaseSchema(db);

            // Check each registered table
            for (const [tableName, definition] of this.schema.entries()) {
                const actualTable = tables.get(tableName);

                if (!actualTable) {
                    result.errors.push(`Missing table: ${tableName}`);
                    result.isValid = false;
                    continue;
                }

                // Validate columns
                for (const column of definition.columns) {
                    const actualColumn = actualTable.columns.find(c => c.name === column.name);

                    if (!actualColumn) {
                        result.errors.push(`Missing column: ${tableName}.${column.name}`);
                        result.isValid = false;
                        continue;
                    }

                    // Check column type
                    if (!this.isCompatibleType(actualColumn.type, column.type)) {
                        result.errors.push(
                            `Type mismatch for ${tableName}.${column.name}: ` +
                            `expected ${column.type}, got ${actualColumn.type}`
                        );
                        result.isValid = false;
                    }

                    // Check constraints
                    if (column.primaryKey && !actualColumn.primaryKey) {
                        result.errors.push(
                            `Missing primary key constraint on ${tableName}.${column.name}`
                        );
                        result.isValid = false;
                    }

                    if (column.unique && !actualColumn.unique) {
                        result.warnings.push(
                            `Missing unique constraint on ${tableName}.${column.name}`
                        );
                    }

                    if (column.references) {
                        const hasReference = await this.validateForeignKey(
                            db,
                            tableName,
                            column.name,
                            column.references
                        );
                        if (!hasReference) {
                            result.errors.push(
                                `Missing foreign key constraint on ${tableName}.${column.name} ` +
                                `referencing ${column.references.table}.${column.references.column}`
                            );
                            result.isValid = false;
                        }
                    }
                }

                // Validate indexes
                if (definition.indexes) {
                    for (const index of definition.indexes) {
                        const hasIndex = await this.validateIndex(
                            db,
                            tableName,
                            index
                        );
                        if (!hasIndex) {
                            result.warnings.push(
                                `Missing index ${index.name} on ${tableName}(${index.columns.join(', ')})`
                            );
                        }
                    }
                }
            }

            // Check for extra tables
            for (const tableName of tables.keys()) {
                if (!this.schema.has(tableName) && !tableName.startsWith('sqlite_')) {
                    result.warnings.push(`Extra table found: ${tableName}`);
                }
            }

            this.logger.info('Schema validation completed', {
                isValid: result.isValid,
                errorCount: result.errors.length,
                warningCount: result.warnings.length
            });

            return result;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Schema validation failed', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Schema validation failed',
                errorMessage
            );
        }
    }

    /**
     * Get actual database schema
     */
    private async getDatabaseSchema(db: Database): Promise<Map<string, {
        name: string;
        columns: {
            name: string;
            type: string;
            primaryKey: boolean;
            unique: boolean;
        }[];
    }>> {
        const schema = new Map();

        // Get tables
        const tables = await db.all(`
            SELECT name FROM sqlite_master 
            WHERE type = 'table' 
            AND name NOT LIKE 'sqlite_%'
        `);

        for (const { name } of tables) {
            // Get table info
            const columns = await db.all(`PRAGMA table_info(${name})`);
            
            schema.set(name, {
                name,
                columns: columns.map(col => ({
                    name: col.name,
                    type: col.type.toUpperCase(),
                    primaryKey: Boolean(col.pk),
                    unique: Boolean(col.pk) // SQLite primary keys are unique
                }))
            });
        }

        return schema;
    }

    /**
     * Check if two SQLite types are compatible
     */
    private isCompatibleType(actual: string, expected: string): boolean {
        // Normalize types
        actual = actual.toUpperCase();
        expected = expected.toUpperCase();

        // Direct match
        if (actual === expected) return true;

        // SQLite type affinities
        const textTypes = ['TEXT', 'CLOB', 'CHAR', 'VARCHAR'];
        const numericTypes = ['INTEGER', 'INT', 'NUMERIC', 'DECIMAL', 'BOOLEAN', 'DATE', 'DATETIME'];
        const realTypes = ['REAL', 'DOUBLE', 'FLOAT'];
        const blobTypes = ['BLOB'];

        // Check type affinity compatibility
        if (textTypes.includes(actual) && textTypes.includes(expected)) return true;
        if (numericTypes.includes(actual) && numericTypes.includes(expected)) return true;
        if (realTypes.includes(actual) && realTypes.includes(expected)) return true;
        if (blobTypes.includes(actual) && blobTypes.includes(expected)) return true;

        return false;
    }

    /**
     * Validate foreign key constraint
     */
    private async validateForeignKey(
        db: Database,
        table: string,
        column: string,
        reference: { table: string; column: string }
    ): Promise<boolean> {
        const foreignKeys = await db.all(`PRAGMA foreign_key_list(${table})`);
        return foreignKeys.some(fk => 
            fk.from === column && 
            fk.table === reference.table && 
            fk.to === reference.column
        );
    }

    /**
     * Validate index
     */
    private async validateIndex(
        db: Database,
        table: string,
        index: { name: string; columns: string[]; unique?: boolean }
    ): Promise<boolean> {
        const indexes = await db.all(`PRAGMA index_list(${table})`);
        const indexInfo = indexes.find(idx => idx.name === index.name);
        
        if (!indexInfo) return false;

        // Check if unique constraint matches
        if (index.unique && !indexInfo.unique) return false;

        // Check index columns
        const columns = await db.all(`PRAGMA index_info(${index.name})`);
        const indexColumns = columns.map(col => col.name);

        return index.columns.every(col => indexColumns.includes(col));
    }

    /**
     * Create a table definition
     */
    static createTableDefinition(
        name: string,
        columns: ColumnDefinition[],
        indexes?: {
            name: string;
            columns: string[];
            unique?: boolean;
        }[]
    ): TableDefinition {
        return { name, columns, indexes };
    }

    /**
     * Create a column definition
     */
    static createColumnDefinition(
        name: string,
        type: string,
        options: {
            nullable?: boolean;
            defaultValue?: any;
            primaryKey?: boolean;
            unique?: boolean;
            references?: {
                table: string;
                column: string;
            };
        } = {}
    ): ColumnDefinition {
        return { name, type, ...options };
    }
}

================
File: src/storage/core/transactions/manager.ts
================
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import crypto from 'crypto';

export interface TransactionState {
    active: boolean;
    depth: number;
    startTime: number;
    timeout?: NodeJS.Timeout;
    id: string;
}

export class TransactionManager {
    private static instance: TransactionManager;
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly activeTransactions = new Map<string, TransactionState>();
    private readonly DEFAULT_TIMEOUT = 30000; // 30 seconds

    private constructor() {
        this.logger = Logger.getInstance().child({ component: 'TransactionManager' });
        this.eventManager = EventManager.getInstance();
    }

    static getInstance(): TransactionManager {
        if (!TransactionManager.instance) {
            TransactionManager.instance = new TransactionManager();
        }
        return TransactionManager.instance;
    }

    /**
     * Begin a new transaction with proper isolation and timeout
     */
    async beginTransaction(db: Database): Promise<string> {
        const txId = crypto.randomUUID();

        try {
            // Check for existing transaction
            const existingTx = Array.from(this.activeTransactions.values())
                .find(tx => tx.active);

            if (existingTx) {
                // Handle nested transaction
                existingTx.depth++;
                this.logger.debug('Nested transaction started', { 
                    transactionId: existingTx.id,
                    depth: existingTx.depth 
                });
                return existingTx.id;
            }

            // Start new transaction
            await db.exec('BEGIN IMMEDIATE');

            // Set up transaction timeout
            const timeoutHandle = setTimeout(
                () => this.handleTransactionTimeout(db, txId),
                this.DEFAULT_TIMEOUT
            );

            // Record active transaction
            const transaction: TransactionState = {
                id: txId,
                active: true,
                depth: 1,
                startTime: Date.now(),
                timeout: timeoutHandle
            };

            this.activeTransactions.set(txId, transaction);

            // Emit transaction start event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_STARTED,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId
                }
            });

            return txId;
        } catch (error) {
            this.logger.error('Failed to begin transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to begin transaction',
                'beginTransaction',
                undefined,
                { originalError: error }
            );
        }
    }

    /**
     * Commit a transaction
     */
    async commitTransaction(db: Database, txId: string): Promise<void> {
        const transaction = this.activeTransactions.get(txId);
        if (!transaction) {
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'No active transaction to commit'
            );
        }

        try {
            if (transaction.depth > 1) {
                // Handle nested transaction
                transaction.depth--;
                this.logger.debug('Nested transaction committed', { 
                    transactionId: txId,
                    depth: transaction.depth 
                });
                return;
            }

            // Clear timeout
            if (transaction.timeout) {
                clearTimeout(transaction.timeout);
            }

            // Commit transaction
            await db.exec('COMMIT');

            const duration = Date.now() - transaction.startTime;

            // Clean up transaction state
            this.activeTransactions.delete(txId);

            // Emit transaction committed event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_COMMITTED,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId,
                    duration
                }
            });
        } catch (error) {
            this.logger.error('Failed to commit transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to commit transaction',
                'commitTransaction',
                undefined,
                { originalError: error }
            );
        }
    }

    /**
     * Rollback a transaction
     */
    async rollbackTransaction(db: Database, txId: string): Promise<void> {
        const transaction = this.activeTransactions.get(txId);
        if (!transaction) {
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'No active transaction to rollback'
            );
        }

        try {
            if (transaction.depth > 1) {
                // Handle nested transaction
                transaction.depth--;
                this.logger.debug('Nested transaction rolled back', { 
                    transactionId: txId,
                    depth: transaction.depth 
                });
                return;
            }

            // Clear timeout
            if (transaction.timeout) {
                clearTimeout(transaction.timeout);
            }

            // Rollback transaction
            await db.exec('ROLLBACK');

            const duration = Date.now() - transaction.startTime;

            // Clean up transaction state
            this.activeTransactions.delete(txId);

            // Emit transaction rollback event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_ROLLED_BACK,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId,
                    duration
                }
            });
        } catch (error) {
            this.logger.error('Failed to rollback transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to rollback transaction',
                'rollbackTransaction',
                undefined,
                { originalError: error }
            );
        }
    }

    /**
     * Handle transaction timeout
     */
    private async handleTransactionTimeout(db: Database, txId: string): Promise<void> {
        const transaction = this.activeTransactions.get(txId);
        if (!transaction) return;

        this.logger.warn('Transaction timeout', {
            transactionId: txId,
            duration: Date.now() - transaction.startTime
        });

        try {
            await this.rollbackTransaction(db, txId);

            // Emit timeout event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_TIMEOUT,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId,
                    duration: Date.now() - transaction.startTime
                }
            });
        } catch (error) {
            this.logger.error('Failed to handle transaction timeout', { error });
        }
    }

    /**
     * Check if a transaction is active
     */
    isTransactionActive(txId: string): boolean {
        const transaction = this.activeTransactions.get(txId);
        return transaction?.active || false;
    }

    /**
     * Get transaction depth
     */
    getTransactionDepth(txId: string): number {
        const transaction = this.activeTransactions.get(txId);
        return transaction?.depth || 0;
    }

    /**
     * Clean up all transactions
     */
    async cleanupAllTransactions(db: Database): Promise<void> {
        for (const [txId, transaction] of this.activeTransactions.entries()) {
            if (transaction.active) {
                try {
                    await this.rollbackTransaction(db, txId);
                } catch (error) {
                    this.logger.error('Failed to cleanup transaction', {
                        error,
                        transactionId: txId
                    });
                }
            }
        }
        this.activeTransactions.clear();
    }
}

================
File: src/storage/core/transactions/scope.ts
================
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';

export enum IsolationLevel {
    READ_UNCOMMITTED = 'READ UNCOMMITTED',
    READ_COMMITTED = 'READ COMMITTED',
    REPEATABLE_READ = 'REPEATABLE READ',
    SERIALIZABLE = 'SERIALIZABLE'
}

/**
 * Manages database transaction lifecycle and isolation levels
 * Supports nested transactions through savepoints
 */
export class TransactionScope {
    private static logger: Logger;

    private static getLogger(): Logger {
        if (!TransactionScope.logger) {
            TransactionScope.logger = Logger.getInstance().child({ component: 'TransactionScope' });
        }
        return TransactionScope.logger;
    }
    private depth: number = 0;
    private savepoints: string[] = [];
    private active: boolean = false;

    constructor(private readonly db: Database) {}

    /**
     * Begins a new transaction or creates a savepoint for nested transactions
     */
    async begin(isolationLevel: IsolationLevel = IsolationLevel.SERIALIZABLE): Promise<void> {
        try {
            if (this.depth === 0) {
                // Start new transaction
                await this.db.exec('BEGIN TRANSACTION');
                await this.setIsolationLevel(isolationLevel);
                this.active = true;
            } else {
                // Create savepoint for nested transaction
                const savepoint = `sp_${this.depth}`;
                await this.db.exec(`SAVEPOINT ${savepoint}`);
                this.savepoints.push(savepoint);
            }
            this.depth++;
            
            TransactionScope.getLogger().debug('Transaction started', {
                depth: this.depth,
                isolationLevel
            });
        } catch (error) {
            TransactionScope.getLogger().error('Failed to begin transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                
                'Failed to begin transaction',
                'begin',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Commits the current transaction or savepoint
     */
    async commit(): Promise<void> {
        if (!this.active) {
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'No active transaction'
            );
        }

        try {
            this.depth--;

            if (this.depth === 0) {
                // Commit main transaction
                await this.db.exec('COMMIT');
                this.active = false;
                this.savepoints = [];
            } else {
                // Release savepoint
                const savepoint = this.savepoints.pop();
                await this.db.exec(`RELEASE SAVEPOINT ${savepoint}`);
            }

            TransactionScope.getLogger().debug('Transaction committed', {
                remainingDepth: this.depth
            });
        } catch (error) {
            TransactionScope.getLogger().error('Failed to commit transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to commit transaction',
                'commit',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Rolls back the current transaction or savepoint
     */
    async rollback(): Promise<void> {
        if (!this.active) {
            return; // No-op if no active transaction
        }

        try {
            if (this.depth === 1) {
                // Rollback main transaction
                await this.db.exec('ROLLBACK');
                this.active = false;
                this.savepoints = [];
            } else {
                // Rollback to savepoint
                const savepoint = this.savepoints.pop();
                await this.db.exec(`ROLLBACK TO SAVEPOINT ${savepoint}`);
            }
            this.depth = Math.max(0, this.depth - 1);

            TransactionScope.getLogger().debug('Transaction rolled back', {
                remainingDepth: this.depth
            });
        } catch (error) {
            TransactionScope.getLogger().error('Failed to rollback transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to rollback transaction',
                'rollback',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Executes work within a transaction scope
     * Automatically handles commit/rollback
     */
    async executeInTransaction<T>(
        work: () => Promise<T>,
        isolationLevel: IsolationLevel = IsolationLevel.SERIALIZABLE
    ): Promise<T> {
        await this.begin(isolationLevel);
        try {
            const result = await work();
            await this.commit();
            return result;
        } catch (error) {
            await this.rollback();
            throw error;
        }
    }

    /**
     * Sets the isolation level for the current transaction
     */
    private async setIsolationLevel(level: IsolationLevel): Promise<void> {
        try {
            switch (level) {
                case IsolationLevel.READ_UNCOMMITTED:
                    await this.db.exec('PRAGMA read_uncommitted = 1');
                    break;
                case IsolationLevel.READ_COMMITTED:
                    await this.db.exec('PRAGMA read_uncommitted = 0');
                    break;
                case IsolationLevel.REPEATABLE_READ:
                case IsolationLevel.SERIALIZABLE:
                    // SQLite's default is SERIALIZABLE
                    break;
            }
        } catch (error) {
            TransactionScope.getLogger().error('Failed to set isolation level', {
                error,
                level
            });
            throw error;
        }
    }

    /**
     * Checks if there is an active transaction
     */
    isActive(): boolean {
        return this.active;
    }

    /**
     * Gets the current transaction depth
     */
    getDepth(): number {
        return this.depth;
    }

    /**
     * Ensures no active transaction
     * Used before operations that can't run in a transaction (like VACUUM)
     */
    async ensureNoTransaction(): Promise<void> {
        if (this.active) {
            await this.rollback();
        }
    }
}

================
File: src/storage/core/wal/manager.ts
================
/**
 * WAL (Write-Ahead Logging) management
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { promises as fs } from 'fs';

export interface WALMetrics {
    isEnabled: boolean;
    walSize: number;
    lastCheckpoint: number;
    checkpointCount: number;
    autoCheckpointSize: number;
}

export class WALManager {
    private static instance: WALManager;
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private isWALEnabled = false;
    private lastCheckpoint = 0;
    private checkpointCount = 0;
    private readonly dbPath: string;
    private checkpointInterval: NodeJS.Timeout | null = null;
    private readonly CHECKPOINT_INTERVAL = 60000; // 1 minute
    private readonly MAX_WAL_SIZE = 10 * 1024 * 1024; // 10MB

    private constructor(dbPath: string) {
        this.logger = Logger.getInstance().child({ component: 'WALManager' });
        this.eventManager = EventManager.getInstance();
        this.dbPath = dbPath;
        this.resetState();
    }

    /**
     * Reset internal state
     */
    private resetState(): void {
        this.isWALEnabled = false;
        this.lastCheckpoint = 0;
        this.checkpointCount = 0;
        if (this.checkpointInterval) {
            clearInterval(this.checkpointInterval);
            this.checkpointInterval = null;
        }
    }

    static getInstance(dbPath?: string): WALManager {
        if (!WALManager.instance) {
            if (!dbPath) {
                throw new Error('dbPath required for WALManager initialization');
            }
            WALManager.instance = new WALManager(dbPath);
        }
        return WALManager.instance;
    }

    /**
     * Enable WAL mode with proper locking and verification
     */
    async enableWAL(db: Database): Promise<void> {
        if (this.isWALEnabled) {
            return;
        }

        // Clean up any existing WAL files from previous runs
        await this.cleanupWALFiles();

        try {
            // Set exclusive lock to prevent other connections
            await db.exec('PRAGMA locking_mode = EXCLUSIVE');
            
            // Check current mode
            const currentMode = await db.get<{ journal_mode: string }>('PRAGMA journal_mode');
            
            if (currentMode?.journal_mode !== 'wal') {
                // Force checkpoint existing journal
                await db.exec('PRAGMA wal_checkpoint(TRUNCATE)');
                
                // Enable WAL mode
                await db.exec('PRAGMA journal_mode = WAL');
                
                // Verify WAL mode
                const newMode = await db.get<{ journal_mode: string }>('PRAGMA journal_mode');
                if (newMode?.journal_mode !== 'wal') {
                    throw createError(
                        ErrorCodes.STORAGE_INIT,
                        'Failed to enable WAL mode',
                        `Expected 'wal', got '${newMode?.journal_mode}'`
                    );
                }

                try {
                    // Set synchronous mode first (must be outside transaction)
                    await db.exec('PRAGMA synchronous = NORMAL');
                    
                    // Verify synchronous setting
                    const syncMode = await db.get('PRAGMA synchronous');
                    if (syncMode?.synchronous !== 1) { // NORMAL = 1
                        throw new Error('Failed to set synchronous mode');
                    }

                    // Set other PRAGMAs in transaction
                    await db.exec('BEGIN IMMEDIATE');
                    await db.exec('PRAGMA wal_autocheckpoint = 1000');
                    await db.exec(`PRAGMA journal_size_limit = ${this.MAX_WAL_SIZE}`);
                    await db.exec('COMMIT');

                    // Verify transaction-safe settings
                    const checkpoint = await db.get('PRAGMA wal_autocheckpoint');
                    const journalSize = await db.get('PRAGMA journal_size_limit');

                    if (checkpoint?.wal_autocheckpoint !== 1000 ||
                        journalSize?.journal_size_limit !== this.MAX_WAL_SIZE) {
                        throw new Error('Failed to set WAL optimization settings');
                    }

                    this.isWALEnabled = true;
                    this.startCheckpointMonitoring(db);

                    this.logger.info('WAL mode enabled successfully', {
                        mode: newMode.journal_mode,
                        settings: {
                            synchronous: syncMode?.synchronous,
                            journal_mode: newMode.journal_mode,
                            wal_autocheckpoint: checkpoint?.wal_autocheckpoint,
                            journal_size_limit: journalSize?.journal_size_limit
                        }
                    });
                } catch (error) {
                    // Roll back transaction if it failed
                    await db.exec('ROLLBACK').catch(() => {});
                    throw error;
                }

                // Emit WAL enabled event
                this.eventManager.emitSystemEvent({
                    type: EventTypes.STORAGE_WAL_ENABLED,
                    timestamp: Date.now(),
                    metadata: {
                        dbPath: this.dbPath
                    }
                });
            } else {
                this.isWALEnabled = true;
                this.startCheckpointMonitoring(db);
                this.logger.info('Database already in WAL mode');
            }
        } catch (error) {
            // Ensure error is properly stringified
            const errorMessage = error instanceof Error 
                ? error.message 
                : error && typeof error === 'object'
                    ? JSON.stringify(error)
                    : String(error);
            
            this.logger.error('Failed to enable WAL mode', { 
                error: errorMessage,
                details: error instanceof Error ? error.stack : undefined
            });
            
            // Reset WAL state
            this.isWALEnabled = false;
            
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to enable WAL mode',
                errorMessage
            );
        } finally {
            // Release exclusive lock
            try {
                await db.exec('PRAGMA locking_mode = NORMAL');
            } catch (error) {
                this.logger.warn('Failed to release exclusive lock', { error });
            }
        }
    }

    /**
     * Start periodic checkpoint monitoring
     */
    private startCheckpointMonitoring(db: Database): void {
        if (this.checkpointInterval) {
            return;
        }

        // Check WAL size periodically
        this.checkpointInterval = setInterval(async () => {
            try {
                const metrics = await this.getMetrics();
                
                // If WAL file is too large, force a checkpoint
                if (metrics.walSize > this.MAX_WAL_SIZE) {
                    await this.checkpoint(db);
                }
            } catch (error) {
                this.logger.error('Checkpoint monitoring failed', { error });
            }
        }, this.CHECKPOINT_INTERVAL);

        // Ensure the interval doesn't prevent the process from exiting
        this.checkpointInterval.unref();
    }

    /**
     * Force a WAL checkpoint
     */
    async checkpoint(db: Database): Promise<void> {
        try {
            await db.exec('PRAGMA wal_checkpoint(TRUNCATE)');
            this.lastCheckpoint = Date.now();
            this.checkpointCount++;
            
            this.logger.info('WAL checkpoint completed', {
                checkpointCount: this.checkpointCount
            });

            // Emit checkpoint event
            this.eventManager.emitSystemEvent({
                type: EventTypes.STORAGE_WAL_CHECKPOINT,
                timestamp: Date.now(),
                metadata: {
                    checkpointCount: this.checkpointCount,
                    dbPath: this.dbPath
                }
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('WAL checkpoint failed', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'WAL checkpoint failed',
                errorMessage
            );
        }
    }

    /**
     * Get WAL metrics
     */
    async getMetrics(): Promise<WALMetrics> {
        const path = await import('path');
        const walPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-wal');
        let walSize = 0;

        try {
            const stats = await fs.stat(walPath);
            walSize = stats.size;
        } catch (error) {
            // WAL file might not exist yet
            this.logger.debug('Could not get WAL file size', { error });
        }

        return {
            isEnabled: this.isWALEnabled,
            walSize,
            lastCheckpoint: this.lastCheckpoint,
            checkpointCount: this.checkpointCount,
            autoCheckpointSize: 1000 // Pages
        };
    }

    /**
     * Verify WAL file integrity
     */
    async verifyWALIntegrity(): Promise<boolean> {
        const path = await import('path');
        const walPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-wal');
        const shmPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-shm');

        try {
            // Check if WAL and SHM files exist
            await Promise.all([
                fs.access(walPath),
                fs.access(shmPath)
            ]);

            // Get WAL file size
            const stats = await fs.stat(walPath);
            
            // Basic integrity checks
            if (stats.size === 0) {
                this.logger.warn('WAL file is empty', { walPath });
                return false;
            }

            if (stats.size % 4096 !== 0) {
                this.logger.warn('WAL file size is not page-aligned', { 
                    size: stats.size,
                    walPath 
                });
                return false;
            }

            return true;
        } catch (error) {
            this.logger.warn('WAL integrity check failed', { error });
            return false;
        }
    }

    /**
     * Clean up any existing WAL files
     */
    private lastCleanup = 0;
    private readonly CLEANUP_INTERVAL = 1000; // 1 second

    private async cleanupWALFiles(): Promise<void> {
        const now = Date.now();
        // Only cleanup every 5 seconds to reduce memory pressure
        if (now - this.lastCleanup < this.CLEANUP_INTERVAL) {
            return;
        }

        const path = await import('path');
        const walPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-wal');
        const shmPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-shm');

        try {
            // Check if files exist first to avoid unnecessary operations
            const [walExists, shmExists] = await Promise.all([
                fs.access(walPath).then(() => true).catch(() => false),
                fs.access(shmPath).then(() => true).catch(() => false)
            ]);

            // Only delete if files exist
            if (walExists || shmExists) {
                const promises = [];
                if (walExists) promises.push(fs.unlink(walPath));
                if (shmExists) promises.push(fs.unlink(shmPath));
                await Promise.all(promises);
                this.logger.debug('Cleaned up existing WAL files');
            }
        } catch (error) {
            // Ignore errors as files may not exist
            this.logger.debug('No existing WAL files to clean up');
        } finally {
            this.lastCleanup = now;
        }
    }

    /**
     * Clean up resources
     */
    async close(): Promise<void> {
        try {
            // Stop checkpoint monitoring
            if (this.checkpointInterval) {
                clearInterval(this.checkpointInterval);
                this.checkpointInterval = null;
            }

            // Clean up WAL files
            await this.cleanupWALFiles();
            
            // Reset state
            this.resetState();

            this.logger.info('WAL manager closed successfully');
        } catch (error) {
            this.logger.error('Error closing WAL manager', { error });
            throw error;
        }
    }
}

================
File: src/storage/core/index.ts
================
/**
 * Core storage components
 */

// Types
import { StorageConfig } from '../../types/storage.js';

// Connection management
import { ConnectionManager, type ConnectionOptions } from './connection/manager.js';
import { ConnectionPool } from './connection/pool.js';

// Query handling
import { QueryBuilder } from './query/builder.js';
import { QueryExecutor } from './query/executor.js';
import { QueryOptimizer } from './query/optimizer.js';

// Schema management
import { SchemaManager } from './schema/migrations.js';
import { SchemaValidator } from './schema/validator.js';
import { BackupManager } from './schema/backup.js';

// Re-export everything
export { ConnectionManager, type ConnectionOptions } from './connection/manager.js';
export { ConnectionPool } from './connection/pool.js';
export { HealthMonitor, type ConnectionHealth, type HealthMetrics } from './connection/health.js';

// Query handling
export { QueryBuilder } from './query/builder.js';
export { QueryExecutor } from './query/executor.js';
export { QueryOptimizer } from './query/optimizer.js';

// Schema management
export { SchemaManager } from './schema/migrations.js';
export { 
    SchemaValidator,
    type TableDefinition,
    type ColumnDefinition,
    type ValidationResult 
} from './schema/validator.js';
export { 
    BackupManager,
    type BackupMetadata,
    type BackupOptions,
    type RestoreOptions 
} from './schema/backup.js';

// Utility types
export interface StorageOptions {
    // Connection options
    connection?: ConnectionOptions;
    minConnections?: number;
    maxConnections?: number;
    idleTimeout?: number;
    healthCheckInterval?: number;
    errorThreshold?: number;
    responseTimeThreshold?: number;

    // Query options
    slowQueryThreshold?: number;
    maxQueryCacheSize?: number;
    queryCacheTTL?: number;
    costThreshold?: number;

    // Backup options
    backupDir?: string;
    maxBackups?: number;
}

// Factory function to create storage components
export function createStorageCore(config: StorageConfig, options: StorageOptions = {}) {
    // Create connection pool and manager
    const pool = new ConnectionPool({
        ...config,
        monitoring: {
            enabled: true,
            healthCheck: {
                enabled: true,
                interval: options.healthCheckInterval,
                errorThreshold: options.errorThreshold,
                responseTimeThreshold: options.responseTimeThreshold
            },
            metrics: {
                enabled: true
            }
        }
    }, {
        minConnections: options.minConnections,
        maxConnections: options.maxConnections,
        idleTimeout: options.idleTimeout
    });

    const connectionManager = new ConnectionManager(config, options.connection);

    // Create query components
    const queryBuilder = new QueryBuilder();
    const queryExecutor = new QueryExecutor(pool, {
        slowQueryThreshold: options.slowQueryThreshold,
        maxCacheSize: options.maxQueryCacheSize,
        defaultCacheTTL: options.queryCacheTTL
    });
    const queryOptimizer = new QueryOptimizer({
        costThreshold: options.costThreshold
    });

    // Create schema components
    const migrationManager = new SchemaManager();
    const schemaValidator = new SchemaValidator();
    const backupManager = options.backupDir ? new BackupManager({
        backupDir: options.backupDir,
        maxBackups: options.maxBackups
    }) : null;

    return {
        // Connection management
        pool,
        connectionManager,

        // Query handling
        queryBuilder,
        queryExecutor,
        queryOptimizer,

        // Schema management
        migrationManager,
        schemaValidator,
        backupManager,

        // Initialization
        async initialize() {
            await pool.initialize();
            if (backupManager) {
                await backupManager.initialize();
            }
        },

        // Cleanup
        async close() {
            await pool.close();
        }
    };
}

================
File: src/storage/monitoring/health.ts
================
/**
 * Storage health monitoring
 */
import { Logger } from '../../logging/index.js';
import { EventManager } from '../../events/event-manager.js';
import { EventTypes } from '../../types/events.js';

export interface HealthMonitorOptions {
    checkInterval?: number;
    errorThreshold?: number;
    responseTimeThreshold?: number;
}

export class HealthMonitor {
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly options: Required<HealthMonitorOptions>;
    private healthCheckInterval: NodeJS.Timeout | null = null;
    private readonly DEFAULT_CHECK_INTERVAL = 30000; // 30 seconds
    private readonly DEFAULT_ERROR_THRESHOLD = 5;
    private readonly DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second

    private errorCount = 0;
    private lastCheckTime = 0;
    private isHealthy = true;

    constructor(options: HealthMonitorOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
        this.eventManager = EventManager.getInstance();
        this.options = {
            checkInterval: options.checkInterval || this.DEFAULT_CHECK_INTERVAL,
            errorThreshold: options.errorThreshold || this.DEFAULT_ERROR_THRESHOLD,
            responseTimeThreshold: options.responseTimeThreshold || this.DEFAULT_RESPONSE_TIME_THRESHOLD
        };
    }

    /**
     * Start health monitoring
     */
    start(): void {
        if (this.healthCheckInterval) {
            return;
        }

        this.healthCheckInterval = setInterval(() => {
            this.checkHealth();
        }, this.options.checkInterval);

        // Ensure the interval doesn't prevent the process from exiting
        this.healthCheckInterval.unref();

        this.logger.info('Health monitoring started', {
            interval: this.options.checkInterval
        });
    }

    /**
     * Stop health monitoring
     */
    stop(): void {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
        this.logger.info('Health monitoring stopped');
    }

    /**
     * Record error occurrence
     */
    recordError(error: Error): void {
        this.errorCount++;
        this.isHealthy = this.errorCount < this.options.errorThreshold;

        if (!this.isHealthy) {
            this.logger.error('Health check failed', {
                error,
                errorCount: this.errorCount,
                threshold: this.options.errorThreshold
            });

            // Emit health event
            this.eventManager.emitSystemEvent({
                type: EventTypes.SYSTEM_ERROR,
                timestamp: Date.now(),
                metadata: {
                    component: 'HealthMonitor',
                    error,
                    memoryUsage: process.memoryUsage()
                }
            });
        }
    }

    /**
     * Record successful operation
     */
    recordSuccess(): void {
        // Reset error count on successful operations
        if (this.errorCount > 0) {
            this.errorCount = 0;
            this.isHealthy = true;
        }
    }

    /**
     * Get current health status
     */
    getHealth(): { isHealthy: boolean; errorCount: number; lastCheck: number } {
        return {
            isHealthy: this.isHealthy,
            errorCount: this.errorCount,
            lastCheck: this.lastCheckTime
        };
    }

    /**
     * Reset health status
     */
    reset(): void {
        this.errorCount = 0;
        this.isHealthy = true;
        this.lastCheckTime = Date.now();
    }

    /**
     * Perform health check
     */
    private checkHealth(): void {
        this.lastCheckTime = Date.now();

        // Check memory usage
        const memoryUsage = process.memoryUsage();
        const heapUsedPercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;

        if (heapUsedPercent > 90) {
            this.logger.warn('High memory usage detected', {
                heapUsed: memoryUsage.heapUsed,
                heapTotal: memoryUsage.heapTotal,
                usedPercent: heapUsedPercent
            });
        }

        // Emit health status event
        this.eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_STARTUP,
            timestamp: this.lastCheckTime,
            metadata: {
                component: 'HealthMonitor',
                memoryUsage,
                success: this.isHealthy,
                error: this.isHealthy ? undefined : new Error(`Error threshold exceeded: ${this.errorCount}`)
            }
        });

        // Log health status
        this.logger.info('Health check completed', {
            isHealthy: this.isHealthy,
            errorCount: this.errorCount,
            memoryUsage: {
                heapUsedPercent,
                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + 'MB',
                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + 'MB'
            }
        });
    }
}

================
File: src/storage/monitoring/index.ts
================
/**
 * Storage monitoring module exports
 */
export { MetricsCollector, type MetricsCollectorOptions } from './metrics.js';
export { HealthMonitor, type HealthMonitorOptions } from './health.js';

// Re-export types
export type { MonitoringMetrics } from '../../types/storage.js';

// Constants
export const DEFAULT_CHECK_INTERVAL = 30000; // 30 seconds
export const DEFAULT_ERROR_THRESHOLD = 5;
export const DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second
export const DEFAULT_METRICS_INTERVAL = 60000; // 1 minute

// Monitoring event types
export const MonitoringEventTypes = {
    HEALTH_CHECK: 'health_check',
    METRICS_COLLECTED: 'metrics_collected',
    ERROR_THRESHOLD_EXCEEDED: 'error_threshold_exceeded',
    HIGH_MEMORY_USAGE: 'high_memory_usage',
    SLOW_QUERY_DETECTED: 'slow_query_detected'
} as const;

// Health status types
export const HealthStatus = {
    HEALTHY: 'healthy',
    DEGRADED: 'degraded',
    UNHEALTHY: 'unhealthy'
} as const;

// Monitoring interfaces
export interface HealthStatus {
    status: typeof HealthStatus[keyof typeof HealthStatus];
    errorCount: number;
    lastCheck: number;
    memoryUsage: {
        heapUsed: number;
        heapTotal: number;
        heapUsedPercent: number;
        rss: number;
    };
}

export interface MonitoringConfig {
    enabled: boolean;
    healthCheck?: {
        enabled?: boolean;
        interval?: number;
        errorThreshold?: number;
        responseTimeThreshold?: number;
    };
    metrics?: {
        enabled?: boolean;
        interval?: number;
        errorThreshold?: number;
        responseTimeThreshold?: number;
    };
}

// Utility functions
export function formatMemorySize(bytes: number): string {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }

    return `${Math.round(size * 100) / 100}${units[unitIndex]}`;
}

export function calculateMemoryUsage(): {
    heapUsed: number;
    heapTotal: number;
    heapUsedPercent: number;
    rss: number;
} {
    const memoryUsage = process.memoryUsage();
    return {
        heapUsed: memoryUsage.heapUsed,
        heapTotal: memoryUsage.heapTotal,
        heapUsedPercent: (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100,
        rss: memoryUsage.rss
    };
}

export function isHealthy(status: HealthStatus): boolean {
    return status.status === HealthStatus.HEALTHY;
}

export function isDegraded(status: HealthStatus): boolean {
    return status.status === HealthStatus.DEGRADED;
}

export function isUnhealthy(status: HealthStatus): boolean {
    return status.status === HealthStatus.UNHEALTHY;
}

================
File: src/storage/monitoring/metrics.ts
================
/**
 * Storage metrics collection and monitoring
 */
import { Logger } from '../../logging/index.js';
import { EventManager } from '../../events/event-manager.js';
import { EventTypes } from '../../types/events.js';
import { MonitoringMetrics } from '../../types/storage.js';

export interface MetricsCollectorOptions {
    checkInterval?: number;
    errorThreshold?: number;
    responseTimeThreshold?: number;
    metricsInterval?: number;
}

export class MetricsCollector {
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly options: Required<MetricsCollectorOptions>;
    private metricsInterval: NodeJS.Timeout | null = null;
    private readonly DEFAULT_CHECK_INTERVAL = 30000; // 30 seconds
    private readonly DEFAULT_ERROR_THRESHOLD = 5;
    private readonly DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second
    private readonly DEFAULT_METRICS_INTERVAL = 60000; // 1 minute

    private totalQueries = 0;
    private errorCount = 0;
    private totalResponseTime = 0;
    private slowQueries = 0;

    constructor(options: MetricsCollectorOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'MetricsCollector' });
        this.eventManager = EventManager.getInstance();
        this.options = {
            checkInterval: options.checkInterval || this.DEFAULT_CHECK_INTERVAL,
            errorThreshold: options.errorThreshold || this.DEFAULT_ERROR_THRESHOLD,
            responseTimeThreshold: options.responseTimeThreshold || this.DEFAULT_RESPONSE_TIME_THRESHOLD,
            metricsInterval: options.metricsInterval || this.DEFAULT_METRICS_INTERVAL
        };
    }

    /**
     * Start metrics collection
     */
    start(): void {
        if (this.metricsInterval) {
            return;
        }

        this.metricsInterval = setInterval(() => {
            this.collectMetrics();
        }, this.options.metricsInterval);

        // Ensure the interval doesn't prevent the process from exiting
        this.metricsInterval.unref();

        this.logger.info('Metrics collection started', {
            interval: this.options.metricsInterval
        });
    }

    /**
     * Stop metrics collection
     */
    stop(): void {
        if (this.metricsInterval) {
            clearInterval(this.metricsInterval);
            this.metricsInterval = null;
        }
        this.logger.info('Metrics collection stopped');
    }

    /**
     * Record query execution
     */
    recordQuery(duration: number, error?: Error): void {
        this.totalQueries++;
        if (error) {
            this.errorCount++;
        }
        this.totalResponseTime += duration;
        if (duration > this.options.responseTimeThreshold) {
            this.slowQueries++;
        }
    }

    /**
     * Get current metrics
     */
    getMetrics(): MonitoringMetrics {
        const memoryUsage = process.memoryUsage();
        return {
            cache: {
                hits: 0, // Populated by storage implementation
                misses: 0,
                hitRate: 0,
                size: 0,
                memoryUsage: memoryUsage.heapUsed
            },
            connections: {
                total: 0, // Populated by connection pool
                active: 0,
                idle: 0,
                errors: this.errorCount,
                avgResponseTime: this.totalQueries > 0 
                    ? this.totalResponseTime / this.totalQueries 
                    : 0
            },
            queries: {
                total: this.totalQueries,
                errors: this.errorCount,
                avgExecutionTime: this.totalQueries > 0 
                    ? this.totalResponseTime / this.totalQueries 
                    : 0,
                slowQueries: this.slowQueries
            },
            timestamp: Date.now()
        };
    }

    /**
     * Reset metrics counters
     */
    reset(): void {
        this.totalQueries = 0;
        this.errorCount = 0;
        this.totalResponseTime = 0;
        this.slowQueries = 0;
    }

    /**
     * Collect and emit metrics
     */
    private collectMetrics(): void {
        const metrics = this.getMetrics();

        // Emit metrics event
        this.eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_STARTUP,
            timestamp: Date.now(),
            metadata: {
                component: 'MetricsCollector',
                memoryUsage: process.memoryUsage(),
                metrics
            }
        });

        // Log metrics summary
        this.logger.info('Storage metrics collected', {
            queries: metrics.queries,
            connections: metrics.connections,
            cache: metrics.cache
        });

        // Check for concerning metrics
        if (metrics.queries.errors > this.options.errorThreshold) {
            this.logger.warn('High error rate detected', {
                errors: metrics.queries.errors,
                threshold: this.options.errorThreshold
            });
        }

        if (metrics.queries.slowQueries > 0) {
            this.logger.warn('Slow queries detected', {
                count: metrics.queries.slowQueries,
                avgTime: metrics.queries.avgExecutionTime
            });
        }

        // Reset counters after collection
        this.reset();
    }
}

================
File: src/storage/sqlite/index.ts
================
/**
 * SQLite Storage Implementation
 * 
 * This module provides a SQLite-based implementation of the TaskStorage interface,
 * with support for:
 * - Task CRUD operations
 * - Transaction management
 * - Database maintenance
 * - Performance monitoring
 * - Data integrity verification
 */

// Core initialization and cleanup
export { 
    initializeSqliteStorage  // Initialize SQLite storage cleanup handlers
} from './init.js';

// Storage implementation and configuration
export { 
    SqliteStorage,           // Main storage class implementing TaskStorage interface
    SqliteConfig,            // Configuration interface for SQLite storage
    DEFAULT_PAGE_SIZE,       // Default SQLite page size (4KB)
    DEFAULT_CACHE_SIZE,      // Default cache size (2000 pages)
    DEFAULT_BUSY_TIMEOUT     // Default busy timeout (5000ms)
} from './storage.js';

// Re-export task types for convenience
export type {
    Task,
    TaskStatus,
    CreateTaskInput,
    UpdateTaskInput
} from '../../types/task.js';

================
File: src/storage/sqlite/init.ts
================
import { Logger } from '../../logging/index.js';
import { createDefaultStorage } from '../factory.js';

/**
 * Sets up cleanup handlers for SQLite storage
 */
export async function initializeSqliteStorage(): Promise<void> {
    const logger = Logger.getInstance();
    const storage = await createDefaultStorage();
    
    // Set up cleanup on process exit
    let isCleaningUp = false;
    const cleanup = async (signal: string) => {
        if (isCleaningUp) {
            return;
        }
        isCleaningUp = true;

        try {
            logger.info('Cleaning up SQLite storage...', { signal });
            await storage.close();
        } catch (error) {
            // Only log non-"already closed" errors
            if (!(error instanceof Error && error.message.includes('Database handle is closed'))) {
                logger.error('Error closing SQLite storage', {
                    error: error instanceof Error ? error.message : String(error)
                });
            }
        }

        // Exit after cleanup
        process.exit(0);
    };

    // Handle termination signals
    process.once('SIGINT', () => cleanup('SIGINT'));
    process.once('SIGTERM', () => cleanup('SIGTERM'));
    process.once('beforeExit', () => cleanup('beforeExit'));

    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
        logger.error('Uncaught exception, cleaning up...', {
            error: error instanceof Error ? error.message : String(error)
        });
        await cleanup('uncaughtException');
    });

    logger.info('SQLite cleanup handlers initialized');
}

================
File: src/storage/sqlite/storage.ts
================
import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';
import { TaskStorage } from '../../types/storage.js';
import { Task, TaskStatus, CreateTaskInput, UpdateTaskInput } from '../../types/task.js';
import { Logger } from '../../logging/index.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionScope, IsolationLevel } from '../core/transactions/scope.js';

// Constants
export const DEFAULT_PAGE_SIZE = 4096;
export const DEFAULT_CACHE_SIZE = 2000;
export const DEFAULT_BUSY_TIMEOUT = 5000;

// Configuration types
export interface SqliteConfig {
    baseDir: string;
    name: string;
    sqlite?: {
        journalMode?: 'DELETE' | 'TRUNCATE' | 'PERSIST' | 'MEMORY' | 'WAL' | 'OFF';
        synchronous?: 'OFF' | 'NORMAL' | 'FULL' | 'EXTRA';
        tempStore?: 'DEFAULT' | 'FILE' | 'MEMORY';
        lockingMode?: 'NORMAL' | 'EXCLUSIVE';
        autoVacuum?: 'NONE' | 'FULL' | 'INCREMENTAL';
    };
    performance?: {
        pageSize?: number;
        cacheSize?: number;
        mmapSize?: number;
    };
    connection?: {
        busyTimeout?: number;
        maxRetries?: number;
        retryDelay?: number;
    };
}

export class SqliteStorage implements TaskStorage {
    private static initializationPromise: Promise<void> | null = null;
    private db: Database | null = null;
    private readonly logger: Logger;
    private readonly dbPath: string;
    private isInitialized = false;
    private transactionScope: TransactionScope | null = null;

    constructor(private readonly config: SqliteConfig) {
        this.logger = Logger.getInstance().child({ component: 'SqliteStorage' });
        this.dbPath = `${config.baseDir}/${config.name}.db`;
    }

    async initialize(): Promise<void> {
        // Return if already initialized
        if (this.isInitialized) {
            this.logger.debug('SQLite storage already initialized');
            return;
        }

        // If initialization is in progress, wait for it
        if (SqliteStorage.initializationPromise) {
            this.logger.debug('Waiting for existing initialization to complete');
            await SqliteStorage.initializationPromise;
            return;
        }

        // Start new initialization with mutex
        SqliteStorage.initializationPromise = (async () => {
            try {
                // Initialize SQLite with WAL mode
                this.db = await open({
                    filename: this.dbPath,
                    driver: sqlite3.Database,
                    mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE
                });

                // Initialize transaction scope
                this.transactionScope = new TransactionScope(this.db);

                // Configure database with proper error handling
                const pragmas = [
                    // Enable WAL mode first for better concurrency
                    `PRAGMA journal_mode=${this.config.sqlite?.journalMode || 'WAL'}`,
                    
                    // Enable foreign keys for referential integrity
                    'PRAGMA foreign_keys=ON',
                    
                    // Configure synchronization and durability
                    `PRAGMA synchronous=${this.config.sqlite?.synchronous || 'NORMAL'}`,
                    
                    // Memory and performance settings
                    `PRAGMA temp_store=${this.config.sqlite?.tempStore || 'MEMORY'}`,
                    `PRAGMA page_size=${this.config.performance?.pageSize || DEFAULT_PAGE_SIZE}`,
                    `PRAGMA cache_size=${this.config.performance?.cacheSize || DEFAULT_CACHE_SIZE}`,
                    `PRAGMA mmap_size=${this.config.performance?.mmapSize || 30000000000}`,
                    
                    // Concurrency settings
                    `PRAGMA locking_mode=${this.config.sqlite?.lockingMode || 'NORMAL'}`,
                    `PRAGMA busy_timeout=${this.config.connection?.busyTimeout || DEFAULT_BUSY_TIMEOUT}`,
                    
                    // Maintenance settings
                    `PRAGMA auto_vacuum=${this.config.sqlite?.autoVacuum || 'NONE'}`,
                    
                    // Query optimization
                    'PRAGMA optimize'
                ];

                for (const pragma of pragmas) {
                    try {
                        await this.db.exec(pragma);
                    } catch (error) {
                        this.logger.error(`Failed to set pragma: ${pragma}`, {
                            error: error instanceof Error ? error.message : String(error)
                        });
                        throw error;
                    }
                }

                // Verify foreign keys are enabled
                const fkResult = await this.db.get('PRAGMA foreign_keys');
                if (!fkResult || !fkResult['foreign_keys']) {
                    throw new Error('Failed to enable foreign key constraints');
                }

                // Create tables and set up database schema
                await this.setupDatabase();

                this.isInitialized = true;
                this.logger.info('SQLite storage initialized', {
                    path: this.dbPath,
                    config: this.config
                });
            } catch (error) {
                this.logger.error('Failed to initialize SQLite storage', {
                    error: error instanceof Error ? error.message : String(error),
                    path: this.dbPath
                });
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    'Failed to initialize SQLite storage',
                    error instanceof Error ? error.message : String(error)
                );
            } finally {
                SqliteStorage.initializationPromise = null;
            }
        })();

        await SqliteStorage.initializationPromise;
    }

    /**
     * Sets up the database schema and tables
     */
    private async setupDatabase(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');

        try {
            // Create tables and indexes
            await this.db.exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                    path TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    parent_path TEXT,
                    notes TEXT,
                    reasoning TEXT,
                    dependencies TEXT,
                    subtasks TEXT,
                    metadata TEXT,
                    created_at INTEGER NOT NULL,
                    updated_at INTEGER NOT NULL,
                    version INTEGER NOT NULL DEFAULT 1
                );

                CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path);
                CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
                CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type);
            `);

            // Set WAL file permissions if needed
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
                const walPath = `${dbPath}-wal`;
                const shmPath = `${dbPath}-shm`;
                
                // Set permissions for WAL and SHM files if they exist
                await Promise.all([
                    fs.access(walPath).then(() => fs.chmod(walPath, 0o644)).catch(() => {}),
                    fs.access(shmPath).then(() => fs.chmod(shmPath, 0o644)).catch(() => {})
                ]);
            } catch (error) {
                this.logger.warn('Failed to set WAL file permissions', { error });
                // Don't throw - this is not critical
            }

            this.logger.info('Database schema setup completed');
        } catch (error) {
            this.logger.error('Failed to set up database schema', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    private isClosed = false;

    async close(): Promise<void> {
        if (!this.db || this.isClosed) {
            return;
        }

        try {
            // Cleanup any active transactions
            if (this.transactionScope?.isActive()) {
                await this.transactionScope.rollback();
            }

            this.isClosed = true;
            await this.db.close();
            this.db = null;
            this.logger.info('SQLite connection closed');
        } catch (error) {
            if (error instanceof Error && error.message.includes('Database handle is closed')) {
                // Ignore already closed errors
                return;
            }
            this.logger.error('Error closing SQLite connection', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    // Transaction methods
    async beginTransaction(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        await this.transactionScope.begin(IsolationLevel.SERIALIZABLE);
    }

    async commitTransaction(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        await this.transactionScope.commit();
    }

    async rollbackTransaction(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        await this.transactionScope.rollback();
    }

    /**
     * Executes work within a transaction
     */
    async executeInTransaction<T>(work: () => Promise<T>): Promise<T> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        return this.transactionScope.executeInTransaction(work);
    }

    // Task operations
    async createTask(input: CreateTaskInput): Promise<Task> {
        if (!this.db) throw new Error('Database not initialized');
        
        if (!input.path || !input.name || !input.type) {
            throw createError(
                ErrorCodes.VALIDATION_ERROR,
                'Missing required fields',
                'createTask',
                'path, name, and type are required'
            );
        }

        const now = Date.now();
        const projectPath = input.path.split('/')[0];
        
        const task: Task = {
            // System fields
            path: input.path,
            name: input.name,
            type: input.type,
            status: TaskStatus.PENDING,
            created: now,
            updated: now,
            version: 1,
            projectPath,

            // Optional fields
            description: input.description,
            parentPath: input.parentPath,
            notes: input.notes || [],
            reasoning: input.reasoning,
            dependencies: input.dependencies || [],
            subtasks: [],
            
            // User metadata
            metadata: input.metadata || {}
        };

        await this.saveTask(task);
        return task;
    }

    async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
        if (!this.db) throw new Error('Database not initialized');
        
        const existingTask = await this.getTask(path);
        if (!existingTask) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                'Task not found',
                'updateTask',
                path
            );
        }

        const now = Date.now();
        const updatedTask: Task = {
            ...existingTask,
            ...updates,
            // Update system fields
            updated: now,
            version: existingTask.version + 1,
            // Keep user metadata separate
            metadata: {
                ...existingTask.metadata,
                ...updates.metadata
            }
        };

        await this.saveTask(updatedTask);
        return updatedTask;
    }

    async getTask(path: string): Promise<Task | null> {
        if (!this.db) throw new Error('Database not initialized');
        
        const row = await this.db.get<Record<string, unknown>>(
            'SELECT * FROM tasks WHERE path = ?',
            path
        );

        if (!row) return null;
        return this.rowToTask(row);
    }

    async getTasks(paths: string[]): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        if (paths.length === 0) return [];

        const placeholders = paths.map(() => '?').join(',');
        const rows = await this.db.all<Record<string, unknown>[]>(
            `SELECT * FROM tasks WHERE path IN (${placeholders})`,
            ...paths
        );

        return rows.map(row => this.rowToTask(row));
    }

    async getTasksByPattern(pattern: string): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        const sqlPattern = pattern.replace(/\*/g, '%').replace(/\?/g, '_');
        const rows = await this.db.all<Record<string, unknown>[]>(
            'SELECT * FROM tasks WHERE path LIKE ?',
            sqlPattern
        );

        return rows.map(row => this.rowToTask(row));
    }

    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        const rows = await this.db.all<Record<string, unknown>[]>(
            'SELECT * FROM tasks WHERE status = ?',
            status
        );

        return rows.map(row => this.rowToTask(row));
    }

    async getSubtasks(parentPath: string): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        const rows = await this.db.all<Record<string, unknown>[]>(
            'SELECT * FROM tasks WHERE parent_path = ?',
            parentPath
        );

        return rows.map(row => this.rowToTask(row));
    }

    async deleteTask(path: string): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.deleteTasks([path]);
    }

    async deleteTasks(paths: string[]): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        if (paths.length === 0) return;

        const placeholders = paths.map(() => '?').join(',');
        await this.db.run(
            `DELETE FROM tasks WHERE path IN (${placeholders})`,
            ...paths
        );
    }

    async hasChildren(path: string): Promise<boolean> {
        if (!this.db) throw new Error('Database not initialized');
        const result = await this.db.get<{ count: number }>(
            'SELECT COUNT(*) as count FROM tasks WHERE parent_path = ?',
            path
        );
        return (result?.count || 0) > 0;
    }

    async getDependentTasks(path: string): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        const rows = await this.db.all<Record<string, unknown>[]>(
            `SELECT * FROM tasks WHERE json_array_length(dependencies) > 0 
             AND json_extract(dependencies, '$') LIKE '%${path}%'`
        );
        return rows.map(row => this.rowToTask(row));
    }

    async saveTask(task: Task): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.saveTasks([task]);
    }

    async saveTasks(tasks: Task[]): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        for (const task of tasks) {
            await this.db.run(
                `INSERT OR REPLACE INTO tasks (
                    path, name, description, type, status,
                    parent_path, notes, reasoning, dependencies,
                    subtasks, metadata, created_at, updated_at, version
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                task.path,
                task.name,
                task.description,
                task.type,
                task.status,
                task.parentPath,
                task.notes ? JSON.stringify(task.notes) : null,
                task.reasoning,
                JSON.stringify(task.dependencies),
                JSON.stringify(task.subtasks),
                JSON.stringify(task.metadata),
                task.created,
                task.updated,
                task.version
            );
        }
    }

    async clearAllTasks(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.db.run('DELETE FROM tasks');
    }

    private rowToTask(row: Record<string, unknown>): Task {
        const metadata = this.parseJSON(String(row.metadata || '{}'), {});
        const now = Date.now();
        
        return {
            // System fields
            path: String(row.path || ''),
            name: String(row.name || ''),
            type: String(row.type || '') as Task['type'],
            status: String(row.status || '') as TaskStatus,
            created: Number(row.created_at || now),
            updated: Number(row.updated_at || now),
            version: Number(row.version || 1),
            projectPath: String(row.path || '').split('/')[0],

            // Optional fields
            description: row.description ? String(row.description) : undefined,
            parentPath: row.parent_path ? String(row.parent_path) : undefined,
            notes: this.parseJSON<string[]>(String(row.notes || '[]'), []),
            reasoning: row.reasoning ? String(row.reasoning) : undefined,
            dependencies: this.parseJSON<string[]>(String(row.dependencies || '[]'), []),
            subtasks: this.parseJSON<string[]>(String(row.subtasks || '[]'), []),
            
            // User metadata
            metadata
        };
    }

    private parseJSON<T>(value: string | null | undefined, defaultValue: T): T {
        if (!value) return defaultValue;
        try {
            return JSON.parse(value) as T;
        } catch {
            return defaultValue;
        }
    }

    async vacuum(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        
        // Ensure no active transaction before vacuum
        await this.transactionScope.ensureNoTransaction();
        
        try {
            await this.db.run('VACUUM');
            this.logger.info('Database vacuum completed');
        } catch (error) {
            this.logger.error('Failed to vacuum database', { error });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to vacuum database',
                'vacuum',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    async analyze(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.db.run('ANALYZE');
    }

    async checkpoint(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.db.run('PRAGMA wal_checkpoint(TRUNCATE)');
    }

    async repairRelationships(dryRun: boolean = false): Promise<{ fixed: number, issues: string[] }> {
        if (!this.db) throw new Error('Database not initialized');
        
        const issues: string[] = [];
        let fixed = 0;

        // Find tasks with invalid parent paths
        const orphanedTasks = await this.db.all<Record<string, unknown>[]>(
            `SELECT t1.path, t1.parent_path 
             FROM tasks t1 
             LEFT JOIN tasks t2 ON t1.parent_path = t2.path 
             WHERE t1.parent_path IS NOT NULL 
             AND t2.path IS NULL`
        );

        for (const task of orphanedTasks) {
            issues.push(`Task ${task.path} has invalid parent_path: ${task.parent_path}`);
            if (!dryRun) {
                await this.db.run(
                    'UPDATE tasks SET parent_path = NULL WHERE path = ?',
                    task.path
                );
                fixed++;
            }
        }

        return { fixed, issues };
    }

    async clearCache(): Promise<void> {
        // SQLite implementation doesn't use cache
        return;
    }

    /**
     * Verifies database integrity and repairs if needed
     */
    async verifyIntegrity(): Promise<boolean> {
        if (!this.db) throw new Error('Database not initialized');
        
        try {
            await this.beginTransaction();
            
            try {
                await this.analyze();
                await this.vacuum();
                await this.checkpoint();
                
                await this.commitTransaction();
                
                this.logger.info('SQLite integrity check passed');
                return true;
            } catch (error) {
                await this.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            this.logger.error('SQLite integrity check failed', {
                error: error instanceof Error ? error.message : String(error)
            });
            return false;
        }
    }

    /**
     * Gets detailed database statistics
     */
    async getStats(): Promise<{
        size: number;
        walSize: number;
        pageCount: number;
        pageSize: number;
        journalMode: string;
    }> {
        if (!this.db) throw new Error('Database not initialized');
        
        try {
            const metrics = await this.getMetrics();
            const fs = await import('fs/promises');
            
            const stats = await fs.stat(this.dbPath);
            const walPath = `${this.dbPath}-wal`;
            const walStats = await fs.stat(walPath).catch(() => ({ size: 0 }));

            const result = {
                size: stats.size,
                walSize: walStats.size,
                pageCount: metrics.storage.pageCount,
                pageSize: metrics.storage.pageSize,
                journalMode: 'WAL'
            };

            this.logger.debug('SQLite stats retrieved', { stats: result });
            return result;
        } catch (error) {
            this.logger.error('Failed to get SQLite stats', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    async getMetrics(): Promise<{
        tasks: {
            total: number;
            byStatus: Record<string, number>;
            noteCount: number;
            dependencyCount: number;
        };
        storage: {
            totalSize: number;
            pageSize: number;
            pageCount: number;
            walSize: number;
            cache: {
                hitRate: number;
                memoryUsage: number;
                entryCount: number;
            };
        };
    }> {
        if (!this.db) throw new Error('Database not initialized');

        const [taskStats, statusStats, storageStats] = await Promise.all([
            this.db.get<{
                total: number;
                noteCount: number;
                dependencyCount: number;
            }>(`
                SELECT 
                    COUNT(*) as total,
                    COUNT(CASE WHEN notes IS NOT NULL THEN 1 END) as noteCount,
                    SUM(CASE 
                        WHEN dependencies IS NOT NULL 
                        AND json_valid(dependencies) 
                        AND json_array_length(dependencies) > 0 
                        THEN json_array_length(dependencies) 
                        ELSE 0 
                    END) as dependencyCount
                FROM tasks
            `),
            this.db.all<{ status: string; count: number }[]>(`
                SELECT status, COUNT(*) as count
                FROM tasks
                GROUP BY status
            `),
            this.db.get<{
                page_count: number;
                page_size: number;
            }>(`
                SELECT 
                    page_count,
                    page_size
                FROM pragma_page_count, pragma_page_size
                LIMIT 1
            `)
        ]);

        // Convert status stats array to object
        const byStatus = statusStats.reduce((acc: Record<string, number>, curr) => {
            acc[curr.status] = curr.count;
            return acc;
        }, {});

        const totalSize = (storageStats?.page_count || 0) * (storageStats?.page_size || 0);
        const memUsage = process.memoryUsage();

        return {
            tasks: {
                total: Number(taskStats?.total || 0),
                byStatus,
                noteCount: Number(taskStats?.noteCount || 0),
                dependencyCount: Number(taskStats?.dependencyCount || 0)
            },
            storage: {
                totalSize,
                pageSize: Number(storageStats?.page_size || 0),
                pageCount: Number(storageStats?.page_count || 0),
                walSize: 0, // WAL size is dynamic
                cache: {
                    hitRate: 0, // SQLite implementation doesn't use cache
                    memoryUsage: memUsage.heapUsed,
                    entryCount: 0
                }
            }
        };
    }
}

================
File: src/storage/connection-manager.ts
================
/**
 * Database connection manager
 */
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';

export class ConnectionManager {
    private readonly logger: Logger;
    private readonly maxRetries: number;
    private readonly retryDelay: number;
    private readonly busyTimeout: number;

    constructor(options: {
        maxRetries?: number;
        retryDelay?: number;
        busyTimeout?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionManager' });
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.busyTimeout = options.busyTimeout || 5000;
    }

    /**
     * Executes a database operation with retries
     */
    async executeWithRetry<T>(
        operation: () => Promise<T>,
        context: string
    ): Promise<T> {
        let lastError: Error | undefined;
        let retryCount = 0;

        while (retryCount < this.maxRetries) {
            try {
                const result = await operation();
                // Operation succeeded
                if (retryCount > 0) {
                    this.logger.info(`Operation succeeded after ${retryCount} retries`, {
                        context
                    });
                }
                return result;
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                retryCount++;

                // Log detailed error info
                const errorDetails = lastError instanceof Error ? {
                    name: lastError.name,
                    message: lastError.message,
                    code: (lastError as any).code,
                    errno: (lastError as any).errno
                } : lastError;

                this.logger.warn(`Operation failed${retryCount < this.maxRetries ? ', retrying' : ''}`, {
                    attempt: retryCount,
                    maxRetries: this.maxRetries,
                    error: errorDetails,
                    context
                });

                // Check if error is WAL-related
                const isWalError = lastError instanceof Error && 
                    (lastError.message.includes('WAL') || 
                     lastError.message.includes('journal_mode') ||
                     lastError.message.includes('Safety level'));

                if (retryCount < this.maxRetries) {
                    // Longer delay for WAL-related errors
                    const baseDelay = isWalError ? 1000 : this.retryDelay;
                    const delay = Math.min(
                        baseDelay * Math.pow(2, retryCount - 1) * (0.5 + Math.random()),
                        isWalError ? 10000 : 5000 // Higher cap for WAL errors
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // All retries failed
        throw createError(
            ErrorCodes.STORAGE_ERROR,
            'Operation failed',
            `Failed after ${this.maxRetries} retries: ${lastError?.message}`,
            lastError?.message
        );
    }

    /**
     * Handles database busy state
     */
    async handleBusy(
        operation: () => Promise<void>,
        context: string
    ): Promise<void> {
        const startTime = Date.now();

        while (true) {
            try {
                await operation();
                return;
            } catch (error) {
                const elapsed = Date.now() - startTime;
                if (elapsed >= this.busyTimeout) {
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Operation timed out',
                        `Timed out after ${elapsed}ms: ${error instanceof Error ? error.message : String(error)}`
                    );
                }

                this.logger.warn('Database busy, waiting...', {
                    elapsed,
                    timeout: this.busyTimeout,
                    context
                });

                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
}

================
File: src/storage/factory.ts
================
/**
 * Storage factory for creating task storage instances
 */
import { TaskStorage } from '../types/storage.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { 
    SqliteStorage,
    SqliteConfig,
    DEFAULT_PAGE_SIZE,
    DEFAULT_CACHE_SIZE,
    DEFAULT_BUSY_TIMEOUT
} from './sqlite/index.js';
import { ConfigManager } from '../config/index.js';
import { promises as fs } from 'fs';
import { Logger } from '../logging/index.js';

/**
 * Storage factory class for managing singleton storage instance
 */
class StorageFactory {
    private static instance: StorageFactory | null = null;
    private static initializationPromise: Promise<StorageFactory> | null = null;
    private storageInstance: TaskStorage | null = null;
    private static logger: Logger;

    private static initLogger(): void {
        if (!StorageFactory.logger) {
            StorageFactory.logger = Logger.getInstance().child({ component: 'StorageFactory' });
        }
    }

    private constructor() {
        StorageFactory.initLogger();
    }

    /**
     * Gets the StorageFactory instance
     */
    static async getInstance(): Promise<StorageFactory> {
        // Return existing instance if available
        if (StorageFactory.instance) {
            return StorageFactory.instance;
        }

        // If initialization is in progress, wait for it
        if (StorageFactory.initializationPromise) {
            return StorageFactory.initializationPromise;
        }

        // Start new initialization with mutex
        StorageFactory.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (StorageFactory.instance) {
                    return StorageFactory.instance;
                }

                StorageFactory.instance = new StorageFactory();
                return StorageFactory.instance;
            } catch (error) {
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    `Failed to initialize StorageFactory: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                StorageFactory.initializationPromise = null;
            }
        })();

        return StorageFactory.initializationPromise;
    }

    /**
     * Creates or returns the singleton storage instance
     */
    async createStorage(config: SqliteConfig): Promise<TaskStorage> {
        try {
            // Return existing instance if available
            if (this.storageInstance) {
                StorageFactory.logger.debug('Returning existing storage instance');
                return this.storageInstance;
            }

            StorageFactory.logger.info('Creating new storage instance', {
                baseDir: config.baseDir,
                name: config.name
            });

            // Ensure base directory exists with platform-appropriate permissions
            await fs.mkdir(config.baseDir, { 
                recursive: true, 
                mode: process.platform === 'win32' ? undefined : 0o755 
            });

            // Apply SQLite-specific defaults
            const sqliteConfig: SqliteConfig = {
                ...config,
                sqlite: {
                    journalMode: 'WAL',
                    synchronous: 'NORMAL',
                    tempStore: 'MEMORY',
                    lockingMode: 'NORMAL',
                    autoVacuum: 'NONE',
                    ...config.sqlite
                },
                performance: {
                    pageSize: DEFAULT_PAGE_SIZE,
                    cacheSize: DEFAULT_CACHE_SIZE,
                    ...config.performance
                },
                connection: {
                    busyTimeout: DEFAULT_BUSY_TIMEOUT,
                    ...config.connection
                }
            };

            // Create and initialize storage
            const storage = new SqliteStorage(sqliteConfig);
            await storage.initialize();
            
            // Only set singleton after successful initialization
            this.storageInstance = storage;
            StorageFactory.logger.info('Storage instance created successfully');
            return storage;
        } catch (error) {
            // Clear storage instance on error
            this.storageInstance = null;
            StorageFactory.logger.error('Failed to create storage instance', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to create storage',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Creates or returns the storage instance with default configuration
     */
    async createDefaultStorage(): Promise<TaskStorage> {
        try {
            // Return existing instance if available
            if (this.storageInstance) {
                StorageFactory.logger.debug('Returning existing default storage instance');
                return this.storageInstance;
            }

            const configManager = ConfigManager.getInstance();
            const config = configManager.getConfig();
            
            if (!config.storage) {
                throw new Error('Storage configuration not found in ConfigManager');
            }

            StorageFactory.logger.info('Creating default storage instance');
            return this.createStorage(config.storage as SqliteConfig);
        } catch (error) {
            StorageFactory.logger.error('Failed to create default storage', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to create default storage',
                error instanceof Error ? error.message : String(error)
            );
        }
    }
}

// Export factory instance creation functions
export async function createStorage(config: SqliteConfig): Promise<TaskStorage> {
    const factory = await StorageFactory.getInstance();
    return factory.createStorage(config);
}

export async function createDefaultStorage(): Promise<TaskStorage> {
    const factory = await StorageFactory.getInstance();
    return factory.createDefaultStorage();
}

================
File: src/storage/index.ts
================
/**
 * Storage module exports
 */
export { createStorage, createDefaultStorage } from './factory.js';
export { SqliteStorage } from './sqlite/index.js';

================
File: src/storage/sqlite-storage.ts
================
/**
 * SQLite storage implementation
 */
import { Database, open } from 'sqlite';
import { Task, TaskStatus, TaskType, CreateTaskInput, UpdateTaskInput } from '../types/task.js';
import { 
    StorageConfig, 
    TaskStorage, 
    StorageMetrics, 
    CacheStats
} from '../types/storage.js';
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { ConnectionManager } from './connection-manager.js';
import { globToSqlPattern } from '../utils/pattern-matcher.js';

interface TaskCacheEntry {
    task: Task;
    timestamp: number;
    hits: number;
}

export class SqliteStorage implements TaskStorage {
    private db: Database | null = null;
    private readonly logger: Logger;
    private readonly config: StorageConfig;
    private readonly connectionManager: ConnectionManager;
    private readonly cache: Map<string, TaskCacheEntry> = new Map();
    private readonly MAX_CACHE_SIZE = 1000;
    private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
    private cacheHits = 0;
    private cacheMisses = 0;

    constructor(config: StorageConfig) {
        this.config = config;
        this.logger = Logger.getInstance().child({ component: 'SqliteStorage' });
        this.connectionManager = new ConnectionManager(config.connection);
    }

    async initialize(): Promise<void> {
        const path = await import('path');
const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
        this.logger.info('Opening SQLite database', { 
            dbPath,
            baseDir: this.config.baseDir,
            name: this.config.name,
            fullPath: (await import('path')).resolve(dbPath)
        });

        try {
            // Import required modules
            const fs = await import('fs/promises');
            const path = await import('path');
            
            // Ensure storage directory exists and is writable
            const dirPath = path.dirname(dbPath);
            try {
                // Create directory with proper permissions
                await fs.mkdir(dirPath, { 
                    recursive: true, 
                    // Skip mode on Windows as it's ignored
                    ...(process.platform !== 'win32' && { mode: 0o755 })
                });

                // Verify directory is writable
                await fs.access(dirPath, fs.constants.W_OK);
                
                // Log directory contents
                const dirContents = await fs.readdir(dirPath);
                this.logger.info('Storage directory ready:', { 
                    path: dirPath,
                    contents: dirContents,
                    writable: true
                });
            } catch (err) {
                const error = err as NodeJS.ErrnoException;
                this.logger.error('Storage directory error', {
                    path: dirPath,
                    code: error.code,
                    errno: error.errno,
                    syscall: error.syscall
                });
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    'Storage directory not writable',
                    `Failed to access ${dirPath}: ${error.message}`
                );
            }

            // Import sqlite3 with verbose mode for better error messages
            const sqlite3 = await import('sqlite3');
            this.logger.info('SQLite3 module imported', {
                sqlite3: typeof sqlite3.default,
                modes: Object.keys(sqlite3.default)
            });

            // Initialize database with retry support
            await this.connectionManager.executeWithRetry(async () => {
                try {
                    // Open database with retry for locked files
                    await this.connectionManager.handleBusy(async () => {
                        this.db = await open({
                            filename: dbPath,
                            driver: sqlite3.default.Database,
                            mode: sqlite3.default.OPEN_READWRITE | sqlite3.default.OPEN_CREATE
                        });
                        this.logger.debug('Database opened successfully');
                    }, 'open_database');

                    return this.withDb(async (db) => {
                        // Set basic PRAGMAs first
                        await db.exec(`
                            PRAGMA busy_timeout=${this.config.connection?.busyTimeout || 5000};
                            PRAGMA temp_store=MEMORY;
                            PRAGMA foreign_keys=ON;
                            PRAGMA locking_mode=EXCLUSIVE;
                        `);

                        // Check and enable WAL mode with exclusive lock
                        await this.connectionManager.handleBusy(async () => {
                            const currentMode = await db.get<{value: string}>('PRAGMA journal_mode');
                            this.logger.info('Current journal mode:', { mode: currentMode?.value });

                            if (currentMode?.value !== 'wal') {
                                await db.exec(`
                                    PRAGMA locking_mode=EXCLUSIVE;
                                    PRAGMA journal_mode=WAL;
                                `);
                                const walMode = await db.get<{value: string}>('PRAGMA journal_mode');
                                if (walMode?.value !== 'wal') {
                                    this.logger.error('Failed to set WAL mode', {
                                        requested: 'wal',
                                        actual: walMode?.value,
                                        currentMode: currentMode?.value
                                    });
                                    throw new Error(`Failed to enable WAL mode: got ${walMode?.value}`);
                                }
                                this.logger.info('WAL mode enabled successfully');
                            } else {
                                this.logger.info('Database already in WAL mode');
                            }
                        }, 'enable_wal');

                        // Set other PRAGMAs after WAL mode is confirmed
                        await db.exec(`
                            PRAGMA synchronous=NORMAL;
                            PRAGMA wal_autocheckpoint=1000;
                            PRAGMA cache_size=${this.config.performance?.cacheSize || 2000};
                            PRAGMA mmap_size=${this.config.performance?.mmapSize || 30000000000};
                            PRAGMA page_size=${this.config.performance?.pageSize || 4096};
                        `);

                        // Create schema and set up database
                        await this.setupDatabase();

                        // Force a write to create WAL files
                        await db.exec(`
                            BEGIN IMMEDIATE;
                            CREATE TABLE IF NOT EXISTS _wal_test (id INTEGER PRIMARY KEY);
                            INSERT OR REPLACE INTO _wal_test (id) VALUES (1);
                            COMMIT;
                        `);

                        // Ensure WAL mode persisted after write
                        const journalMode = await db.get<{value: string}>('PRAGMA journal_mode');
                        this.logger.info('Journal mode confirmed:', { mode: journalMode?.value });

                        if (journalMode?.value !== 'wal') {
                            throw new Error('WAL mode not persisted after write');
                        }

                        // Log WAL status
                        const fs = await import('fs/promises');
                        const walPath = `${dbPath}-wal`;
                        const shmPath = `${dbPath}-shm`;
                        
                        try {
                            await Promise.all([
                                fs.access(walPath),
                                fs.access(shmPath)
                            ]);
                            this.logger.info('WAL files present', {
                                wal: walPath,
                                shm: shmPath
                            });
                        } catch (err) {
                            this.logger.warn('WAL files not immediately visible', {
                                error: err,
                                note: 'This may be normal if files are being created'
                            });
                        }

                        this.logger.info('SQLite storage initialized', { 
                            path: this.config.baseDir,
                            journalMode: journalMode?.value
                        });
                    });
                } catch (err) {
                    this.logger.error('Failed to initialize database', {
                        error: err instanceof Error ? {
                            name: err.name,
                            message: err.message,
                            stack: err.stack,
                            code: (err as any).code,
                            errno: (err as any).errno
                        } : err
                    });
                    throw err;
                }
            }, 'initialize');
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            const errorDetails = {
                error: error instanceof Error ? {
                    stack: error.stack,
                    ...error,
                    // Ensure custom properties don't get overwritten
                    customProps: Object.getOwnPropertyNames(error).reduce((acc, key) => {
                        if (key !== 'name' && key !== 'message' && key !== 'stack') {
                            acc[key] = (error as any)[key];
                        }
                        return acc;
                    }, {} as Record<string, unknown>)
                } : error,
                config: {
                    baseDir: this.config.baseDir,
                    name: this.config.name,
                    dbPath: `${this.config.baseDir}/${this.config.name}.db`
                }
            };
            
            this.logger.error('Failed to initialize SQLite storage', errorDetails);
            
            // Try to get more details about the SQLite error
            if (error instanceof Error && 'code' in error) {
                this.logger.error('SQLite error details', {
                    code: (error as any).code,
                    errno: (error as any).errno,
                    syscall: (error as any).syscall
                });
            }
            
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize SQLite storage',
                `${errorMessage} - Details: ${JSON.stringify(errorDetails, null, 2)}`
            );
        }
    }

    private async setupDatabase(): Promise<void> {
        return this.withDb(async (db) => {
            // Create tables and indexes
            await db.exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                    path TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    parent_path TEXT,
                    notes TEXT,
                    reasoning TEXT,
                    dependencies TEXT,
                    subtasks TEXT,
                    metadata TEXT,
                    created_at INTEGER NOT NULL,
                    updated_at INTEGER NOT NULL,
                    version INTEGER NOT NULL DEFAULT 1
                );

                CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path);
                CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
                CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type);
            `);

            // Set WAL file permissions if needed
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
                const walPath = `${dbPath}-wal`;
                const shmPath = `${dbPath}-shm`;
                
                // Set permissions for WAL and SHM files if they exist and not on Windows
                if (process.platform !== 'win32') {
                    await Promise.all([
                        fs.access(walPath).then(() => fs.chmod(walPath, 0o644)).catch(() => {}),
                        fs.access(shmPath).then(() => fs.chmod(shmPath, 0o644)).catch(() => {})
                    ]);
                }
            } catch (error) {
                this.logger.warn('Failed to set WAL file permissions', { error });
                // Don't throw - this is not critical
            }
        });
    }

    async createTask(input: CreateTaskInput): Promise<Task> {
        if (!input.name) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Task name is required',
                'createTask'
            );
        }

        // Generate path first
        const taskPath = input.path || input.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
        
        // Then create task with the generated path
        const now = Date.now();
        const projectPath = input.path?.split('/')[0] || taskPath.split('/')[0];
        
        const task: Task = {
            // System fields
            path: taskPath,
            name: input.name,
            type: input.type || TaskType.TASK,
            status: TaskStatus.PENDING,
            created: now,
            updated: now,
            version: 1,
            projectPath,

            // Optional fields
            description: input.description || undefined,
            parentPath: input.parentPath || undefined,
            notes: input.notes || [],
            reasoning: input.reasoning || undefined,
            dependencies: input.dependencies || [],
            subtasks: [],
            
            // User metadata
            metadata: input.metadata || {}
        };

        await this.saveTask(task);
        return task;
    }

    async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
        const existingTask = await this.getTask(path);
        if (!existingTask) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                'Task not found',
                'updateTask',
                path
            );
        }

        const now = Date.now();
        const updatedTask: Task = {
            ...existingTask,
            ...updates,
            // Update system fields
            updated: now,
            version: existingTask.version + 1,
            // Keep user metadata separate
            metadata: {
                ...existingTask.metadata,
                ...updates.metadata
            }
        };

        await this.saveTask(updatedTask);
        return updatedTask;
    }

    async hasChildren(path: string): Promise<boolean> {
        return this.withDb(async (db) => {
            const result = await db.get<{ count: number }>(
                'SELECT COUNT(*) as count FROM tasks WHERE parent_path = ?',
                path
            );
            return (result?.count || 0) > 0;
        });
    }

    async getDependentTasks(path: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            const rows = await db.all<Record<string, unknown>[]>(
                `SELECT * FROM tasks WHERE json_array_length(dependencies) > 0 
                 AND json_extract(dependencies, '$') LIKE '%${path}%'`
            );
            return rows.map(row => this.rowToTask(row));
        });
    }

    async saveTask(task: Task): Promise<void> {
        await this.saveTasks([task]);
    }

    private async withDb<T>(operation: (db: Database) => Promise<T>): Promise<T> {
        if (!this.db) {
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Database not initialized'
            );
        }
        return operation(this.db);
    }

    private transactionDepth = 0;

    private async inTransaction<T>(operation: () => Promise<T>): Promise<T> {
        return this.withDb(async (db) => {
            // If we're already in a transaction, just execute the operation
            if (this.transactionDepth > 0) {
                this.transactionDepth++;
                try {
                    return await operation();
                } finally {
                    this.transactionDepth--;
                }
            }

            // Start a new transaction
            this.transactionDepth = 1;
            try {
                await db.run('BEGIN IMMEDIATE');
                this.logger.debug('Started new transaction');
                
                const result = await operation();
                
                // Only commit if we haven't already committed
                if (this.transactionDepth === 1) {
                    await db.run('COMMIT');
                    this.logger.debug('Committed transaction');
                }
                
                return result;
            } catch (error) {
                // Only rollback if we haven't already rolled back
                if (this.transactionDepth === 1) {
                    try {
                        await db.run('ROLLBACK');
                        this.logger.debug('Rolled back transaction');
                    } catch (rollbackError) {
                        this.logger.error('Failed to rollback transaction', {
                            error: rollbackError,
                            originalError: error
                        });
                    }
                }
                throw error;
            } finally {
                this.transactionDepth = 0;
            }
        });
    }

    async saveTasks(tasks: Task[]): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {

                // First pass: collect all parent paths to load existing parents
                const parentPaths = new Set<string>();
                for (const task of tasks) {
                    if (task.parentPath) {
                        parentPaths.add(task.parentPath);
                    }
                }

                // Load existing parents
                const existingParents = new Map<string, Task>();
                if (parentPaths.size > 0) {
                    const placeholders = Array(parentPaths.size).fill('?').join(',');
                    const rows = await db.all<Record<string, unknown>[]>(
                        `SELECT * FROM tasks WHERE path IN (${placeholders})`,
                        Array.from(parentPaths)
                    );
                    for (const row of rows) {
                        const parent = this.rowToTask(row);
                        existingParents.set(parent.path, parent);
                    }
                }

                // Second pass: update parent-child relationships
                for (const task of tasks) {
                    if (task.parentPath) {
                        let parent = existingParents.get(task.parentPath);
                        if (parent) {
                            // Update parent's subtasks array if needed
                            if (!parent.subtasks.includes(task.path)) {
                                parent.subtasks = [...parent.subtasks, task.path];
                                existingParents.set(parent.path, parent);
                                tasks.push(parent); // Add parent to tasks to be saved
                            }
                        }
                    }
                }

                // Save all tasks with updated relationships
                for (const task of tasks) {
                    this.logger.info('Saving task:', { task });
                    await db.run(
                        `INSERT OR REPLACE INTO tasks (
                            path, name, description, type, status,
                            parent_path, notes, reasoning, dependencies,
                            subtasks, metadata, created_at, updated_at,
                            version
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                        task.path,
                        task.name,
                        task.description,
                        task.type,
                        task.status,
                        task.parentPath,
                        task.notes ? JSON.stringify(task.notes) : null,
                        task.reasoning,
                        JSON.stringify(task.dependencies),
                        JSON.stringify(task.subtasks),
                        JSON.stringify(task.metadata),
                        task.created,
                        task.updated,
                        task.version
                    );
                }
            });
        });
    }

    /**
     * Implements CacheManager.clearCache
     */
    async clearCache(): Promise<void> {
        this.cache.clear();
        this.cacheHits = 0;
        this.cacheMisses = 0;
        this.logger.debug('Cache cleared');
    }

    /**
     * Implements CacheManager.getCacheStats
     */
    async getCacheStats(): Promise<CacheStats> {
        const totalRequests = this.cacheHits + this.cacheMisses;
        return {
            size: this.cache.size,
            hits: this.cacheHits,
            misses: this.cacheMisses,
            hitRate: totalRequests > 0 ? this.cacheHits / totalRequests : 0,
            memoryUsage: process.memoryUsage().heapUsed
        };
    }

    /**
     * Gets a task from cache or database
     */
    async getTask(path: string): Promise<Task | null> {
        // Check cache first
        const cached = this.cache.get(path);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            cached.hits++;
            this.cacheHits++;
            return cached.task;
        }
        this.cacheMisses++;

        return this.withDb(async (db) => {
            try {
                const row = await db.get<Record<string, unknown>>(
                    'SELECT * FROM tasks WHERE path = ?',
                    path
                );

                if (!row) {
                    return null;
                }

                const task = this.rowToTask(row);
                
                // Add to cache with LRU eviction
                if (this.cache.size >= this.MAX_CACHE_SIZE) {
                    // Find least recently used entry
                    let oldestTime = Date.now();
                    let oldestKey = '';
                    for (const [key, entry] of this.cache.entries()) {
                        if (entry.timestamp < oldestTime) {
                            oldestTime = entry.timestamp;
                            oldestKey = key;
                        }
                    }
                    this.cache.delete(oldestKey);
                }
                
                this.cache.set(path, {
                    task,
                    timestamp: Date.now(),
                    hits: 1
                });

                return task;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get task', { error: errorMessage, path });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get task',
                    errorMessage
                );
            }
        });
    }

    async getTasks(paths: string[]): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                const placeholders = paths.map(() => '?').join(',');
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE path IN (${placeholders})`,
                    ...paths
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks', { error: errorMessage, paths });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks',
                    errorMessage
                );
            }
        });
    }

    async getTasksByPattern(pattern: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                // Convert glob pattern to SQL pattern
                const sqlPattern = globToSqlPattern(pattern);

                this.logger.debug('Converting glob pattern to SQL', {
                    original: pattern,
                    sql: sqlPattern
                });

                // Use both GLOB and LIKE for better pattern matching
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE 
                     path GLOB ? OR 
                     path LIKE ? OR
                     path LIKE ?`,
                    sqlPattern,
                    sqlPattern,
                    // Add recursive matching for **
                    pattern.includes('**') ? `${sqlPattern}/%` : sqlPattern
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks by pattern', { error: errorMessage, pattern });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks by pattern',
                    errorMessage
                );
            }
        });
    }

    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                const rows = await db.all<Record<string, unknown>[]>(
                    'SELECT * FROM tasks WHERE status = ?',
                    status
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks by status', { error: errorMessage, status });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks by status',
                    errorMessage
                );
            }
        });
    }

    async getSubtasks(parentPath: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                // Get the parent task first
                const parent = await this.getTask(parentPath);
                if (!parent) {
                    return [];
                }

                // Get all tasks that have this parent path
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE parent_path = ?`,
                    parentPath
                );

                // Convert rows to tasks
                const tasks = rows.map(row => this.rowToTask(row));

                // Ensure consistency - update any tasks that have this parent
                // but aren't in the parent's subtasks array
                const needsUpdate = tasks.some(task => 
                    task.parentPath === parentPath && !parent.subtasks.includes(task.path)
                );

                if (needsUpdate) {
                    parent.subtasks = Array.from(new Set([
                        ...parent.subtasks,
                        ...tasks.filter(t => t.parentPath === parentPath).map(t => t.path)
                    ]));
                    await this.saveTask(parent);
                }

                return tasks;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get subtasks', { error: errorMessage, parentPath });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get subtasks',
                    errorMessage
                );
            }
        });
    }

    async deleteTask(path: string): Promise<void> {
        await this.deleteTasks([path]);
    }

    async deleteTasks(paths: string[]): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {
                // Get all tasks that need to be deleted using recursive CTE
                const placeholders = paths.map(() => '?').join(',');
                const rows = await db.all<Record<string, unknown>[]>(
                    `WITH RECURSIVE task_tree AS (
                        -- Base case: tasks with paths in the input list
                        SELECT path, parent_path, json_extract(subtasks, '$') as subtasks
                        FROM tasks 
                        WHERE path IN (${placeholders})
                        
                        UNION ALL
                        
                        -- Recursive case 1: tasks with parent_path matching any task in tree
                        SELECT t.path, t.parent_path, json_extract(t.subtasks, '$')
                        FROM tasks t
                        JOIN task_tree tt ON t.parent_path = tt.path
                        
                        UNION ALL
                        
                        -- Recursive case 2: tasks listed in subtasks array of any task in tree
                        SELECT t.path, t.parent_path, json_extract(t.subtasks, '$')
                        FROM tasks t
                        JOIN task_tree tt ON json_each.value = t.path
                        JOIN json_each(tt.subtasks)
                    )
                    SELECT DISTINCT path FROM task_tree`,
                    ...paths
                );

                const allPaths = rows.map(row => String(row.path));
                this.logger.debug('Found tasks to delete', { 
                    inputPaths: paths,
                    foundPaths: allPaths 
                });

                // Get all tasks before deletion for proper cleanup
                const tasksToDelete = await Promise.all(
                    allPaths.map(path => this.getTask(path))
                );
                const validTasksToDelete = tasksToDelete.filter((t): t is Task => t !== null);

                // Find all parent paths that need updating
                const parentsToUpdate = new Set(
                    validTasksToDelete
                        .filter(t => t.parentPath)
                        .map(t => t.parentPath as string)
                );

                // Update parent tasks' subtasks arrays
                for (const parentPath of parentsToUpdate) {
                    const parent = await this.getTask(parentPath);
                    if (parent && !allPaths.includes(parent.path)) {
                        parent.subtasks = parent.subtasks.filter(p => !allPaths.includes(p));
                        await this.saveTask(parent);
                    }
                }

                // Delete all tasks and their descendants
                if (allPaths.length > 0) {
                    const deletePlaceholders = allPaths.map(() => '?').join(',');
                    await db.run(
                        `DELETE FROM tasks WHERE path IN (${deletePlaceholders})`,
                        ...allPaths
                    );
                }

                this.logger.debug('Tasks deleted with descendants', {
                    inputPaths: paths,
                    deletedPaths: allPaths
                });
            });
        });
    }

    async vacuum(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('VACUUM');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to vacuum database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to vacuum database',
                    errorMessage
                );
            }
        });
    }

    async analyze(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('ANALYZE');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to analyze database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to analyze database',
                    errorMessage
                );
            }
        });
    }

    async checkpoint(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('PRAGMA wal_checkpoint(TRUNCATE)');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to checkpoint database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to checkpoint database',
                    errorMessage
                );
            }
        });
    }

    async getMetrics(): Promise<StorageMetrics & {
        cache?: CacheStats;
        memory?: {
            heapUsed: number;
            heapTotal: number;
            rss: number;
        };
    }> {
        return this.withDb(async (db) => {
            try {
                interface TaskStats {
                    total: number;
                    noteCount: number;
                    dependencyCount: number;
                }

                const [taskStats, statusStats, storageStats] = await Promise.all([
                    db.get<TaskStats>(`
                        SELECT 
                            COUNT(*) as total,
                            COUNT(CASE WHEN notes IS NOT NULL THEN 1 END) as noteCount,
                            SUM(CASE 
                                WHEN dependencies IS NOT NULL 
                                AND json_valid(dependencies) 
                                AND json_array_length(dependencies) > 0 
                                THEN json_array_length(dependencies) 
                                ELSE 0 
                            END) as dependencyCount
                        FROM tasks
                    `),
                    db.all(`
                        SELECT status, COUNT(*) as count
                        FROM tasks
                        GROUP BY status
                    `),
                    db.get<Record<string, unknown>>(`
                        SELECT 
                            page_count * page_size as totalSize,
                            page_size,
                            page_count,
                            0 as wal_size
                        FROM pragma_page_count, pragma_page_size LIMIT 1
                    `)
                ]);

                const memUsage = process.memoryUsage();
                const cacheStats = await this.getCacheStats();

                // Convert status stats array to object
                const byStatus = (statusStats as { status: string; count: number }[]).reduce((acc: Record<string, number>, curr) => {
                    acc[curr.status] = curr.count;
                    return acc;
                }, {});

                return {
                    tasks: {
                        total: Number(taskStats?.total || 0),
                        byStatus,
                        noteCount: Number(taskStats?.noteCount || 0),
                        dependencyCount: Number(taskStats?.dependencyCount || 0)
                    },
                    storage: {
                        totalSize: Number(storageStats?.totalSize || 0),
                        pageSize: Number(storageStats?.page_size || 0),
                        pageCount: Number(storageStats?.page_count || 0),
                        walSize: Number(storageStats?.wal_size || 0),
                        cache: {
                            hitRate: cacheStats.hitRate,
                            memoryUsage: cacheStats.memoryUsage,
                            entryCount: this.cache.size
                        }
                    },
                    cache: cacheStats,
                    memory: {
                        heapUsed: memUsage.heapUsed,
                        heapTotal: memUsage.heapTotal,
                        rss: memUsage.rss
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get storage metrics', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to get storage metrics',
                    errorMessage
                );
            }
        });
    }

    private parseJSON<T>(value: string | null | undefined, defaultValue: T): T {
        if (!value) return defaultValue;
        try {
            return JSON.parse(value) as T;
        } catch {
            return defaultValue;
        }
    }

    private rowToTask(row: Record<string, unknown>): Task {
        const metadata = this.parseJSON(String(row.metadata || '{}'), {});
        const now = Date.now();
        
        return {
            // System fields
            path: String(row.path || ''),
            name: String(row.name || ''),
            type: String(row.type || '') as Task['type'],
            status: String(row.status || '') as Task['status'],
            created: Number(row.created_at || now),
            updated: Number(row.updated_at || now),
            version: Number(row.version || 1),
            projectPath: String(row.path || '').split('/')[0],

            // Optional fields
            description: row.description ? String(row.description) : undefined,
            parentPath: row.parent_path ? String(row.parent_path) : undefined,
            notes: this.parseJSON<string[]>(String(row.notes || '[]'), []),
            reasoning: row.reasoning ? String(row.reasoning) : undefined,
            dependencies: this.parseJSON<string[]>(String(row.dependencies || '[]'), []),
            subtasks: this.parseJSON<string[]>(String(row.subtasks || '[]'), []),
            
            // User metadata
            metadata
        };
    }

    /**
     * Clears all tasks from the database and recreates tables
     */
    async clearAllTasks(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                // Drop existing tables
                await db.run('DROP TABLE IF EXISTS tasks');
                
                // Clear cache and indexes
                await this.clearCache();
                
                // Recreate tables
                await this.setupDatabase();
                
                // Vacuum database outside of transaction
                await db.run('VACUUM');
                
                // Analyze the new empty tables
                await db.run('ANALYZE');
                
                // Checkpoint WAL
                await db.run('PRAGMA wal_checkpoint(TRUNCATE)');
                
                this.logger.info('Database reset: tables dropped, recreated, and optimized');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to clear tasks', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to clear tasks',
                    errorMessage
                );
            }
        });
    }

    /**
     * Repairs parent-child relationships
     */
    async repairRelationships(dryRun: boolean = false): Promise<{ fixed: number, issues: string[] }> {
        return this.inTransaction(async () => {
            return this.withDb(async (db) => {
                const issues: string[] = [];
                let fixCount = 0;

                try {
                    // Find tasks with invalid parent paths
                    const orphanedTasks = await db.all<Record<string, unknown>[]>(
                        `SELECT t1.path, t1.parent_path 
                         FROM tasks t1 
                         LEFT JOIN tasks t2 ON t1.parent_path = t2.path 
                         WHERE t1.parent_path IS NOT NULL 
                         AND t2.path IS NULL`
                    );

                    for (const task of orphanedTasks) {
                        issues.push(`Task ${task.path} has invalid parent_path: ${task.parent_path}`);
                        if (!dryRun) {
                            await db.run(
                                'UPDATE tasks SET parent_path = NULL WHERE path = ?',
                                task.path
                            );
                            fixCount++;
                        }
                    }

                    // Find inconsistencies between parent_path and subtasks
                    const rows = await db.all<Record<string, unknown>[]>(
                        'SELECT * FROM tasks WHERE parent_path IS NOT NULL OR subtasks IS NOT NULL'
                    );

                    for (const row of rows) {
                        const task = this.rowToTask(row);
                        const subtaskRefs = new Set(task.subtasks);
                        
                        // Check if all subtasks exist and reference this task as parent
                        if (subtaskRefs.size > 0) {
                            const subtasks = await db.all<Record<string, unknown>[]>(
                                `SELECT * FROM tasks WHERE path IN (${Array(subtaskRefs.size).fill('?').join(',')})`,
                                ...Array.from(subtaskRefs)
                            );

                            for (const subtask of subtasks.map(r => this.rowToTask(r))) {
                                if (subtask.parentPath !== task.path) {
                                    issues.push(`Task ${task.path} lists ${subtask.path} as subtask but parent_path mismatch`);
                                    if (!dryRun) {
                                        subtask.parentPath = task.path;
                                        await this.saveTask(subtask);
                                        fixCount++;
                                    }
                                }
                            }
                        }
                    }

                    return { fixed: fixCount, issues };
                } catch (error) {
                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                    this.logger.error('Failed to repair relationships', { error: errorMessage });
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Failed to repair relationships',
                        errorMessage
                    );
                }
            });
        });
    }

    /**
     * Begins a new transaction
     */
    async beginTransaction(): Promise<void> {
        if (this.transactionDepth > 0) {
            this.transactionDepth++;
            this.logger.debug('Nested transaction started', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('BEGIN IMMEDIATE');
                this.transactionDepth = 1;
                this.logger.debug('Transaction started');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to begin transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to begin transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Commits the current transaction
     */
    async commitTransaction(): Promise<void> {
        if (this.transactionDepth > 1) {
            this.transactionDepth--;
            this.logger.debug('Nested transaction committed', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('COMMIT');
                this.transactionDepth = 0;
                this.logger.debug('Transaction committed');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to commit transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to commit transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Rolls back the current transaction
     */
    async rollbackTransaction(): Promise<void> {
        if (this.transactionDepth > 1) {
            this.transactionDepth--;
            this.logger.debug('Nested transaction rolled back', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('ROLLBACK');
                this.transactionDepth = 0;
                this.logger.debug('Transaction rolled back');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to rollback transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to rollback transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Closes the database connection and cleans up resources
     */
    async close(): Promise<void> {
        try {
            await this.clearCache();
            if (this.db) {
                await this.db.close();
                this.db = null;
                this.logger.info('Database connection closed');
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error('Failed to close database', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to close database',
                errorMessage
            );
        }
    }
}

================
File: src/task/core/batch/common/batch-utils.ts
================
import { Task } from '../../../../types/task.js';

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export interface BatchData<T = unknown> {
  id: string;
  data: T;
  [key: string]: unknown;
}

export interface TaskBatchData extends BatchData<Task> {
  data: Task;
}

export interface BatchResult<T> {
  results: T[];
  errors: Error[];
  metadata?: {
    processingTime: number;
    successCount: number;
    errorCount: number;
  };
}

export class BatchUtils {
  static validateBatch(batch: BatchData[]): ValidationResult {
    const errors: string[] = [];
    
    if (!Array.isArray(batch)) {
      errors.push('Batch must be an array');
      return { valid: false, errors };
    }

    if (batch.length === 0) {
      errors.push('Batch cannot be empty');
      return { valid: false, errors };
    }

    // Validate each item in the batch
    batch.forEach((item, index) => {
      if (!item.id) {
        errors.push(`Item at index ${index} is missing required 'id' field`);
      }
      if (!item.data) {
        errors.push(`Item at index ${index} is missing required 'data' field`);
      }
    });

    return {
      valid: errors.length === 0,
      errors
    };
  }

  static async processBatch<T>(
    batch: BatchData[],
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();
    
    for (const item of batch) {
      try {
        const result = await processor(item);
        results.push(result);
      } catch (error) {
        errors.push(error as Error);
      }
    }

    const endTime = Date.now();
    
    return {
      results,
      errors,
      metadata: {
        processingTime: endTime - startTime,
        successCount: results.length,
        errorCount: errors.length
      }
    };
  }

  static async retryFailedItems<T>(
    failedItems: BatchData[],
    processor: (item: BatchData) => Promise<T>,
    maxRetries: number = 3,
    delayMs: number = 1000
  ): Promise<BatchResult<T>> {
    let currentRetry = 0;
    let itemsToRetry = [...failedItems];
    const results: T[] = [];
    const errors: Error[] = [];

    while (currentRetry < maxRetries && itemsToRetry.length > 0) {
      // Wait before retry
      if (currentRetry > 0) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }

      const retryResult = await this.processBatch(itemsToRetry, processor);
      
      // Add successful results
      results.push(...retryResult.results);
      
      // Update items to retry
      itemsToRetry = itemsToRetry.filter((_, index) => 
        retryResult.errors[index] !== undefined
      );

      if (currentRetry === maxRetries - 1) {
        // On last attempt, add remaining errors
        errors.push(...retryResult.errors);
      }

      currentRetry++;
    }

    return {
      results,
      errors,
      metadata: {
        processingTime: 0, // Not tracking total time for retries
        successCount: results.length,
        errorCount: errors.length
      }
    };
  }

  static splitBatchBySize<T extends BatchData>(
    batch: T[],
    maxBatchSize: number
  ): T[][] {
    if (maxBatchSize <= 0) {
      throw new Error('maxBatchSize must be greater than 0');
    }

    const batches: T[][] = [];
    for (let i = 0; i < batch.length; i += maxBatchSize) {
      batches.push(batch.slice(i, i + maxBatchSize));
    }

    return batches;
  }
}

================
File: src/task/core/batch/base-batch-processor.ts
================
import { Logger } from '../../../logging/index.js';
import { BatchData, BatchResult, ValidationResult } from './common/batch-utils.js';

export interface BatchDependencies {
  validator: any;
  logger: Logger;
  storage: any;
}

export interface BatchOptions {
  maxBatchSize?: number;
  maxRetries?: number;
  retryDelay?: number;
  timeout?: number;
  validateBeforeProcess?: boolean;
  concurrentBatches?: number;
}

export abstract class BaseBatchProcessor<T = unknown> {
  protected readonly logger: Logger;
  protected readonly defaultOptions: Required<BatchOptions> = {
    maxBatchSize: 100,
    maxRetries: 3,
    retryDelay: 1000,
    timeout: 30000,
    validateBeforeProcess: true,
    concurrentBatches: 1
  };

  private activeTimeouts: Set<NodeJS.Timeout> = new Set();
  private activeBatches: Map<string, { 
    startTime: number;
    results: WeakRef<any[]>;
  }> = new Map();
  private isShuttingDown = false;
  private cleanupInterval?: NodeJS.Timeout;
  private readonly CLEANUP_INTERVAL = 300000; // 5 minutes
  private readonly BATCH_RESULT_TTL = 600000; // 10 minutes
  private readonly MEMORY_CHECK_INTERVAL = 60000; // 1 minute
  private readonly HEAP_THRESHOLD = 0.9; // 90% heap usage threshold
  private memoryCheckInterval?: NodeJS.Timeout;

  constructor(
    protected readonly dependencies: BatchDependencies,
    protected readonly options: BatchOptions = {}
  ) {
    this.logger = Logger.getInstance().child({ 
      component: this.constructor.name 
    });
    this.options = { ...this.defaultOptions, ...options };

    // Start monitoring and cleanup
    this.startMemoryMonitoring();
    this.startPeriodicCleanup();
    
    // Log initial memory state
    this.logMemoryUsage('Initialization');
  }

  /**
   * Main execution method that orchestrates the batch processing flow
   */
  async execute(batch: BatchData[]): Promise<BatchResult<T>> {
    if (this.isShuttingDown) {
      throw new Error('Batch processor is shutting down');
    }

    const batchId = `batch-${Date.now()}-${Math.random()}`;
    this.activeBatches.set(batchId, {
      startTime: Date.now(),
      results: new WeakRef([])
    });

    try {
      // Validate batch if enabled
      if (this.options.validateBeforeProcess) {
        const validation = await this.validate(batch);
        if (!validation.valid) {
          throw new Error(`Batch validation failed: ${validation.errors.join(', ')}`);
        }
      }

      // Set up timeout if specified
      let timeoutId: NodeJS.Timeout | undefined;
      const timeoutPromise = new Promise<never>((_, reject) => {
        if (this.options.timeout) {
          timeoutId = setTimeout(() => {
            reject(new Error(`Batch processing timed out after ${this.options.timeout}ms`));
          }, this.options.timeout);
          this.activeTimeouts.add(timeoutId);
        }
      });

      // Process the batch with timeout
      const processResult = await Promise.race([
        this.process(batch),
        timeoutPromise
      ]);

      // Clear timeout if it was set
      if (timeoutId) {
        clearTimeout(timeoutId);
        this.activeTimeouts.delete(timeoutId);
      }

      // Store results with WeakRef for memory management
      const batchInfo = this.activeBatches.get(batchId);
      if (batchInfo) {
        batchInfo.results = new WeakRef(processResult.results);
      }

      // Log metrics
      this.logMetrics(processResult);

      return processResult;
    } catch (error) {
      this.logger.error('Batch processing failed', { error });
      throw error;
    } finally {
      this.activeBatches.delete(batchId);
    }
  }

  /**
   * Process items in batches with configurable concurrency
   */
  public async processInBatches(
    items: BatchData[],
    batchSize: number,
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    const batches = this.createBatches(items, batchSize);
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    try {
      const concurrentBatches = this.options.concurrentBatches || 1;
      for (let i = 0; i < batches.length; i += concurrentBatches) {
        const batchPromises = batches
          .slice(i, i + concurrentBatches)
          .map(batch => this.processBatch(batch, processor));

        const batchResults = await Promise.all(batchPromises);
        
        for (const result of batchResults) {
          results.push(...result.results);
          errors.push(...result.errors);
        }
      }

      const endTime = Date.now();
      return {
        results,
        errors,
        metadata: {
          processingTime: endTime - startTime,
          successCount: results.length,
          errorCount: errors.length
        }
      };
    } catch (error) {
      this.logger.error('Batch processing failed', { error });
      throw error;
    }
  }

  /**
   * Abstract method for batch validation
   * Must be implemented by concrete classes
   */
  protected abstract validate(batch: BatchData[]): Promise<ValidationResult>;

  /**
   * Abstract method for batch processing
   * Must be implemented by concrete classes
   */
  protected abstract process(batch: BatchData[]): Promise<BatchResult<T>>;

  /**
   * Helper method to split items into batches
   */
  protected createBatches(items: BatchData[], batchSize: number): BatchData[][] {
    const batches: BatchData[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * Helper method to process a single batch
   */
  protected async processBatch(
    batch: BatchData[],
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    if (this.isShuttingDown) {
      throw new Error('Batch processor is shutting down');
    }

    const batchId = `sub-batch-${Date.now()}-${Math.random()}`;
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    // Track this sub-batch
    this.activeBatches.set(batchId, {
      startTime,
      results: new WeakRef([])
    });

    try {
      for (const item of batch) {
        try {
          const result = await this.withRetry(
            () => processor(item),
            `Processing item ${item.id}`
          );
          results.push(result);
        } catch (error) {
          errors.push(error as Error);
          this.logger.error('Failed to process batch item', {
            error,
            itemId: item.id
          });
        }
      }

      const endTime = Date.now();
      const batchResult = {
        results,
        errors,
        metadata: {
          processingTime: endTime - startTime,
          successCount: results.length,
          errorCount: errors.length,
          batchId
        }
      };

      // Update batch results reference
      const batchInfo = this.activeBatches.get(batchId);
      if (batchInfo) {
        batchInfo.results = new WeakRef(results);
      }

      return batchResult;
    } finally {
      // Clean up batch tracking after processing
      this.activeBatches.delete(batchId);
    }
  }

  /**
   * Helper method to handle retries
   */
  protected async withRetry<R>(
    operation: () => Promise<R>,
    context: string
  ): Promise<R> {
    const maxRetries = this.options.maxRetries || this.defaultOptions.maxRetries;
    const delay = this.options.retryDelay || this.defaultOptions.retryDelay;
    let lastError: Error | undefined;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        this.logger.warn(`${context} failed, attempt ${attempt}/${maxRetries}`, { 
          error,
          attempt,
          maxRetries 
        });

        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  /**
   * Helper method to log batch processing metrics
   */
  protected logMetrics(result: BatchResult<T>): void {
    this.logger.info('Batch processing completed', {
      processingTime: result.metadata?.processingTime,
      successCount: result.metadata?.successCount,
      errorCount: result.metadata?.errorCount,
      totalItems: result.results.length + result.errors.length
    });
  }

  /**
   * Cleanup resources and prepare for shutdown
   */
  private startMemoryMonitoring(): void {
    // Monitor memory usage periodically
    this.memoryCheckInterval = setInterval(() => {
      const memoryUsage = process.memoryUsage();
      const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;

      this.logger.debug('Memory usage', {
        heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
        heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
        rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
        external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
        arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`
      });

      if (heapUsed > this.HEAP_THRESHOLD) {
        this.logger.warn('High memory usage detected', {
          heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
          activeTimeouts: this.activeTimeouts.size,
          activeBatches: this.activeBatches.size
        });
        
        // Force cleanup when memory pressure is high
        this.cleanupExpiredBatches(true);
        
        // Force GC if available
        if (global.gc) {
          this.logger.info('Forcing garbage collection');
          global.gc();
        }
      }
    }, this.MEMORY_CHECK_INTERVAL);

    // Ensure cleanup on process exit
    process.once('beforeExit', () => {
      if (this.memoryCheckInterval) {
        clearInterval(this.memoryCheckInterval);
        this.memoryCheckInterval = undefined;
      }
    });
  }

  private startPeriodicCleanup(): void {
    // More frequent cleanup interval
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredBatches();
    }, this.CLEANUP_INTERVAL);

    // Ensure cleanup interval is cleared on process exit
    process.once('beforeExit', () => {
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = undefined;
      }
    });
  }

  private cleanupExpiredBatches(force: boolean = false): void {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [batchId, batchInfo] of this.activeBatches.entries()) {
      // Clean up batches that have expired or force cleanup
      if (force || now - batchInfo.startTime > this.BATCH_RESULT_TTL) {
        this.activeBatches.delete(batchId);
        cleanedCount++;
        continue;
      }

      // Clean up batches whose results have been garbage collected
      const results = batchInfo.results.deref();
      if (!results) {
        this.activeBatches.delete(batchId);
        cleanedCount++;
      }
    }

    // Always log cleanup metrics
    this.logger.debug('Batch cleanup completed', {
      cleanedCount,
      remainingBatches: this.activeBatches.size,
      forced: force,
      memoryUsage: this.getMemoryMetrics()
    });
  }

  private getMemoryMetrics(): Record<string, string> {
    const memoryUsage = process.memoryUsage();
    return {
      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
      external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
      arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
      heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
    };
  }

  private logMemoryUsage(context: string): void {
    this.logger.info(`Memory usage - ${context}`, this.getMemoryMetrics());
  }

  async cleanup(): Promise<void> {
    this.isShuttingDown = true;
    this.logMemoryUsage('Cleanup start');

    // Stop all monitoring and cleanup intervals
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = undefined;
    }

    if (this.memoryCheckInterval) {
      clearInterval(this.memoryCheckInterval);
      this.memoryCheckInterval = undefined;
    }

    // Clear all timeouts
    for (const timeout of this.activeTimeouts) {
      clearTimeout(timeout);
    }
    this.activeTimeouts.clear();

    // Wait for active batches to complete with timeout
    if (this.activeBatches.size > 0) {
      this.logger.info('Waiting for active batches to complete', {
        count: this.activeBatches.size
      });

      const timeout = 5000;
      const startTime = Date.now();
      
      while (this.activeBatches.size > 0 && Date.now() - startTime < timeout) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      if (this.activeBatches.size > 0) {
        this.logger.warn('Some batches did not complete before timeout', {
          remainingBatches: this.activeBatches.size
        });
      }
    }

    // Force final cleanup
    this.cleanupExpiredBatches(true);
    this.activeBatches.clear();
    
    // Force garbage collection
    if (global.gc) {
      this.logger.info('Forcing final garbage collection');
      global.gc();
    }

    this.logMemoryUsage('Cleanup end');
    this.logger.info('Batch processor cleanup completed', {
      finalMetrics: {
        activeTimeouts: this.activeTimeouts.size,
        activeBatches: this.activeBatches.size,
        ...this.getMemoryMetrics()
      }
    });
  }
}

================
File: src/task/core/batch/dependency-aware-batch-processor.ts
================
import { Task, TaskStatus } from '../../../types/task.js';
import { BatchData, BatchResult, ValidationResult } from './common/batch-utils.js';
import { BaseBatchProcessor, BatchDependencies, BatchOptions } from './base-batch-processor.js';
import { detectDependencyCycle } from '../../validation/index.js';

interface TaskBatchData extends BatchData {
  task: Task;
  dependencies: string[];
}

export class DependencyAwareBatchProcessor extends BaseBatchProcessor {
  private dependencyGraph: Record<string, Set<string>> = {};

  constructor(
    dependencies: BatchDependencies,
    options: BatchOptions = {}
  ) {
    super(dependencies, {
      ...options,
      validateBeforeProcess: true // Always validate dependencies
    });
  }

  protected async validate(batch: BatchData[]): Promise<ValidationResult> {
    const errors: string[] = [];
    const tasks = batch as TaskBatchData[];

    try {
      // Clear any stale cache entries before validation
      if ('clearCache' in this.dependencies.storage) {
        await (this.dependencies.storage as any).clearCache();
      }

      // Build dependency graph
      this.buildDependencyGraph(tasks);

      // First pass: validate task existence and basic structure
      for (const task of tasks) {
        const existingTask = await this.dependencies.storage.getTask(task.task.path);
        if (!existingTask) {
          errors.push(`Task ${task.task.path} not found`);
          continue;
        }

        // Validate task matches stored version
        if (existingTask.metadata.version !== task.task.metadata.version) {
          errors.push(`Task ${task.task.path} has been modified by another process`);
          continue;
        }
      }

      // Check for circular dependencies using shared validation
      for (const taskData of tasks) {
        try {
          const hasCycle = await detectDependencyCycle(
            taskData.task,
            taskData.dependencies,
            this.dependencies.storage.getTask.bind(this.dependencies.storage)
          );
          if (hasCycle) {
            errors.push(`Circular dependency detected for task ${taskData.task.path}`);
          }
        } catch (error) {
          if (error instanceof Error) {
            errors.push(error.message);
          } else {
            errors.push('Unknown error checking dependencies');
          }
        }
      }

      // Validate each task's dependencies exist
      for (const task of tasks) {
        const missingDeps = await this.findMissingDependencies(task);
        if (missingDeps.length > 0) {
          errors.push(`Task ${task.id} has missing dependencies: ${missingDeps.join(', ')}`);
        }
      }

      // Validate dependency status
      for (const task of tasks) {
        const blockedDeps = await this.findBlockedDependencies(task);
        if (blockedDeps.length > 0) {
          errors.push(
            `Task ${task.id} has blocked dependencies: ${blockedDeps.join(', ')}`
          );
        }
      }

      return {
        valid: errors.length === 0,
        errors
      };
    } catch (error) {
      this.logger.error('Dependency validation failed', { error });
      errors.push(`Validation error: ${(error as Error).message}`);
      return { valid: false, errors };
    }
  }

  protected async process<T>(batch: BatchData[]): Promise<BatchResult<T>> {
    const tasks = batch as TaskBatchData[];
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    try {
      // Process tasks in dependency order
      const processingOrder = this.getProcessingOrder();
      
      for (const taskId of processingOrder) {
        const task = tasks.find(t => t.id === taskId);
        if (!task) continue;

        try {
          // Process the task
          const result = await this.withRetry(
            async () => this.processTask(task),
            `Processing task ${task.id}`
          );
          
          results.push(result as T);
          
          this.logger.debug('Task processed successfully', {
            taskId: task.id,
            dependencies: task.dependencies
          });
        } catch (error) {
          this.logger.error('Failed to process task', {
            error,
            taskId: task.id
          });
          errors.push(error as Error);
        }
      }

      const endTime = Date.now();
      const result: BatchResult<T> = {
        results,
        errors,
        metadata: {
          processingTime: endTime - startTime,
          successCount: results.length,
          errorCount: errors.length
        }
      };

      this.logMetrics(result);
      return result;
    } catch (error) {
      this.logger.error('Batch processing failed', { error });
      throw error;
    } finally {
      // Clear dependency graph
      this.dependencyGraph = {};
    }
  }

  private buildDependencyGraph(tasks: TaskBatchData[]): void {
    this.dependencyGraph = {};
    
    for (const task of tasks) {
      if (!this.dependencyGraph[task.id]) {
        this.dependencyGraph[task.id] = new Set();
      }
      
      for (const dep of task.dependencies) {
        this.dependencyGraph[task.id].add(dep);
      }
    }
  }

  private async findMissingDependencies(task: TaskBatchData): Promise<string[]> {
    const missing: string[] = [];
    
    for (const depId of task.dependencies) {
      const depTask = await this.dependencies.storage.getTask(depId);
      if (!depTask) {
        missing.push(depId);
      }
    }
    
    return missing;
  }

  private async findBlockedDependencies(task: TaskBatchData): Promise<string[]> {
    const blocked: string[] = [];
    
    for (const depId of task.dependencies) {
      const depTask = await this.dependencies.storage.getTask(depId);
      if (depTask && depTask.status === TaskStatus.BLOCKED) {
        blocked.push(depId);
      }
    }
    
    return blocked;
  }

  private getProcessingOrder(): string[] {
    const visited = new Set<string>();
    const order: string[] = [];

    const visit = (taskId: string) => {
      if (visited.has(taskId)) return;
      visited.add(taskId);

      const dependencies = this.dependencyGraph[taskId] || new Set();
      for (const depId of dependencies) {
        visit(depId);
      }

      order.push(taskId);
    };

    for (const taskId of Object.keys(this.dependencyGraph)) {
      visit(taskId);
    }

    return order;
  }

  private async processTask(task: TaskBatchData): Promise<Task> {
    try {
      // Re-fetch task to ensure we have latest state
      const currentTask = await this.dependencies.storage.getTask(task.task.path);
      if (!currentTask) {
        throw new Error(`Task ${task.task.path} not found during processing`);
      }

      // Check dependencies are complete
      const incompleteDeps: string[] = [];
      const failedDeps: string[] = [];
      
      for (const depId of task.dependencies) {
        const depTask = await this.dependencies.storage.getTask(depId);
        if (!depTask) {
          incompleteDeps.push(depId);
        } else if (depTask.status === TaskStatus.FAILED) {
          failedDeps.push(depId);
        } else if (depTask.status !== TaskStatus.COMPLETED) {
          incompleteDeps.push(depId);
        }
      }

      // Handle dependency issues
      if (failedDeps.length > 0) {
        // If any dependencies failed, mark this task as failed
        return await this.dependencies.storage.updateTask(
          task.task.path,
          {
            status: TaskStatus.FAILED,
            metadata: {
              ...currentTask.metadata,
              failureReason: `Dependencies failed: ${failedDeps.join(', ')}`,
              updated: Date.now(),
              version: currentTask.metadata.version + 1
            }
          }
        );
      }

      if (incompleteDeps.length > 0) {
        // If dependencies are incomplete, mark as blocked
        return await this.dependencies.storage.updateTask(
          task.task.path,
          {
            status: TaskStatus.BLOCKED,
            metadata: {
              ...currentTask.metadata,
              blockedBy: incompleteDeps,
              updated: Date.now(),
              version: currentTask.metadata.version + 1
            }
          }
        );
      }

      // All dependencies complete, process the task
      const processedTask = await this.dependencies.storage.updateTask(
        task.task.path,
        {
          status: TaskStatus.COMPLETED,
          metadata: {
            ...currentTask.metadata,
            completedAt: Date.now(),
            updated: Date.now(),
            version: currentTask.metadata.version + 1
          }
        }
      );

      return processedTask;
    } catch (error) {
      this.logger.error('Failed to process task', {
        error,
        taskPath: task.task.path,
        dependencies: task.dependencies
      });
      throw error;
    }
  }
}

================
File: src/task/core/batch/generic-batch-processor.ts
================
import { BatchData, BatchResult, ValidationResult } from './common/batch-utils.js';
import { BaseBatchProcessor, BatchDependencies, BatchOptions } from './base-batch-processor.js';

export interface GenericBatchConfig extends BatchOptions {
  validateItems?: boolean;
  stopOnError?: boolean;
  itemTimeout?: number;
}

export class GenericBatchProcessor<T> extends BaseBatchProcessor<T> {
  private readonly config: Required<GenericBatchConfig>;
  private readonly defaultConfig: Required<GenericBatchConfig> = {
    ...this.defaultOptions,
    validateItems: true,
    stopOnError: false,
    itemTimeout: 5000
  };

  constructor(
    dependencies: BatchDependencies,
    config: GenericBatchConfig = {}
  ) {
    super(dependencies, config);
    this.config = { ...this.defaultConfig, ...config };
  }

  protected async validate(batch: BatchData[]): Promise<ValidationResult> {
    const errors: string[] = [];

    if (!Array.isArray(batch)) {
      errors.push('Batch must be an array');
      return { valid: false, errors };
    }

    if (batch.length === 0) {
      errors.push('Batch cannot be empty');
      return { valid: false, errors };
    }

    if (this.config.validateItems) {
      for (const [index, item] of batch.entries()) {
        if (!item.id) {
          errors.push(`Item at index ${index} is missing required 'id' field`);
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  protected async process(batch: BatchData[]): Promise<BatchResult<T>> {
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    for (const item of batch) {
      try {
        const result = await this.processWithTimeout(
          item,
          this.config.itemTimeout
        );
        results.push(result);

        this.logger.debug('Processed batch item', {
          itemId: item.id,
          duration: Date.now() - startTime
        });
      } catch (error) {
        this.logger.error('Failed to process batch item', {
          error,
          itemId: item.id
        });
        errors.push(error as Error);

        if (this.config.stopOnError) {
          this.logger.warn('Stopping batch processing due to error', {
            itemId: item.id,
            remainingItems: batch.length - results.length - 1
          });
          break;
        }
      }
    }

    const endTime = Date.now();
    const result: BatchResult<T> = {
      results,
      errors,
      metadata: {
        processingTime: endTime - startTime,
        successCount: results.length,
        errorCount: errors.length
      }
    };

    this.logMetrics(result);
    return result;
  }

  private async processWithTimeout(
    item: BatchData,
    timeout: number
  ): Promise<T> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Processing timed out for item ${item.id}`));
      }, timeout);

      this.processItem(item)
        .then(result => {
          clearTimeout(timeoutId);
          resolve(result);
        })
        .catch(error => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  }

  private async processItem(item: BatchData): Promise<T> {
    // This is where you would implement the actual processing logic
    // For now, we'll just return the item as is
    return item as unknown as T;
  }

  /**
   * Helper method to categorize errors for better error handling
   */
}

================
File: src/task/core/batch/index.ts
================
export * from './base-batch-processor.js';
export * from './dependency-aware-batch-processor.js';
export * from './generic-batch-processor.js';
export * from './task-status-batch-processor.js';

================
File: src/task/core/batch/status-update-batch.ts
================
import { TaskStatus, UpdateTaskInput } from '../../../types/task.js';
import { Logger } from '../../../logging/index.js';
import { TransactionManager } from '../transactions/transaction-manager.js';
import { TaskStorage } from '../../../types/storage.js';
import { ErrorCodes, createError } from '../../../errors/index.js';

export class StatusUpdateBatch {
    private readonly logger: Logger;
    private readonly transactionManager: TransactionManager;
    private readonly updates: Map<string, UpdateTaskInput> = new Map();
    private readonly processedTasks: Set<string> = new Set();

    constructor(
        private readonly storage: TaskStorage
    ) {
        this.logger = Logger.getInstance().child({ component: 'StatusUpdateBatch' });
        this.transactionManager = TransactionManager.getInstance(storage);
    }

    /**
     * Add a task status update to the batch
     */
    addUpdate(path: string, status: TaskStatus, metadata?: Record<string, any>): void {
        if (this.processedTasks.has(path)) {
            return; // Prevent circular updates
        }

        this.updates.set(path, {
            status,
            metadata: {
                ...metadata,
                statusUpdatedAt: Date.now()
            }
        });
        this.processedTasks.add(path);
    }

    /**
     * Execute all batched updates in a single transaction
     */
    async execute(): Promise<void> {
        if (this.updates.size === 0) {
            return;
        }

        const transaction = await this.transactionManager.begin({
            timeout: 30000, // 30 second timeout for batch operations
            requireLock: true
        });

        try {
            // Process updates in dependency order
            const orderedUpdates = await this.orderUpdatesByDependencies();

            for (const [path, update] of orderedUpdates) {
                const task = await this.storage.getTask(path);
                if (!task) {
                    this.logger.warn('Task not found during batch update', { path });
                    continue;
                }

                await this.storage.updateTask(path, update);
            }

            await this.transactionManager.commit(transaction);
            
            this.logger.info('Status update batch completed', {
                updateCount: this.updates.size,
                paths: Array.from(this.updates.keys())
            });
        } catch (error) {
            this.logger.error('Failed to execute status update batch', { error });
            await this.transactionManager.rollback(transaction);
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to execute status update batch',
                String(error)
            );
        } finally {
            this.updates.clear();
            this.processedTasks.clear();
        }
    }

    /**
     * Order updates based on task dependencies to prevent conflicts
     */
    private async orderUpdatesByDependencies(): Promise<Map<string, UpdateTaskInput>> {
        const ordered = new Map<string, UpdateTaskInput>();
        const visited = new Set<string>();
        const visiting = new Set<string>();

        const visit = async (path: string) => {
            if (visited.has(path)) return;
            if (visiting.has(path)) {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Circular dependency detected: ${path}`
                );
            }

            visiting.add(path);

            const task = await this.storage.getTask(path);
            if (task) {
                // Visit dependencies first
                for (const depPath of task.dependencies) {
                    if (this.updates.has(depPath)) {
                        await visit(depPath);
                    }
                }

                // Then add this task's update
                const update = this.updates.get(path);
                if (update) {
                    ordered.set(path, update);
                }
            }

            visiting.delete(path);
            visited.add(path);
        };

        // Visit all tasks in the update set
        for (const path of this.updates.keys()) {
            await visit(path);
        }

        return ordered;
    }

    /**
     * Get number of pending updates
     */
    get size(): number {
        return this.updates.size;
    }
}

================
File: src/task/core/batch/task-status-batch-processor.ts
================
import { Task, TaskStatus } from '../../../types/task.js';
import { BatchData, BatchResult, ValidationResult, TaskBatchData } from './common/batch-utils.js';
import { BaseBatchProcessor, BatchDependencies, BatchOptions } from './base-batch-processor.js';
import { validateTaskStatusTransition } from '../../validation/index.js';

export interface TaskStatusBatchConfig extends BatchOptions {
  updateDependents?: boolean;
}

export class TaskStatusBatchProcessor extends BaseBatchProcessor<Task> {
  private readonly config: Required<TaskStatusBatchConfig> & Required<BatchOptions>;

  constructor(
    dependencies: BatchDependencies,
    config: TaskStatusBatchConfig = {}
  ) {
    super(dependencies, config);
    this.config = Object.assign(
      {},
      this.defaultOptions,
      {
        updateDependents: true
      },
      config
    ) as Required<TaskStatusBatchConfig> & Required<BatchOptions>;
  }

  protected async validate(batch: BatchData[]): Promise<ValidationResult> {
    const errors: string[] = [];
    const tasks = batch.map(item => (item as TaskBatchData).data);

    if (!Array.isArray(batch)) {
      errors.push('Batch must be an array');
      return { valid: false, errors };
    }

    if (batch.length === 0) {
      errors.push('Batch cannot be empty');
      return { valid: false, errors };
    }

    // Clear any stale cache entries before validation
    if ('clearCache' in this.dependencies.storage) {
      await (this.dependencies.storage as any).clearCache();
    }

    // First pass: validate all status transitions
    for (const task of tasks) {
      const newStatus = task.metadata?.newStatus as TaskStatus;

      if (!newStatus) {
        errors.push(`Task ${task.path} is missing new status in metadata`);
        continue;
      }

      try {
        // Use shared validation utility for status transitions
        await validateTaskStatusTransition(task, newStatus, this.dependencies.storage.getTask.bind(this.dependencies.storage));
      } catch (error) {
        if (error instanceof Error) {
          errors.push(error.message);
        } else {
          errors.push('Unknown validation error occurred');
        }
      }
    }

    // Second pass: validate parent-child status consistency
    for (const task of tasks) {
      const newStatus = task.metadata?.newStatus as TaskStatus;
      if (!newStatus || !task.parentPath) continue;

      const parent = await this.dependencies.storage.getTask(task.parentPath);
      if (!parent) continue;

      const siblings = await this.dependencies.storage.getSubtasks(parent.path);
      const siblingStatuses = new Set(siblings.map((t: Task) => t.status));

      // Check for invalid status combinations
      if (newStatus === TaskStatus.COMPLETED && 
          siblingStatuses.has(TaskStatus.BLOCKED)) {
        errors.push(`Cannot complete task ${task.path} while sibling tasks are blocked`);
      }

      if (newStatus === TaskStatus.IN_PROGRESS && 
          siblingStatuses.has(TaskStatus.FAILED)) {
        errors.push(`Cannot start task ${task.path} while sibling tasks have failed`);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  protected async process(batch: BatchData[]): Promise<BatchResult<Task>> {
    const tasks = batch.map(item => (item as TaskBatchData).data);
    const results: Task[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    for (const task of tasks) {
      try {
        const newStatus = task.metadata?.newStatus as TaskStatus;
        const updatedTask = await this.updateTaskStatus(task, newStatus);
        results.push(updatedTask);

        if (this.config.updateDependents) {
          await this.updateDependentTasks(updatedTask);
        }
      } catch (error) {
        errors.push(error as Error);
        this.logger.error('Failed to update task status', {
          error,
          taskPath: task.path,
          newStatus: task.metadata?.newStatus
        });
      }
    }

    const endTime = Date.now();
    const result: BatchResult<Task> = {
      results,
      errors,
      metadata: {
        processingTime: endTime - startTime,
        successCount: results.length,
        errorCount: errors.length
      }
    };

    this.logMetrics(result);
    return result;
  }

  private async updateTaskStatus(task: Task, newStatus: TaskStatus): Promise<Task> {
    return await this.dependencies.storage.updateTask(task.path, {
      status: newStatus,
      metadata: {
        ...task.metadata,
        statusUpdatedAt: Date.now(),
        previousStatus: task.status
      }
    });
  }

  private async updateDependentTasks(task: Task): Promise<void> {
    const dependentTasks = await this.dependencies.storage.getDependentTasks(task.path);

    for (const depTask of dependentTasks) {
      if (task.status === TaskStatus.BLOCKED || task.status === TaskStatus.FAILED) {
        await this.updateTaskStatus(depTask, TaskStatus.BLOCKED);
      } else if (task.status === TaskStatus.COMPLETED) {
        const allDepsCompleted = await this.areAllDependenciesCompleted(depTask);
        if (allDepsCompleted && depTask.status === TaskStatus.BLOCKED) {
          await this.updateTaskStatus(depTask, TaskStatus.PENDING);
        }
      }
    }
  }

  private async areAllDependenciesCompleted(task: Task): Promise<boolean> {
    for (const depPath of task.dependencies) {
      const depTask = await this.dependencies.storage.getTask(depPath);
      if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
        return false;
      }
    }
    return true;
  }
}

================
File: src/task/core/cache/cache-coordinator.ts
================
import { Logger } from '../../../logging/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { CacheManager } from './cache-manager.js';
import { CacheMetrics } from './cache-metrics.js';
import { CacheCoordinatorOptions } from '../../../types/cache.js';

export class CacheCoordinator {
  private readonly logger: Logger;
  private readonly metrics: CacheMetrics;
  private readonly eventManager: EventManager;
  private monitorInterval?: NodeJS.Timeout;
  private readonly options: Required<CacheCoordinatorOptions>;

  constructor(
    private readonly cacheManager: CacheManager,
    options: CacheCoordinatorOptions = {}
  ) {
    this.logger = Logger.getInstance().child({ component: 'CacheCoordinator' });
    this.metrics = new CacheMetrics();
    this.eventManager = EventManager.getInstance();

    // Set default options
    this.options = {
      maxMemory: options.maxMemory || 512 * 1024 * 1024, // 512MB
      checkInterval: options.checkInterval || 60000, // 1 minute
      pressureThreshold: options.pressureThreshold || 0.8, // 80%
      debugMode: options.debugMode || process.env.NODE_ENV === 'development'
    };

    this.setupEventListeners();
    this.startMemoryMonitoring();
  }

  private setupEventListeners(): void {
    // Listen for task updates to invalidate cache
    this.eventManager.on(EventTypes.TASK_UPDATED, () => {
      this.invalidateTaskCache();
    });

    // Listen for memory pressure to reduce cache size
    this.eventManager.on(EventTypes.MEMORY_PRESSURE, () => {
      this.reduceCacheSize();
    });

    // Listen for cache-related events to update metrics
    this.eventManager.on(EventTypes.CACHE_INVALIDATED, () => {
      this.metrics.recordInvalidation();
    });

    this.eventManager.on(EventTypes.CACHE_CLEARED, () => {
      this.metrics.recordClear();
    });
  }

  private startMemoryMonitoring(): void {
    this.monitorInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, this.options.checkInterval);
  }

  private async checkMemoryUsage(): Promise<void> {
    const memUsage = process.memoryUsage();
    const heapUsed = memUsage.heapUsed;
    const usage = heapUsed / this.options.maxMemory;

    this.metrics.updateMemoryUsage(heapUsed);

    if (usage >= this.options.pressureThreshold) {
      this.logger.warn('Memory pressure detected', {
        heapUsed: `${Math.round(heapUsed / 1024 / 1024)}MB`,
        maxMemory: `${Math.round(this.options.maxMemory / 1024 / 1024)}MB`,
        usage: `${Math.round(usage * 100)}%`,
        threshold: `${Math.round(this.options.pressureThreshold * 100)}%`
      });

      // Emit memory pressure event
      this.eventManager.emit({
        type: EventTypes.MEMORY_PRESSURE,
        timestamp: Date.now(),
        metadata: {
          memoryUsage: {
            heapUsed,
            heapTotal: memUsage.heapTotal,
            rss: memUsage.rss
          },
          threshold: this.options.pressureThreshold
        }
      });

      await this.reduceCacheSize();
    }

    if (this.options.debugMode) {
      this.logger.debug('Memory usage stats', {
        heapUsed: `${Math.round(heapUsed / 1024 / 1024)}MB`,
        usage: `${Math.round(usage * 100)}%`,
        cacheSize: this.metrics.getCacheSize(),
        hitRatio: this.metrics.getHitRatio()
      });
    }
  }

  private async invalidateTaskCache(): Promise<void> {
    try {
      const before = this.metrics.getCacheSize();
      await this.cacheManager.invalidate();
      const after = this.metrics.getCacheSize();

      this.eventManager.emit({
        type: EventTypes.CACHE_INVALIDATED,
        timestamp: Date.now(),
        metadata: {
          reason: 'task_update',
          sizeBefore: before,
          sizeAfter: after,
          reduction: before - after
        }
      });

      if (this.options.debugMode) {
        this.logger.debug('Cache invalidated', {
          sizeBefore: before,
          sizeAfter: after,
          reduction: before - after
        });
      }
    } catch (error) {
      this.logger.error('Failed to invalidate cache', { error });
      throw error;
    }
  }

  private async reduceCacheSize(): Promise<void> {
    try {
      const before = this.metrics.getCacheSize();
      await this.cacheManager.reduce();
      const after = this.metrics.getCacheSize();

      this.eventManager.emit({
        type: EventTypes.CACHE_CLEARED,
        timestamp: Date.now(),
        metadata: {
          reason: 'memory_pressure',
          sizeBefore: before,
          sizeAfter: after,
          reduction: before - after
        }
      });

      this.logger.info('Cache size reduced', {
        before,
        after,
        reduction: before - after
      });
    } catch (error) {
      this.logger.error('Failed to reduce cache size', { error });
      throw error;
    }
  }

  async clearCache(): Promise<void> {
    try {
      const before = this.metrics.getCacheSize();
      await this.cacheManager.clear();
      
      this.eventManager.emit({
        type: EventTypes.CACHE_CLEARED,
        timestamp: Date.now(),
        metadata: {
          reason: 'manual_clear',
          sizeBefore: before,
          sizeAfter: 0,
          reduction: before
        }
      });

      this.logger.info('Cache cleared');
    } catch (error) {
      this.logger.error('Failed to clear cache', { error });
      throw error;
    }
  }

  getMetrics(): Record<string, unknown> {
    return {
      ...this.metrics.getMetrics(),
      maxMemory: this.options.maxMemory,
      pressureThreshold: this.options.pressureThreshold,
      checkInterval: this.options.checkInterval
    };
  }

  stop(): void {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = undefined;
    }
  }
}

================
File: src/task/core/cache/cache-manager.ts
================
import { Logger } from '../../../logging/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { CacheMetrics } from './cache-metrics.js';
import { CacheOptions, CacheEntry } from '../../../types/cache.js';

export class CacheManager {
  private readonly cache: Map<string, CacheEntry<any>>;
  private readonly logger: Logger;
  private readonly metrics: CacheMetrics;
  private readonly eventManager: EventManager;
  private cleanupInterval?: NodeJS.Timeout;
  private readonly options: Required<CacheOptions>;

  constructor(options: CacheOptions = {}) {
    this.cache = new Map();
    this.logger = Logger.getInstance().child({ component: 'CacheManager' });
    this.metrics = new CacheMetrics();
    this.eventManager = EventManager.getInstance();

    // Set default options
    this.options = {
      maxSize: options.maxSize || 1000,
      ttl: options.ttl || 5 * 60 * 1000, // 5 minutes
      cleanupInterval: options.cleanupInterval || 60 * 1000, // 1 minute
      baseTTL: options.baseTTL || 60 * 1000, // 1 minute
      maxTTL: options.maxTTL || 5 * 60 * 1000 // 5 minutes
    };

    this.startCleanupInterval();
  }

  async get<T>(key: string): Promise<T | undefined> {
    const entry = this.cache.get(key);

    if (!entry) {
      this.metrics.recordMiss();
      return undefined;
    }

    // Check if entry has expired
    if (Date.now() > entry.expires) {
      this.cache.delete(key);
      this.metrics.recordMiss();
      this.updateMetrics();
      return undefined;
    }

    // Update last accessed time
    entry.lastAccessed = Date.now();
    this.metrics.recordHit();
    return entry.value;
  }

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    // Check cache size limit
    if (this.cache.size >= this.options.maxSize) {
      await this.evictLeastRecentlyUsed();
    }

    const expires = Date.now() + (ttl || this.options.ttl);
    
    this.cache.set(key, {
      value,
      expires,
      lastAccessed: Date.now()
    });

    this.updateMetrics();
  }

  async invalidate(pattern?: string): Promise<void> {
    if (pattern) {
      const regex = new RegExp(pattern);
      for (const key of this.cache.keys()) {
        if (regex.test(key)) {
          this.cache.delete(key);
        }
      }
    } else {
      this.cache.clear();
    }

    this.metrics.recordInvalidation();
    this.updateMetrics();

    this.eventManager.emit({
      type: EventTypes.CACHE_INVALIDATED,
      timestamp: Date.now(),
      batchId: `cache_invalidate_${Date.now()}`,
      metadata: {
        pattern,
        entriesRemaining: this.cache.size
      }
    });
  }

  async reduce(percentage: number = 0.5): Promise<void> {
    const targetSize = Math.floor(this.cache.size * (1 - percentage));
    await this.evictEntries(this.cache.size - targetSize);
    this.updateMetrics();
  }

  async delete(key: string): Promise<void> {
    this.cache.delete(key);
    this.updateMetrics();
  }

  async clear(): Promise<void> {
    this.cache.clear();
    this.metrics.recordClear();
    this.updateMetrics();

    this.eventManager.emit({
      type: EventTypes.CACHE_CLEARED,
      timestamp: Date.now(),
      batchId: `cache_clear_${Date.now()}`,
      metadata: {
        reason: 'manual_clear'
      }
    });
  }

  getMetrics(): Record<string, unknown> {
    return this.metrics.getMetrics();
  }

  private startCleanupInterval(): void {
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, this.options.cleanupInterval);
  }

  private async cleanup(): Promise<void> {
    const now = Date.now();
    let removed = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expires) {
        this.cache.delete(key);
        removed++;
      }
    }

    if (removed > 0) {
      this.updateMetrics();
      this.logger.debug('Cache cleanup completed', {
        entriesRemoved: removed,
        remainingEntries: this.cache.size
      });
    }
  }

  private async evictLeastRecentlyUsed(): Promise<void> {
    let oldest: { key: string; lastAccessed: number } | null = null;

    for (const [key, entry] of this.cache.entries()) {
      if (!oldest || entry.lastAccessed < oldest.lastAccessed) {
        oldest = { key, lastAccessed: entry.lastAccessed };
      }
    }

    if (oldest) {
      this.cache.delete(oldest.key);
      this.updateMetrics();
    }
  }

  private async evictEntries(count: number): Promise<void> {
    // Sort entries by last accessed time
    const entries = Array.from(this.cache.entries())
      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);

    // Remove oldest entries
    for (let i = 0; i < Math.min(count, entries.length); i++) {
      this.cache.delete(entries[i][0]);
    }
  }

  private updateMetrics(): void {
    this.metrics.updateSize(this.cache.size);
  }

  stop(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = undefined;
    }
  }
}

================
File: src/task/core/cache/cache-metrics.ts
================
import { Logger } from '../../../logging/index.js';
import { CacheMetricsData } from '../../../types/cache.js';

export class CacheMetrics {
  private readonly logger: Logger;
  private hits = 0;
  private misses = 0;
  private size = 0;
  private lastCleanup: number = Date.now();
  private invalidations = 0;
  private clears = 0;
  private memoryUsage = 0;

  constructor() {
    this.logger = Logger.getInstance().child({ component: 'CacheMetrics' });
  }

  recordHit(): void {
    this.hits++;
  }

  recordMiss(): void {
    this.misses++;
  }

  updateSize(newSize: number): void {
    this.size = newSize;
    this.logger.debug('Cache size updated', { size: newSize });
  }

  recordInvalidation(): void {
    this.invalidations++;
    this.lastCleanup = Date.now();
    this.logger.debug('Cache invalidation recorded', {
      invalidations: this.invalidations
    });
  }

  recordClear(): void {
    this.clears++;
    this.lastCleanup = Date.now();
    this.logger.debug('Cache clear recorded', {
      clears: this.clears
    });
  }

  updateMemoryUsage(bytes: number): void {
    this.memoryUsage = bytes;
    this.logger.debug('Memory usage updated', {
      memoryUsage: `${Math.round(bytes / 1024 / 1024)}MB`
    });
  }

  getCacheSize(): number {
    return this.size;
  }

  getHitRatio(): number {
    const total = this.hits + this.misses;
    return total === 0 ? 0 : this.hits / total;
  }

  getMetrics(): CacheMetricsData {
    const metrics = {
      hits: this.hits,
      misses: this.misses,
      hitRatio: this.getHitRatio(),
      size: this.size,
      lastCleanup: this.lastCleanup,
      invalidations: this.invalidations,
      clears: this.clears,
      memoryUsage: this.memoryUsage
    };

    this.logger.debug('Cache metrics retrieved', metrics);
    return metrics;
  }

  reset(): void {
    this.hits = 0;
    this.misses = 0;
    this.size = 0;
    this.lastCleanup = Date.now();
    this.invalidations = 0;
    this.clears = 0;
    this.memoryUsage = 0;
    this.logger.debug('Cache metrics reset');
  }
}

================
File: src/task/core/cache/index.ts
================
export * from './cache-manager.js';
export * from './cache-coordinator.js';
export * from './cache-metrics.js';

================
File: src/task/core/indexing/index-manager.ts
================
/**
 * Task index manager
 * Maintains in-memory indexes for efficient task lookups
 */
import { ErrorCodes, createError } from '../../../errors/index.js';
import { Task, TaskStatus } from '../../../types/task.js';
import { TaskIndex, IndexStats } from '../../../types/indexing.js';
import { Logger } from '../../../logging/index.js';
import { globToRegex, generatePathPatterns, matchesPattern } from '../../../utils/pattern-matcher.js';

export class TaskIndexManager {
    private readonly logger: Logger;
    private readonly taskIndexes: Map<string, WeakRef<TaskIndex>>;
    private readonly pathIndex: Map<string, Set<string>>;
    private readonly patternIndex: Map<string, Set<string>>;
    private readonly statusIndex: Map<TaskStatus, Set<string>>;
    private readonly parentIndex: Map<string, Set<string>>;
    private readonly dependencyIndex: Map<string, Set<string>>;
    
    // Keep track of pattern count to prevent unbounded growth
    private readonly MAX_PATTERNS = 1000;
    private patternCount = 0;

    // Cleanup interval
    private readonly CLEANUP_INTERVAL = 60000; // 1 minute
    private cleanupTimer?: NodeJS.Timeout;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'TaskIndexManager' });
        this.taskIndexes = new Map();
        this.pathIndex = new Map();
        this.patternIndex = new Map();
        this.statusIndex = new Map();
        this.parentIndex = new Map();
        this.dependencyIndex = new Map();

        // Start cleanup timer
        this.startCleanupTimer();
    }

    private startCleanupTimer(): void {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
        
        this.cleanupTimer = setInterval(() => {
            this.cleanupIndexes();
            this.cleanupPatterns();
            
            // Force GC if available
            if (global.gc) {
                global.gc();
            }
        }, this.CLEANUP_INTERVAL);

        // Ensure cleanup timer is cleared on process exit
        process.once('beforeExit', () => {
            if (this.cleanupTimer) {
                clearInterval(this.cleanupTimer);
                this.cleanupTimer = undefined;
            }
        });
    }

    /**
     * Indexes path patterns for efficient pattern matching
     */
    private indexPathPatterns(path: string): void {
        const patterns = generatePathPatterns(path);
        
        for (const pattern of patterns) {
            let paths = this.patternIndex.get(pattern);
            if (!paths) {
                paths = new Set();
                this.patternIndex.set(pattern, paths);
                this.patternCount++;
            }
            paths.add(path);
        }
    }

    /**
     * Gets a task from its weak reference
     */
    private getTaskFromWeakRef(path: string): TaskIndex | undefined {
        const ref = this.taskIndexes.get(path);
        if (!ref) return undefined;
        
        const task = ref.deref();
        if (!task) {
            // Clean up if task was garbage collected
            this.taskIndexes.delete(path);
            return undefined;
        }
        
        return task;
    }

    /**
     * Indexes a task
     */
    async indexTask(task: Task): Promise<void> {
        try {
            // Create task index
            const taskIndex: TaskIndex = {
                ...task,
                path: task.path,
                status: task.status,
                parentPath: task.parentPath,
                dependencies: task.dependencies || [],
                subtasks: task.subtasks || []
            };

            // Store weak reference to allow GC
            this.taskIndexes.set(task.path, new WeakRef(taskIndex));

            // Clean up old patterns if we're at the limit
            if (this.patternCount >= this.MAX_PATTERNS) {
                this.cleanupPatterns();
            }

            // Update path index and patterns
            const pathSegments = task.path.split('/');
            for (let i = 1; i <= pathSegments.length; i++) {
                const prefix = pathSegments.slice(0, i).join('/');
                let paths = this.pathIndex.get(prefix);
                if (!paths) {
                    paths = new Set();
                    this.pathIndex.set(prefix, paths);
                }
                paths.add(task.path);
            }
            this.indexPathPatterns(task.path);

            // Update status index
            let statusPaths = this.statusIndex.get(task.status);
            if (!statusPaths) {
                statusPaths = new Set();
                this.statusIndex.set(task.status, statusPaths);
            }
            statusPaths.add(task.path);

            // Update parent index
            if (task.parentPath) {
                let children = this.parentIndex.get(task.parentPath);
                if (!children) {
                    children = new Set();
                    this.parentIndex.set(task.parentPath, children);
                }
                children.add(task.path);
            }

            // Update dependency index
            for (const depPath of task.dependencies) {
                let dependents = this.dependencyIndex.get(depPath);
                if (!dependents) {
                    dependents = new Set();
                    this.dependencyIndex.set(depPath, dependents);
                }
                dependents.add(task.path);
            }

            this.logger.debug('Indexed task', { path: task.path });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to index task', { error: errorMessage, task });
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to index task',
                errorMessage
            );
        }
    }

    /**
     * Gets tasks by path pattern
     */
    async getTasksByPattern(pattern: string): Promise<TaskIndex[]> {
        // First try exact pattern match from pattern index
        const exactMatches = this.patternIndex.get(pattern);
        if (exactMatches) {
            const tasks = Array.from(exactMatches)
                .map(path => this.getTaskFromWeakRef(path))
                .filter((task): task is TaskIndex => task !== undefined);
            
            // If we got matches, return them
            if (tasks.length > 0) {
                return tasks;
            }
            // Otherwise clean up the empty pattern
            this.patternIndex.delete(pattern);
            this.patternCount--;
        }

        // Try prefix match from path index
        const prefixMatches = this.pathIndex.get(pattern);
        if (prefixMatches) {
            const tasks = Array.from(prefixMatches)
                .map(path => this.getTaskFromWeakRef(path))
                .filter((task): task is TaskIndex => task !== undefined);
            
            // Clean up empty sets
            if (tasks.length === 0) {
                this.pathIndex.delete(pattern);
            }
            
            return tasks;
        }

        // Fall back to regex matching
        const regex = globToRegex(pattern);
        const matchingPaths = Array.from(this.taskIndexes.keys())
            .filter(path => regex.test(path));

        return matchingPaths
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets tasks by status with optional pattern filtering
     */
    async getTasksByStatus(status: TaskStatus, pattern?: string): Promise<TaskIndex[]> {
        const statusPaths = this.statusIndex.get(status) || new Set<string>();
        
        if (!pattern) {
            return Array.from(statusPaths)
                .map(path => this.getTaskFromWeakRef(path))
                .filter((task): task is TaskIndex => task !== undefined);
        }

        // Filter by pattern if provided
        const matchingPaths = Array.from(statusPaths)
            .filter(path => matchesPattern(path, pattern));

        return matchingPaths
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets project tasks by pattern
     */
    async getProjectTasks(pattern: string): Promise<TaskIndex[]> {
        return this.getTasksByPattern(pattern);
    }

    /**
     * Gets tasks by parent path
     */
    async getTasksByParent(parentPath: string): Promise<TaskIndex[]> {
        const children = this.parentIndex.get(parentPath) || new Set<string>();
        return Array.from(children)
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets tasks that depend on a task
     */
    async getDependentTasks(path: string): Promise<TaskIndex[]> {
        const dependents = this.dependencyIndex.get(path) || new Set<string>();
        return Array.from(dependents)
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets a task by path
     */
    async getTaskByPath(path: string): Promise<TaskIndex | null> {
        return this.getTaskFromWeakRef(path) || null;
    }

    /**
     * Unindexes a task
     */
    async unindexTask(task: Task): Promise<void> {
        try {
            // Remove from task indexes
            this.taskIndexes.delete(task.path);

            // Remove from path index and patterns
            const pathSegments = task.path.split('/');
            for (let i = 1; i <= pathSegments.length; i++) {
                const prefix = pathSegments.slice(0, i).join('/');
                const paths = this.pathIndex.get(prefix);
                if (paths) {
                    paths.delete(task.path);
                    if (paths.size === 0) {
                        this.pathIndex.delete(prefix);
                    }
                }
            }

            // Remove from pattern index
            const patterns = generatePathPatterns(task.path);
            for (const pattern of patterns) {
                const paths = this.patternIndex.get(pattern);
                if (paths) {
                    paths.delete(task.path);
                    if (paths.size === 0) {
                        this.patternIndex.delete(pattern);
                        this.patternCount--;
                    }
                }
            }

            // Remove from status index
            const statusPaths = this.statusIndex.get(task.status);
            if (statusPaths) {
                statusPaths.delete(task.path);
                if (statusPaths.size === 0) {
                    this.statusIndex.delete(task.status);
                }
            }

            // Remove from parent index
            if (task.parentPath) {
                const children = this.parentIndex.get(task.parentPath);
                if (children) {
                    children.delete(task.path);
                    if (children.size === 0) {
                        this.parentIndex.delete(task.parentPath);
                    }
                }
            }

            // Remove from dependency index
            for (const depPath of task.dependencies) {
                const dependents = this.dependencyIndex.get(depPath);
                if (dependents) {
                    dependents.delete(task.path);
                    if (dependents.size === 0) {
                        this.dependencyIndex.delete(depPath);
                    }
                }
            }

            this.logger.debug('Unindexed task', { path: task.path });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to unindex task', { error: errorMessage, task });
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to unindex task',
                errorMessage
            );
        }
    }

    /**
     * Gets index statistics
     */
    getStats(): IndexStats {
        const byStatus = {} as Record<TaskStatus, number>;
        const byDepth = {} as Record<number, number>;
        let totalDepth = 0;
        let validTaskCount = 0;

        // Only count tasks that haven't been garbage collected
        for (const [path, weakRef] of this.taskIndexes.entries()) {
            const task = weakRef.deref();
            if (task) {
                validTaskCount++;
                
                // Count by status
                byStatus[task.status] = (byStatus[task.status] || 0) + 1;

                // Count by depth
                const depth = path.split('/').length - 1;
                byDepth[depth] = (byDepth[depth] || 0) + 1;
                totalDepth += depth;
            }
        }

        return {
            totalTasks: validTaskCount,
            byStatus,
            byDepth,
            averageDepth: validTaskCount > 0 ? totalDepth / validTaskCount : 0
        };
    }

    /**
     * Cleans up old patterns to prevent unbounded growth
     */
    private cleanupPatterns(): void {
        // Remove patterns with no valid tasks
        for (const [pattern, paths] of this.patternIndex.entries()) {
            const validPaths = Array.from(paths)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.patternIndex.delete(pattern);
                this.patternCount--;
            } else if (validPaths.length !== paths.size) {
                // Update set with only valid paths
                this.patternIndex.set(pattern, new Set(validPaths));
            }
        }
    }

    /**
     * Cleans up invalid references and empty sets
     */
    private cleanupIndexes(): void {
        // Clean up task indexes
        for (const [path, weakRef] of this.taskIndexes.entries()) {
            if (weakRef.deref() === undefined) {
                this.taskIndexes.delete(path);
            }
        }

        // Clean up empty sets in all indexes
        for (const [prefix, paths] of this.pathIndex.entries()) {
            const validPaths = Array.from(paths)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.pathIndex.delete(prefix);
            } else if (validPaths.length !== paths.size) {
                this.pathIndex.set(prefix, new Set(validPaths));
            }
        }

        for (const [status, paths] of this.statusIndex.entries()) {
            const validPaths = Array.from(paths)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.statusIndex.delete(status);
            } else if (validPaths.length !== paths.size) {
                this.statusIndex.set(status, new Set(validPaths));
            }
        }

        for (const [parent, children] of this.parentIndex.entries()) {
            const validPaths = Array.from(children)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.parentIndex.delete(parent);
            } else if (validPaths.length !== children.size) {
                this.parentIndex.set(parent, new Set(validPaths));
            }
        }

        for (const [dep, dependents] of this.dependencyIndex.entries()) {
            const validPaths = Array.from(dependents)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.dependencyIndex.delete(dep);
            } else if (validPaths.length !== dependents.size) {
                this.dependencyIndex.set(dep, new Set(validPaths));
            }
        }
    }

    /**
     * Clears all indexes
     */
    clear(): void {
        // Stop cleanup timer
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = undefined;
        }

        this.taskIndexes.clear();
        this.pathIndex.clear();
        this.patternIndex.clear();
        this.statusIndex.clear();
        this.parentIndex.clear();
        this.dependencyIndex.clear();
        this.patternCount = 0;

        // Restart cleanup timer
        this.startCleanupTimer();
        
        this.logger.debug('Cleared all indexes');
    }
}

================
File: src/task/core/indexing/index.ts
================
export * from './index-manager.js';

================
File: src/task/core/transactions/index.ts
================
export * from './transaction-manager.js';

================
File: src/task/core/transactions/transaction-manager.ts
================
/**
 * Manages atomic transactions for task operations
 */

import { Logger } from '../../../logging/index.js';
import { TaskStorage } from '../../../types/storage.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { 
    Transaction,
    Operation,
    TransactionResult,
    TransactionOptions,
    DEFAULT_TRANSACTION_OPTIONS
} from '../../../types/transaction.js';
import { TransactionManager as StorageTransactionManager } from '../../../storage/core/transactions/manager.js';

export class TransactionManager {
    private readonly logger: Logger;
    private activeTransactions: Map<string, Transaction>;
    private transactionCounter: number;
    private readonly storageTransactionManager: StorageTransactionManager;
    private transactionTimeouts: Map<string, NodeJS.Timeout>;
    private static instance: TransactionManager | null = null;

    private constructor(private readonly storage?: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TaskTransactionManager' });
        this.activeTransactions = new Map();
        this.transactionTimeouts = new Map();
        this.transactionCounter = 0;
        this.storageTransactionManager = StorageTransactionManager.getInstance();
    }

    static getInstance(storage?: TaskStorage): TransactionManager {
        if (!TransactionManager.instance) {
            TransactionManager.instance = new TransactionManager(storage);
        }
        return TransactionManager.instance;
    }

    /**
     * Begins a new transaction
     */
    async begin(options: TransactionOptions = {}): Promise<Transaction> {
        const mergedOptions = { ...DEFAULT_TRANSACTION_OPTIONS, ...options };
        const id = this.generateTransactionId();
        const transaction: Transaction = {
            id,
            operations: [],
            timestamp: Date.now(),
            status: 'pending',
            timeout: mergedOptions.timeout,
            metadata: {
                retryCount: 0
            }
        };

        // Set up transaction timeout
        if (mergedOptions.timeout) {
            const timeoutHandle = setTimeout(() => {
                this.handleTransactionTimeout(id).catch(error => {
                    this.logger.error('Failed to handle transaction timeout', {
                        error,
                        transactionId: id
                    });
                });
            }, mergedOptions.timeout);
            
            this.transactionTimeouts.set(id, timeoutHandle);
        }

        try {
            // Acquire lock if required
            if (mergedOptions.requireLock) {
                await this.acquireLock(id);
            }

            // Start storage-level transaction
            if (this.storage && 'db' in this.storage) {
                await this.storageTransactionManager.beginTransaction((this.storage as any).db);
            }

            this.activeTransactions.set(id, transaction);
            
            this.logger.debug('Transaction started', { 
                transactionId: id,
                timestamp: transaction.timestamp,
                options: mergedOptions
            });

            return transaction;
        } catch (error) {
            this.logger.error('Failed to begin transaction', {
                error,
                transactionId: id
            });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to begin transaction',
                String(error)
            );
        }
    }

    /**
     * Commits a transaction
     */
    async commit(transaction: Transaction, retryOnError: boolean = true): Promise<TransactionResult> {
        try {
            const startTime = Date.now();

            // Validate transaction state
            this.validateTransactionState(transaction);

            // Clear timeout if exists
            this.clearTransactionTimeout(transaction.id);

            try {
                // Persist and commit transaction
                if (this.storage && 'db' in this.storage) {
                    await this.persistTransaction(transaction);
                    await this.storageTransactionManager.commitTransaction(
                        (this.storage as any).db,
                        transaction.id
                    );
                }

                transaction.status = 'committed';
                this.activeTransactions.delete(transaction.id);

                const duration = Date.now() - startTime;
                this.logger.debug('Transaction committed', { 
                    transactionId: transaction.id,
                    operationCount: transaction.operations.length,
                    duration
                });

                return {
                    success: true,
                    transactionId: transaction.id,
                    metadata: {
                        duration,
                        retryCount: transaction.metadata?.retryCount
                    }
                };
            } catch (error) {
                // Retry logic for transient errors
                if (retryOnError && 
                    transaction.metadata?.retryCount! < DEFAULT_TRANSACTION_OPTIONS.retryLimit! &&
                    this.isRetryableError(error)) {
                    
                    transaction.metadata!.retryCount!++;
                    await new Promise(resolve => 
                        setTimeout(resolve, DEFAULT_TRANSACTION_OPTIONS.retryDelay));
                    
                    return this.commit(transaction, true);
                }

                throw error;
            }
        } catch (error) {
            this.logger.error('Failed to commit transaction', { 
                error,
                transactionId: transaction.id 
            });

            await this.rollback(transaction);

            return {
                success: false,
                transactionId: transaction.id,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }

    /**
     * Rolls back a transaction
     */
    async rollback(transaction: Transaction): Promise<TransactionResult> {
        try {
            if (!this.activeTransactions.has(transaction.id)) {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Transaction ${transaction.id} not found`
                );
            }

            // Rollback storage-level transaction first
            if (this.storage && 'db' in this.storage) {
                await this.storageTransactionManager.rollbackTransaction(
                    (this.storage as any).db,
                    transaction.id
                );
            }

            // Then reverse operations in reverse order
            for (const operation of [...transaction.operations].reverse()) {
                await this.rollbackOperation(operation);
            }

            transaction.status = 'rolled_back';
            this.activeTransactions.delete(transaction.id);

            this.logger.debug('Transaction rolled back', { 
                transactionId: transaction.id,
                operationCount: transaction.operations.length 
            });

            return {
                success: true,
                transactionId: transaction.id
            };
        } catch (error) {
            this.logger.error('Failed to rollback transaction', { 
                error,
                transactionId: transaction.id 
            });

            // Even if application-level rollback fails, ensure storage transaction is rolled back
            if (this.storage && 'db' in this.storage) {
                try {
                    await this.storageTransactionManager.rollbackTransaction(
                        (this.storage as any).db,
                        transaction.id
                    );
                } catch (rollbackError) {
                    this.logger.error('Failed to rollback storage transaction', {
                        error: rollbackError,
                        transactionId: transaction.id
                    });
                }
            }

            return {
                success: false,
                transactionId: transaction.id,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }

    /**
     * Gets active transaction by ID
     */
    getTransaction(id: string): Transaction | undefined {
        return this.activeTransactions.get(id);
    }

    /**
     * Generates a unique transaction ID
     */
    private generateTransactionId(): string {
        this.transactionCounter++;
        return `txn_${Date.now()}_${this.transactionCounter}_${Math.random().toString(36).substr(2, 9)}`;
    }

    private async handleTransactionTimeout(transactionId: string): Promise<void> {
        const transaction = this.activeTransactions.get(transactionId);
        if (!transaction) return;

        this.logger.warn('Transaction timeout', {
            transactionId,
            duration: Date.now() - transaction.timestamp
        });

        try {
            await this.rollback(transaction);
        } finally {
            this.clearTransactionTimeout(transactionId);
        }
    }

    private clearTransactionTimeout(transactionId: string): void {
        const timeout = this.transactionTimeouts.get(transactionId);
        if (timeout) {
            clearTimeout(timeout);
            this.transactionTimeouts.delete(transactionId);
        }
    }

    private validateTransactionState(transaction: Transaction): void {
        if (!this.activeTransactions.has(transaction.id)) {
            throw createError(
                ErrorCodes.INVALID_STATE,
                `Transaction ${transaction.id} not found`
            );
        }

        if (transaction.status !== 'pending') {
            throw createError(
                ErrorCodes.INVALID_STATE,
                `Transaction ${transaction.id} is already ${transaction.status}`
            );
        }
    }

    private async acquireLock(transactionId: string): Promise<void> {
        // Implement distributed locking mechanism here
        // Could use Redis, ZooKeeper, or other lock service
        this.logger.debug('Lock acquired', { transactionId });
    }

    private isRetryableError(error: any): boolean {
        // Add logic to determine if error is transient
        return error.code === 'SQLITE_BUSY' || 
               error.code === 'SQLITE_LOCKED' ||
               error.message.includes('deadlock');
    }

    /**
     * Persists a transaction to storage
     */
    private async persistTransaction(transaction: Transaction): Promise<void> {
        if (!this.storage) return;

        try {
            // Implementation depends on storage interface
            // Could store in a transactions table or log
            this.logger.debug('Transaction persisted', { 
                transactionId: transaction.id 
            });
        } catch (error) {
            this.logger.error('Failed to persist transaction', { 
                error,
                transactionId: transaction.id 
            });
            throw error;
        }
    }

    /**
     * Rolls back a single operation
     */
    private async rollbackOperation(operation: Operation): Promise<void> {
        if (!this.storage) return;

        try {
            switch (operation.type) {
                case 'delete':
                    // Restore deleted tasks
                    if (operation.tasks && operation.tasks.length > 0) {
                        await this.storage.saveTasks(operation.tasks);
                    }
                    break;

                case 'update':
                    // Revert task to previous state
                    if (operation.previousState && operation.path) {
                        await this.storage.updateTask(operation.path, operation.previousState);
                    }
                    break;

                case 'create':
                    // Delete created task
                    if (operation.task) {
                        await this.storage.deleteTasks([operation.task.path]);
                    }
                    break;
            }
        } catch (error) {
            this.logger.error('Failed to rollback operation', { 
                error,
                operationType: operation.type 
            });
            throw error;
        }
    }
}

================
File: src/task/core/index.ts
================
/**
 * Task Core Module
 * 
 * Provides core task management functionality:
 * - Task storage and persistence
 * - Dependency validation
 * - Status management
 */

export * from './task-store.js';

================
File: src/task/core/task-store.ts
================
/**
 * Path-based task storage with caching, indexing, and transaction support
 */
import { Task, TaskStatus, getParentPath } from '../../types/task.js';
import { isValidTaskHierarchy } from '../validation/index.js';
import { PathValidator } from '../../validation/index.js';
import { TaskStorage } from '../../types/storage.js';
import { Logger } from '../../logging/index.js';
import { TaskIndexManager } from './indexing/index-manager.js';
import { CacheManager } from './cache/cache-manager.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionManager } from './transactions/transaction-manager.js';

const BATCH_SIZE = 50; // Maximum number of tasks to process in parallel

export class TaskStore {
    private readonly logger: Logger;
    private readonly indexManager: TaskIndexManager;
    private readonly cacheManager: CacheManager;
    private readonly pathValidator: PathValidator;
    private nodes: Map<string, {
        path: string;
        dependencies: Set<string>;
        dependents: Set<string>;
        visited: boolean;
        inPath: boolean;
        ref: WeakRef<object>;
    }>;
    private readonly transactionManager: TransactionManager;
    private readonly HIGH_MEMORY_THRESHOLD = 0.7; // 70% memory pressure threshold
    private readonly MEMORY_CHECK_INTERVAL = 10000; // 10 seconds
    private memoryCheckInterval?: NodeJS.Timeout;

    constructor(private readonly storage: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TaskStore' });
        this.indexManager = new TaskIndexManager();
        this.pathValidator = new PathValidator();
        this.cacheManager = new CacheManager({
            maxSize: 500, // Reduced from 1000
            ttl: 30000, // Reduced from 60000
            maxTTL: 60000, // Reduced from 300000
            cleanupInterval: 15000 // Reduced from 30000
        });
        this.nodes = new Map();
        this.transactionManager = TransactionManager.getInstance(storage);

        // Start memory monitoring
        this.startMemoryMonitoring();
    }

    private startMemoryMonitoring(): void {
        this.memoryCheckInterval = setInterval(() => {
            const memoryUsage = process.memoryUsage();
            const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;

            this.logger.debug('Memory usage', {
                heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
                heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
                external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
                arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
                nodeCount: this.nodes.size,
                activeNodes: Array.from(this.nodes.keys()).length
            });

            if (heapUsed > this.HIGH_MEMORY_THRESHOLD) {
                this.logger.warn('High memory usage detected in TaskStore', {
                    heapUsed: `${(heapUsed * 100).toFixed(1)}%`
                });
                
                // Force cleanup
                this.cleanupResources(true);
                
                // Force GC if available
                if (global.gc) {
                    global.gc();
                }
            }
        }, this.MEMORY_CHECK_INTERVAL);

        // Ensure cleanup on process exit
        process.once('beforeExit', () => {
            if (this.memoryCheckInterval) {
                clearInterval(this.memoryCheckInterval);
                this.memoryCheckInterval = undefined;
            }
        });
    }

    private async cleanupResources(force: boolean = false): Promise<void> {
        try {
            const startTime = Date.now();
            let cleanedCount = 0;

            // Clean up nodes whose refs have been collected
            for (const [path, node] of this.nodes.entries()) {
                if (!node.ref.deref() || force) {
                    this.nodes.delete(path);
                    cleanedCount++;
                }
            }

            // Force garbage collection if needed
            if (global.gc && (force || cleanedCount > 0)) {
                global.gc();
            }

            const endTime = Date.now();
            this.logger.info('Resource cleanup completed', {
                duration: endTime - startTime,
                cleanedCount,
                remainingNodes: this.nodes.size,
                memoryUsage: this.getMemoryMetrics()
            });
        } catch (error) {
            this.logger.error('Error during resource cleanup', { error });
        }
    }

    private getMemoryMetrics(): Record<string, string> {
        const memoryUsage = process.memoryUsage();
        return {
            heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
            heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
            rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
            external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
            arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
            heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
        };
    }

    /**
     * Processes tasks in batches with memory-efficient processing
     */
    private async processBatch<T>(
        items: T[],
        processor: (item: T) => Promise<void>
    ): Promise<void> {
        // Process in smaller chunks to avoid memory spikes
        const chunkSize = Math.min(BATCH_SIZE, 10);
        for (let i = 0; i < items.length; i += chunkSize) {
            const chunk = items.slice(i, i + chunkSize);
            
            // Process items sequentially in chunk to reduce memory pressure
            for (const item of chunk) {
                await processor(item);
            }

            // Allow GC between chunks
            if (i > 0 && i % (chunkSize * 5) === 0) {
                if (global.gc) {
                    global.gc();
                }
            }
        }
    }

    /**
     * Gets a task by path, checking cache first
     */
    private async getTaskByPath(path: string): Promise<Task | null> {
        const pathResult = this.pathValidator.validatePath(path);
        if (!pathResult.isValid) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                pathResult.error || `Invalid task path: ${path}`
            );
        }

        // Check cache first
        const cachedTask = await this.cacheManager.get<Task>(path);
        if (cachedTask) {
            return cachedTask;
        }

        // Check index
        const indexedTask = await this.indexManager.getTaskByPath(path);
        if (indexedTask) {
            await this.cacheManager.set(path, indexedTask);
            return indexedTask;
        }

        // Load from storage
        const task = await this.storage.getTask(path);
        if (task) {
            await this.cacheManager.set(path, task);
            await this.indexManager.indexTask(task);
        }

        return task;
    }

    /**
     * Updates dependent task statuses
     */
    private async updateDependentStatuses(task: Task): Promise<void> {
        const dependentTasks = await this.indexManager.getDependentTasks(task.path);
        
        for (const depTask of dependentTasks) {
            const taskPath = depTask.path;
            const updatedTask = await this.getTaskByPath(taskPath);
            if (!updatedTask) continue;

            // If a dependency fails or is blocked, block the dependent task
            if (task.status === TaskStatus.FAILED || task.status === TaskStatus.BLOCKED) {
                updatedTask.status = TaskStatus.BLOCKED;
                await this.saveTasks([updatedTask]);
            }
            // If all dependencies are complete, unblock the dependent task
            else if (task.status === TaskStatus.COMPLETED) {
                const allDepsCompleted = await this.checkAllDependenciesCompleted(updatedTask);
                if (allDepsCompleted) {
                    updatedTask.status = TaskStatus.PENDING;
                    await this.saveTasks([updatedTask]);
                }
            }
        }
    }

    /**
     * Checks if all dependencies are completed
     */
    private async checkAllDependenciesCompleted(task: Task): Promise<boolean> {
        for (const depPath of task.dependencies) {
            const depTask = await this.getTaskByPath(depPath);
            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
                return false;
            }
        }
        return true;
    }

    /**
     * Saves tasks with validation, indexing, and transaction support
     */
    async saveTasks(tasks: Task[]): Promise<void> {
        // Validate paths and collect parent updates
        for (const task of tasks) {
            const pathResult = this.pathValidator.validatePath(task.path);
            if (!pathResult.isValid) {
                throw createError(
                    ErrorCodes.TASK_INVALID_PATH,
                    pathResult.error || `Invalid task path: ${task.path}`
                );
            }
        }

        const transaction = await this.transactionManager.begin();

        try {
            // First pass: validate all tasks and collect parent paths
            const parentPaths = new Set<string>();
            const tasksToSave = new Map<string, Task>();

            for (const task of tasks) {
                // Ensure task has required arrays
                if (!task.subtasks) task.subtasks = [];
                if (!task.dependencies) task.dependencies = [];

                // Get and validate parent path
                const parentPath = task.parentPath || getParentPath(task.path);
                if (parentPath) {
                    task.parentPath = parentPath;
                    parentPaths.add(parentPath);
                }

                tasksToSave.set(task.path, task);
            }

            // Second pass: load and validate all parents
            const parentUpdates = new Map<string, Task>();
            for (const parentPath of parentPaths) {
                const parent = await this.getTaskByPath(parentPath);
                if (!parent) {
                    throw createError(
                        ErrorCodes.TASK_PARENT_NOT_FOUND,
                        `Parent task not found: ${parentPath}. Parent tasks must be created before their children.`
                    );
                }
                parentUpdates.set(parentPath, parent);
            }

            // Third pass: validate relationships and update parent subtasks
            for (const task of tasksToSave.values()) {
                // Get the original task to check if parentPath has changed
                const originalTask = await this.getTaskByPath(task.path);
                
                // If task exists and parentPath has changed, remove from old parent
                if (originalTask && originalTask.parentPath && originalTask.parentPath !== task.parentPath) {
                    const oldParent = await this.getTaskByPath(originalTask.parentPath);
                    if (oldParent) {
                        oldParent.subtasks = oldParent.subtasks.filter(p => p !== task.path);
                        parentUpdates.set(oldParent.path, oldParent);
                        
                        // Update old parent's index
                        await this.indexManager.unindexTask(oldParent);
                        await this.indexManager.indexTask(oldParent);
                    }
                }

                // Handle new parent relationship
                if (task.parentPath) {
                    const parent = parentUpdates.get(task.parentPath) || await this.getTaskByPath(task.parentPath);
                    if (!parent) {
                        throw createError(
                            ErrorCodes.TASK_PARENT_NOT_FOUND,
                            `Parent task not found: ${task.parentPath}. Parent tasks must be created before their children.`
                        );
                    }

                    // Validate task type hierarchy
                    if (!isValidTaskHierarchy(parent.type, task.type)) {
                        throw createError(
                            ErrorCodes.TASK_PARENT_TYPE,
                            `Invalid parent-child relationship: ${parent.type} cannot contain ${task.type}`
                        );
                    }

                    // Update and index parent's subtasks if needed
                    if (!parent.subtasks.includes(task.path)) {
                        parent.subtasks = [...parent.subtasks, task.path];
                        parentUpdates.set(parent.path, parent);
                        
                        // Ensure parent-child relationship is indexed
                        await this.indexManager.unindexTask(parent);
                        await this.indexManager.indexTask(parent);
                    }
                }
            }

            // Prepare final task list with updated relationships
            const allTasks = [...parentUpdates.values(), ...tasksToSave.values()];
            await this.storage.saveTasks(allTasks);

            // Clear cache for all affected tasks
            await Promise.all(allTasks.map(task => this.cacheManager.delete(task.path)));

            // Reindex all tasks to ensure relationships are properly established
            for (const task of allTasks) {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
            }

            // Validate dependencies for original tasks
            for (const task of tasks) {
                await this.validateDependencies(task.path, task.dependencies);
            }

            // Propagate status changes
            await this.processBatch(tasks, async task => {
                await this.updateDependentStatuses(task);
            });

            await this.transactionManager.commit(transaction);

            this.logger.debug('Tasks saved successfully', {
                count: tasks.length,
                paths: tasks.map(t => t.path)
            });
        } catch (error) {
            // Rollback transaction
            await this.transactionManager.rollback(transaction);

            // Rollback cache and indexes
            await this.processBatch(tasks, async task => {
                await this.indexManager.unindexTask(task);
                await this.cacheManager.delete(task.path);
            });

            this.logger.error('Failed to save tasks', { error, tasks });
            throw error;
        }
    }

    /**
     * Gets tasks by path pattern with efficient caching
     */
    async getTasksByPattern(pattern: string): Promise<Task[]> {
        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getProjectTasks(pattern);
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get<Task>(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getTasksByPattern(pattern);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get tasks by pattern', { error, pattern });
            throw error;
        }
    }

    /**
     * Gets tasks by status with efficient caching
     */
    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getTasksByStatus(status, '');
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get<Task>(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getTasksByStatus(status);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get tasks by status', { error, status });
            throw error;
        }
    }

    /**
     * Gets subtasks of a task with efficient caching
     */
    async getSubtasks(parentPath: string): Promise<Task[]> {
        const pathResult = this.pathValidator.validatePath(parentPath);
        if (!pathResult.isValid) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                pathResult.error || `Invalid parent path: ${parentPath}`
            );
        }

        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getTasksByParent(parentPath);
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get<Task>(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getSubtasks(parentPath);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get subtasks', { error, parentPath });
            throw error;
        }
    }

    /**
     * Deletes a task and its subtasks with transaction support
     */
    async deleteTask(path: string): Promise<void> {
        const pathResult = this.pathValidator.validatePath(path);
        if (!pathResult.isValid) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                pathResult.error || `Invalid task path: ${path}`
            );
        }

        const transaction = await this.transactionManager.begin();

        try {
            // Get task and subtasks
            const task = await this.storage.getTask(path);
            if (!task) {
                throw createError(
                    ErrorCodes.TASK_NOT_FOUND,
                    `Task not found: ${path}`
                );
            }

            const subtasks = await this.storage.getSubtasks(path);
            const allTasks = [task, ...subtasks];
            const allPaths = allTasks.map(t => t.path);

            // Add delete operation to transaction
            for (const taskPath of allPaths) {
                transaction.operations.push({
                    id: `delete-${Date.now()}-${Math.random()}`,
                    type: 'delete',
                    timestamp: Date.now(),
                    path: taskPath,
                    tasks: allTasks
                });
            }

            // Delete from storage
            await this.storage.deleteTasks(allPaths);

            // Update cache and indexes
            await this.processBatch(allTasks, async task => {
                await this.indexManager.unindexTask(task);
                await this.cacheManager.delete(task.path);
            });

            // Update dependent tasks
            await this.processBatch(allTasks, async task => {
                await this.updateDependentStatuses(task);
            });

            await this.transactionManager.commit(transaction);

            this.logger.debug('Task and subtasks deleted', {
                path,
                subtaskCount: subtasks.length
            });
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to delete task', { error, path });
            throw error;
        }
    }

    /**
     * Clears all tasks and resets indexes
     */
    async clearAllTasks(confirm: boolean): Promise<void> {
        if (!confirm) {
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Must explicitly confirm task deletion'
            );
        }

        const transaction = await this.transactionManager.begin();

        try {
            // Clear all tasks from storage
            await this.storage.clearAllTasks();
            
            // Clear cache and indexes
            await Promise.all([
                this.indexManager.clear(),
                this.cacheManager.clear()
            ]);

            await this.transactionManager.commit(transaction);
            this.logger.info('All tasks and indexes cleared');
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to clear tasks', { error });
            throw error;
        }
    }

    /**
     * Optimizes database storage and performance
     */
    async vacuumDatabase(analyze: boolean = true): Promise<void> {
        try {
            await this.storage.vacuum();
            if (analyze) {
                await this.storage.analyze();
            }
            await this.storage.checkpoint();
            this.logger.info('Database optimized', { analyzed: analyze });
        } catch (error) {
            this.logger.error('Failed to optimize database', { error });
            throw error;
        }
    }

    /**
     * Repairs parent-child relationships and fixes inconsistencies
     */
    async repairRelationships(dryRun: boolean = false, pathPattern?: string): Promise<{ fixed: number, issues: string[] }> {
        const transaction = await this.transactionManager.begin();

        try {
            // Get tasks to repair
            const tasks = pathPattern ? 
                await this.getTasksByPattern(pathPattern) :
                await this.storage.getTasks([]);

            // Clear cache for affected tasks
            await Promise.all(tasks.map(task => this.cacheManager.delete(task.path)));

            // Repair relationships
            const result = await this.storage.repairRelationships(dryRun);

            if (!dryRun) {
                // Reindex all tasks after repair
                await Promise.all(tasks.map(task => this.indexManager.indexTask(task)));
            }

            await this.transactionManager.commit(transaction);
            return result;
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to repair relationships', { error });
            throw error;
        }
    }

    /**
     * Clears cache and indexes
     */
    async clearCache(): Promise<void> {
        const transaction = await this.transactionManager.begin();

        try {
            await Promise.all([
                this.indexManager.clear(),
                this.cacheManager.clear()
            ]);

            await this.transactionManager.commit(transaction);
            this.logger.debug('Cache cleared');
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to clear cache', { error });
            throw error;
        }
    }

    /**
     * Validates task dependencies
     */
    private async validateDependencies(taskPath: string, dependencies: string[]): Promise<void> {
        try {
            // Pre-validate dependencies exist
            await this.preValidateDependencies(dependencies);

            // Reset validation state
            this.nodes.clear();

            // Build dependency graph
            await this.buildDependencyGraph(taskPath, dependencies);

            // Check for cycles
            this.detectCycles(taskPath);

            // Validate dependency statuses
            await this.validateDependencyStatuses();

            this.logger.debug('Dependencies validated successfully', {
                taskPath,
                dependencies,
                validationSteps: [
                    'pre-validation',
                    'graph-building',
                    'cycle-detection',
                    'status-validation'
                ]
            });
        } catch (error) {
            this.logger.error('Dependency validation failed', {
                taskPath,
                dependencies,
                error
            });
            throw error;
        }
    }

    /**
     * Pre-validates all dependencies exist before building the graph
     */
    private async preValidateDependencies(dependencies: string[]): Promise<void> {
        const missingDeps: string[] = [];
        
        for (const depPath of dependencies) {
            const depTask = await this.getTaskByPath(depPath);
            if (!depTask) {
                missingDeps.push(depPath);
            }
        }

        if (missingDeps.length > 0) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                'One or more dependency tasks not found',
                'preValidateDependencies',
                'Ensure all dependency tasks exist before creating relationships',
                {
                    missingDependencies: missingDeps,
                    totalDependencies: dependencies.length
                }
            );
        }
    }

    /**
     * Builds the dependency graph
     */
    private async buildDependencyGraph(taskPath: string, dependencies: string[]): Promise<void> {
        try {
            // Create node for current task
            const node = this.getOrCreateNode(taskPath);

            // Process each dependency
            for (const depPath of dependencies) {
                const depTask = await this.getTaskByPath(depPath);
                if (!depTask) {
                    // This shouldn't happen due to pre-validation, but handle just in case
                    throw createError(
                        ErrorCodes.TASK_NOT_FOUND,
                        'Dependency task not found during graph building',
                        'buildDependencyGraph',
                        undefined,
                        {
                            taskPath,
                            dependencyPath: depPath,
                            graphState: this.getGraphState()
                        }
                    );
                }

                // Add dependency relationship
                node.dependencies.add(depPath);
                const depNode = this.getOrCreateNode(depPath);
                depNode.dependents.add(taskPath);

                // Process transitive dependencies
                await this.buildDependencyGraph(depPath, depTask.dependencies);
            }
        } catch (error) {
            this.logger.error('Error building dependency graph', {
                taskPath,
                dependencies,
                error,
                graphState: this.getGraphState()
            });
            throw error;
        }
    }

    /**
     * Detects cycles in the dependency graph
     */
    private detectCycles(startPath: string): void {
        const node = this.nodes.get(startPath);
        if (!node) {
            return;
        }

        node.visited = true;
        node.inPath = true;

        for (const depPath of node.dependencies) {
            const depNode = this.nodes.get(depPath);
            if (!depNode) {
                continue;
            }

            if (!depNode.visited) {
                this.detectCycles(depPath);
            } else if (depNode.inPath) {
                const cyclePath = this.getCyclePath(depPath);
                throw createError(
                    ErrorCodes.TASK_CYCLE,
                    'Circular dependency detected in task graph',
                    'detectCycles',
                    'Remove one of the dependencies to break the cycle',
                    {
                        cyclePath,
                        startPath,
                        affectedTasks: Array.from(this.nodes.keys()),
                        graphState: this.getGraphState()
                    }
                );
            }
        }

        node.inPath = false;
    }

    /**
     * Gets the path of a dependency cycle
     */
    private getCyclePath(startPath: string): string {
        const cycle: string[] = [startPath];
        let current = startPath;

        while (true) {
            const node = this.nodes.get(current);
            if (!node) {
                break;
            }

            for (const depPath of node.dependencies) {
                const depNode = this.nodes.get(depPath);
                if (depNode?.inPath) {
                    cycle.push(depPath);
                    if (depPath === startPath) {
                        return cycle.join(' -> ');
                    }
                    current = depPath;
                    break;
                }
            }
        }

        return cycle.join(' -> ');
    }

    /**
     * Validates dependency task statuses
     */
    private async validateDependencyStatuses(): Promise<void> {
        const statusIssues: Array<{ path: string; status: TaskStatus; issue: string }> = [];

        for (const [path] of this.nodes) {
            const task = await this.getTaskByPath(path);
            if (!task) {
                continue;
            }

            if (task.status === TaskStatus.FAILED) {
                statusIssues.push({
                    path,
                    status: task.status,
                    issue: 'Task has failed'
                });
            }

            if (task.status === TaskStatus.BLOCKED) {
                statusIssues.push({
                    path,
                    status: task.status,
                    issue: 'Task is blocked'
                });
            }
        }

        if (statusIssues.length > 0) {
            throw createError(
                ErrorCodes.TASK_DEPENDENCY,
                'Dependency status validation failed',
                'validateDependencyStatuses',
                'Ensure all dependencies are in a valid state before proceeding',
                {
                    statusIssues,
                    graphState: this.getGraphState()
                }
            );
        }
    }

    /**
     * Gets or creates a dependency node
     */
    private getOrCreateNode(path: string): {
        path: string;
        dependencies: Set<string>;
        dependents: Set<string>;
        visited: boolean;
        inPath: boolean;
        ref: WeakRef<object>;
    } {
        let node = this.nodes.get(path);
        if (!node) {
            const obj = { path }; // Create object to track via WeakRef
            node = {
                path,
                dependencies: new Set(),
                dependents: new Set(),
                visited: false,
                inPath: false,
                ref: new WeakRef(obj)
            };
            this.nodes.set(path, node);
        }
        return node;
    }

    /**
     * Gets the current state of the dependency graph for debugging
     */
    private getGraphState(): Record<string, unknown> {
        return Object.fromEntries(
            Array.from(this.nodes.entries()).map(([path, node]) => [
                path,
                {
                    dependencies: Array.from(node.dependencies),
                    dependents: Array.from(node.dependents),
                    visited: node.visited,
                    inPath: node.inPath,
                    hasRef: node.ref.deref() !== undefined
                }
            ])
        );
    }
}

================
File: src/task/operations/index.ts
================
import { TaskOperations } from './task-operations.js';

export {
    TaskOperations
};

================
File: src/task/operations/task-operations.ts
================
import { Logger } from '../../logging/index.js';
import { EventManager } from '../../events/event-manager.js';
import { EventTypes } from '../../types/events.js';
import { TaskStorage } from '../../types/storage.js';
import { Task, TaskStatus, TaskType, CreateTaskInput, UpdateTaskInput } from '../../types/task.js';
import { TaskValidator } from '../validation/task-validator.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionManager } from '../core/transactions/transaction-manager.js';
import { StatusUpdateBatch } from '../core/batch/status-update-batch.js';

interface TaskEvent {
  type: EventTypes;
  timestamp: number;
  taskId: string;
  task: Task;
  metadata?: Record<string, any>;
  changes?: {
    before: Partial<Task>;
    after: Partial<Task>;
  };
}

export class TaskOperations {
  private readonly logger: Logger;
  private readonly eventManager: EventManager;
  private readonly transactionManager: TransactionManager;
  private readonly eventSubscriptions: Map<string, { unsubscribe: () => void }> = new Map();
  private readonly HIGH_MEMORY_THRESHOLD = 0.7; // 70% memory pressure threshold
  private readonly MEMORY_CHECK_INTERVAL = 10000; // 10 seconds
  private memoryCheckInterval?: NodeJS.Timeout;
  private isShuttingDown = false;
  private static instance: TaskOperations | null = null;
  private static initializationPromise: Promise<TaskOperations> | null = null;
  private initialized = false;
  private readonly statusUpdateBatch: StatusUpdateBatch;

    private constructor(
        private readonly storage: TaskStorage,
        private readonly validator: TaskValidator
    ) {
        this.logger = Logger.getInstance().child({ component: 'TaskOperations' });
        this.eventManager = EventManager.getInstance();
        this.transactionManager = TransactionManager.getInstance(storage);
        this.statusUpdateBatch = new StatusUpdateBatch(storage);
        
        // Setup event listeners
        this.setupEventListeners();

        // Setup memory monitoring
        this.startMemoryMonitoring();
        
        // Log initial memory state
        this.logMemoryUsage('Initialization');
    }

  /**
   * Gets the TaskOperations instance
   */
  static async getInstance(storage: TaskStorage, validator: TaskValidator): Promise<TaskOperations> {
    // Return existing instance if available
    if (TaskOperations.instance && TaskOperations.instance.initialized) {
      return TaskOperations.instance;
    }

    // If initialization is in progress, wait for it
    if (TaskOperations.initializationPromise) {
      return TaskOperations.initializationPromise;
    }

    // Start new initialization with mutex
    TaskOperations.initializationPromise = (async () => {
      try {
        // Double-check instance hasn't been created while waiting
        if (TaskOperations.instance && TaskOperations.instance.initialized) {
          return TaskOperations.instance;
        }

        TaskOperations.instance = new TaskOperations(storage, validator);
        await TaskOperations.instance.initialize();
        return TaskOperations.instance;
      } catch (error) {
        throw createError(
          ErrorCodes.STORAGE_INIT,
          `Failed to initialize TaskOperations: ${error instanceof Error ? error.message : String(error)}`
        );
      } finally {
        TaskOperations.initializationPromise = null;
      }
    })();

    return TaskOperations.initializationPromise;
  }

  private async initialize(): Promise<void> {
    if (this.initialized) {
      this.logger.debug('Task operations already initialized');
      return;
    }

    try {
      this.initialized = true;
      this.logger.debug('Task operations initialized');
    } catch (error) {
      this.logger.error('Failed to initialize task operations', { error });
      throw error;
    }
  }

  private setupEventListeners(): void {
    // Setup event listeners with strong references and explicit cleanup
    const setupListener = (type: EventTypes) => {
      const handler = (event: TaskEvent) => {
        this.logger.debug(`${type} event received`, { taskId: event.taskId });
      };
      const subscription = this.eventManager.on(type, handler);
      this.eventSubscriptions.set(type, subscription);
    };

    setupListener(EventTypes.TASK_CREATED);
    setupListener(EventTypes.TASK_UPDATED);
    setupListener(EventTypes.TASK_DELETED);
    setupListener(EventTypes.TASK_STATUS_CHANGED);
  }

  private startMemoryMonitoring(): void {
    // Monitor memory usage periodically
    this.memoryCheckInterval = setInterval(() => {
      const memoryUsage = process.memoryUsage();
      const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;

      this.logger.debug('Memory usage', {
        heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
        heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
        rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
        external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
        arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`
      });

      if (heapUsed > this.HIGH_MEMORY_THRESHOLD) {
        this.logger.warn('High memory usage detected', {
          heapUsed: `${(heapUsed * 100).toFixed(1)}%`
        });
        
        // Force cleanup when memory pressure is high
        this.cleanupResources(true);
        
        // Force GC if available
        if (global.gc) {
          this.logger.info('Forcing garbage collection');
          global.gc();
        }
      }

      // Check for stale transactions
      this.cleanupStaleTransactions();
    }, this.MEMORY_CHECK_INTERVAL);

    // Ensure cleanup on process exit
    process.once('beforeExit', () => {
      if (this.memoryCheckInterval) {
        clearInterval(this.memoryCheckInterval);
        this.memoryCheckInterval = undefined;
      }
    });
  }

  private async cleanupResources(force: boolean = false): Promise<void> {
    try {
      const startTime = Date.now();
      let cleanedCount = 0;

      // Clean up event subscriptions
      if (force) {
        for (const [type, subscription] of this.eventSubscriptions.entries()) {
          subscription.unsubscribe();
          this.eventSubscriptions.delete(type);
          cleanedCount++;
        }
      }

      // Force garbage collection if available
      if (global.gc && (force || cleanedCount > 0)) {
        global.gc();
      }

      const endTime = Date.now();
      this.logger.info('Resource cleanup completed', {
        duration: endTime - startTime,
        cleanedCount,
        forced: force,
        remainingSubscriptions: this.eventSubscriptions.size,
        memoryUsage: this.getMemoryMetrics()
      });
    } catch (error) {
      this.logger.error('Error during resource cleanup', { error });
    }
  }

  private cleanupStaleTransactions(): void {
    // Transaction cleanup is now handled by TransactionManager
  }

  private getMemoryMetrics(): Record<string, string> {
    const memoryUsage = process.memoryUsage();
    return {
      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
      external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
      arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
      heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
    };
  }

  private logMemoryUsage(context: string): void {
    this.logger.info(`Memory usage - ${context}`, this.getMemoryMetrics());
  }

  async cleanup(): Promise<void> {
    try {
      this.isShuttingDown = true;
      this.logMemoryUsage('Cleanup start');

      // Stop memory monitoring
      if (this.memoryCheckInterval) {
        clearInterval(this.memoryCheckInterval);
        this.memoryCheckInterval = undefined;
      }

      // Cleanup event subscriptions
      for (const [type, subscription] of this.eventSubscriptions.entries()) {
        subscription.unsubscribe();
        this.eventSubscriptions.delete(type);
      }

      // Force final cleanup
      await this.cleanupResources(true);

      // Final garbage collection
      if (global.gc) {
        this.logger.info('Forcing final garbage collection');
        global.gc();
      }

      this.logMemoryUsage('Cleanup end');
      this.logger.info('Task operations cleanup completed', {
        finalMetrics: {
          eventSubscriptions: this.eventSubscriptions.size,
          ...this.getMemoryMetrics()
        }
      });
    } catch (error) {
      this.logger.error('Error during task operations cleanup', { error });
      throw error;
    }
  }

  async createTask(input: CreateTaskInput): Promise<Task> {
    if (!this.initialized) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'Task operations not initialized');
    }
    if (this.isShuttingDown) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'System is shutting down');
    }

    // Set defaults
    const taskInput: CreateTaskInput = {
      ...input,
      type: input.type || TaskType.TASK // Default to TASK type if not provided
    };

    // Validate input
    await this.validator.validateCreate(taskInput);

    const transaction = await this.transactionManager.begin({
      timeout: 10000,
      requireLock: true
    });

    try {
      // Create task with processed input containing defaults
      const task = await this.storage.createTask(taskInput);

      // Add operation to transaction
      transaction.operations.push({
        id: `create-${Date.now()}`,
        type: 'create',
        timestamp: Date.now(),
        path: task.path,
        task
      });

      // Emit event
      this.eventManager.emit({
        type: EventTypes.TASK_CREATED,
        timestamp: Date.now(),
        taskId: task.path,
        task,
        metadata: { input }
      });

      await this.transactionManager.commit(transaction);
      return task;
    } catch (error) {
      await this.transactionManager.rollback(transaction);
      this.logger.error('Failed to create task', { error, input });
      throw error;
    }
  }

  async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
    if (!this.initialized) {
      throw createError(
        ErrorCodes.OPERATION_FAILED,
        'Task operations not initialized'
      );
    }
    if (this.isShuttingDown) {
      throw createError(
        ErrorCodes.OPERATION_FAILED,
        'System is shutting down'
      );
    }

    // Get existing task
    const existingTask = await this.storage.getTask(path);
    if (!existingTask) {
      throw createError(ErrorCodes.TASK_NOT_FOUND, `Task not found: ${path}`);
    }

    // Validate updates
    await this.validator.validateUpdate(path, updates);

    const transaction = await this.transactionManager.begin({
      timeout: 10000,
      requireLock: true
    });

    try {
      // Update task with system fields
      const updatedTask = await this.storage.updateTask(path, {
        ...updates,
        version: existingTask.version + 1,
        updated: Date.now(),
        // Preserve other system fields
        created: existingTask.created,
        projectPath: existingTask.projectPath
      });

      // Add operation to transaction
      transaction.operations.push({
        id: `update-${Date.now()}`,
        type: 'update',
        timestamp: Date.now(),
        path: updatedTask.path,
        task: updatedTask,
        previousState: existingTask
      });

      // Handle status changes in batch
      if (updates.status && updates.status !== existingTask.status) {
        await this.handleStatusChange(existingTask, updatedTask);
        await this.statusUpdateBatch.execute();
      }

      // Emit update event
      this.eventManager.emit({
        type: EventTypes.TASK_UPDATED,
        timestamp: Date.now(),
        taskId: updatedTask.path,
        task: updatedTask,
        changes: {
          before: existingTask,
          after: updatedTask
        }
      });

      await this.transactionManager.commit(transaction);
      return updatedTask;
    } catch (error) {
      this.logger.error('Failed to update task', {
        error,
        path,
        updates
      });
      throw error;
    }
  }

  async deleteTask(path: string): Promise<void> {
    if (!this.initialized) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'Task operations not initialized');
    }
    if (this.isShuttingDown) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'System is shutting down');
    }

    // Get existing task
    const existingTask = await this.storage.getTask(path);
    if (!existingTask) {
      throw createError(ErrorCodes.TASK_NOT_FOUND, `Task not found: ${path}`);
    }

    const transaction = await this.transactionManager.begin({
      timeout: 10000,
      requireLock: true
    });

    try {
      // Delete task
      await this.storage.deleteTask(path);

      // Add operation to transaction
      transaction.operations.push({
        id: `delete-${Date.now()}`,
        type: 'delete',
        timestamp: Date.now(),
        path: existingTask.path,
        tasks: [existingTask]
      });

      // Emit delete event
      this.eventManager.emit({
        type: EventTypes.TASK_DELETED,
        timestamp: Date.now(),
        taskId: existingTask.path,
        task: existingTask
      });

      await this.transactionManager.commit(transaction);
    } catch (error) {
      this.logger.error('Failed to delete task', {
        error,
        path
      });
      throw error;
    }
  }

  private async handleStatusChange(
    oldTask: Task,
    newTask: Task
  ): Promise<void> {
    try {
      // Clear cache before status updates
      if ('clearCache' in this.storage) {
        await (this.storage as any).clearCache();
      }

      // Emit status change event
      this.eventManager.emit({
        type: EventTypes.TASK_STATUS_CHANGED,
        timestamp: Date.now(),
        taskId: newTask.path,
        task: newTask,
        changes: {
          before: { status: oldTask.status },
          after: { status: newTask.status }
        }
      });

      // Update parent task status if needed
      if (newTask.parentPath) {
        const parent = await this.storage.getTask(newTask.parentPath);
        if (parent) {
          const siblings = await this.storage.getSubtasks(parent.path);
          const allCompleted = siblings.every(t => t.status === TaskStatus.COMPLETED);
          const anyFailed = siblings.some(t => t.status === TaskStatus.FAILED);
          const anyBlocked = siblings.some(t => t.status === TaskStatus.BLOCKED);
          const anyInProgress = siblings.some(t => t.status === TaskStatus.IN_PROGRESS);

          let newParentStatus = parent.status;
          if (allCompleted) {
            newParentStatus = TaskStatus.COMPLETED;
          } else if (anyFailed) {
            newParentStatus = TaskStatus.FAILED;
          } else if (anyBlocked) {
            newParentStatus = TaskStatus.BLOCKED;
          } else if (anyInProgress) {
            newParentStatus = TaskStatus.IN_PROGRESS;
          }

          if (newParentStatus !== parent.status) {
            await this.updateTask(parent.path, {
              status: newParentStatus,
              metadata: {
                ...parent.metadata,
                statusUpdatedAt: Date.now(),
                previousStatus: parent.status
              }
            });
          }
        }
      }

      // Handle blocked status
      if (newTask.status === TaskStatus.BLOCKED) {
        await this.handleBlockedStatus(newTask);
      }

      // Handle completed status
      if (newTask.status === TaskStatus.COMPLETED) {
        await this.handleCompletedStatus(newTask);
      }

      // Handle failed status
      if (newTask.status === TaskStatus.FAILED) {
        await this.handleFailedStatus(newTask);
      }
    } catch (error) {
      this.logger.error('Failed to handle status change', {
        error,
        oldStatus: oldTask.status,
        newStatus: newTask.status,
        taskPath: newTask.path
      });
      throw error;
    }
  }

  private async handleFailedStatus(task: Task): Promise<void> {
    // Block dependent tasks when a task fails
    const dependentTasks = await this.storage.getDependentTasks(task.path);
    
    for (const depTask of dependentTasks) {
      if (depTask.status !== TaskStatus.FAILED) {
        await this.updateTask(depTask.path, {
          status: TaskStatus.BLOCKED,
            metadata: {
              ...depTask.metadata,
              blockedBy: task.path,
              blockReason: `Dependency task ${task.path} failed`,
              blockTimestamp: Date.now()
            }
        });
      }
    }
  }

  private async handleBlockedStatus(task: Task): Promise<void> {
    // Update dependent tasks to blocked status
    const dependentTasks = await this.storage.getDependentTasks(task.path);
    
    for (const depTask of dependentTasks) {
      if (depTask.status !== TaskStatus.BLOCKED) {
        await this.updateTask(depTask.path, {
          status: TaskStatus.BLOCKED,
            metadata: {
              ...depTask.metadata,
              blockedBy: task.path,
              blockTimestamp: Date.now()
            }
        });
      }
    }
  }

  private async handleCompletedStatus(task: Task): Promise<void> {
    // Check if dependent tasks can be unblocked
    const dependentTasks = await this.storage.getDependentTasks(task.path);
    
    for (const depTask of dependentTasks) {
      if (depTask.status === TaskStatus.BLOCKED) {
        // Check if all dependencies are completed
        const allDepsCompleted = await this.areAllDependenciesCompleted(depTask);
        
        if (allDepsCompleted) {
          await this.updateTask(depTask.path, {
            status: TaskStatus.PENDING,
            metadata: {
              ...depTask.metadata,
              blockedBy: undefined,
              blockTimestamp: undefined,
              unblockTimestamp: Date.now()
            }
          });
        }
      }
    }
  }

  private async areAllDependenciesCompleted(task: Task): Promise<boolean> {
    for (const depPath of task.dependencies) {
      const depTask = await this.storage.getTask(depPath);
      if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
        return false;
      }
    }
    return true;
  }
}

================
File: src/task/validation/index.ts
================
/**
 * Task validation module exports
 * Provides a centralized point for all task validation functionality
 */

import { z } from 'zod';
import { ValidationResult } from '../../types/index.js';

/**
 * Convert Zod validation error to ValidationResult format
 */
export function formatZodError(error: z.ZodError): ValidationResult {
    return {
        success: false,
        errors: error.errors.map(err => ({
            path: err.path.map(String),
            message: err.message,
            received: err instanceof z.ZodError ? err.code : undefined,
            expected: getExpectedValue(err)
        }))
    };
}

/**
 * Get expected value from Zod error
 */
function getExpectedValue(error: z.ZodIssue): string | undefined {
    switch (error.code) {
        case z.ZodIssueCode.invalid_type:
            return error.expected;
        case z.ZodIssueCode.invalid_enum_value:
            return error.options.join(' | ');
        case z.ZodIssueCode.too_small:
            return `${error.type === 'string' ? 'length' : 'value'} >= ${error.minimum}`;
        case z.ZodIssueCode.too_big:
            return `${error.type === 'string' ? 'length' : 'value'} <= ${error.maximum}`;
        default:
            return undefined;
    }
}

/**
 * Create a safe validator function that returns ValidationResult
 */
export function createSafeValidator<T>(schema: z.ZodType<T>) {
    return (value: unknown): ValidationResult & { value?: T } => {
        const result = schema.safeParse(value);
        if (result.success) {
            return {
                success: true,
                data: result.data
            };
        } else {
            return formatZodError(result.error);
        }
    };
}

/**
 * Create a validator function that throws on invalid input
 */
export function createValidator<T>(schema: z.ZodType<T>) {
    return (value: unknown): T => schema.parse(value);
}

/**
 * Validation error messages
 */
export const ValidationErrorMessages = {
    INVALID_INPUT: 'Invalid input provided',
    VALIDATION_FAILED: 'Validation failed',
    TYPE_ERROR: 'Type validation failed',
    CONSTRAINT_ERROR: 'Constraint validation failed',
    REQUIRED_FIELD: 'Required field is missing',
    INVALID_FORMAT: 'Invalid format',
    INVALID_VALUE: 'Invalid value provided',
    OUT_OF_RANGE: 'Value is out of allowed range',
    PATTERN_MISMATCH: 'Value does not match required pattern',
    UNIQUE_VIOLATION: 'Value must be unique',
    REFERENCE_ERROR: 'Invalid reference',
    CUSTOM_ERROR: 'Custom validation failed'
} as const;

/**
 * Validation utilities
 */
export const ValidationUtils = {
    /**
     * Check if a value is defined (not null or undefined)
     */
    isDefined: <T>(value: T | null | undefined): value is T => {
        return value !== null && value !== undefined;
    },

    /**
     * Check if a value is a non-empty string
     */
    isNonEmptyString: (value: unknown): value is string => {
        return typeof value === 'string' && value.trim().length > 0;
    },

    /**
     * Check if a value is a valid number
     */
    isValidNumber: (value: unknown): value is number => {
        return typeof value === 'number' && !isNaN(value) && isFinite(value);
    },

    /**
     * Check if a value is a valid integer
     */
    isValidInteger: (value: unknown): value is number => {
        return ValidationUtils.isValidNumber(value) && Number.isInteger(value);
    },

    /**
     * Check if a value is a valid date string
     */
    isValidDateString: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const date = new Date(value);
        return !isNaN(date.getTime());
    },

    /**
     * Check if a value is a valid UUID
     */
    isValidUUID: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(value);
    },

    /**
     * Check if a value is a valid email
     */
    isValidEmail: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(value);
    },

    /**
     * Check if a value is a valid URL
     */
    isValidURL: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        try {
            new URL(value);
            return true;
        } catch {
            return false;
        }
    },

    /**
     * Check if an array contains only unique values
     */
    hasUniqueValues: <T>(array: T[]): boolean => {
        return new Set(array).size === array.length;
    },

    /**
     * Check if an object has all required properties
     */
    hasRequiredProperties: (obj: unknown, properties: string[]): boolean => {
        if (typeof obj !== 'object' || obj === null) return false;
        return properties.every(prop => prop in obj);
    }
} as const;

export {
    TaskValidator,
    isValidTaskHierarchy,
    validateTaskStatusTransition,
    detectDependencyCycle,
    validateTask,
    validateCreateTaskInput,
    validateUpdateTaskInput,
    validateTaskResponse
} from './task-validator.js';

================
File: src/task/validation/task-validator.ts
================
import { Logger } from '../../logging/index.js';
import { TaskStorage } from '../../types/storage.js';
import { CreateTaskInput, UpdateTaskInput, TaskType, TaskStatus, CONSTRAINTS, Task } from '../../types/task.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { PathValidator } from '../../validation/index.js';
import { z } from 'zod';

// Task metadata schema (user-defined fields only)
const taskMetadataSchema = z.object({
    priority: z.enum(['low', 'medium', 'high']).optional(),
    tags: z.array(z.string().max(100)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    toolsUsed: z.array(z.string().max(100)).max(100).optional(),
    resourcesAccessed: z.array(z.string().max(100)).max(100).optional(),
    contextUsed: z.array(z.string().max(1000)).max(100).optional()
}).passthrough();

// Initialize path validator for schema validation
const pathValidator = new PathValidator({
    maxDepth: CONSTRAINTS.MAX_PATH_DEPTH,
    maxLength: 1000,
    allowedCharacters: /^[a-zA-Z0-9-_/]+$/,
    projectNamePattern: /^[a-zA-Z][a-zA-Z0-9-_]*$/,
    maxProjectNameLength: 100
});

// Base task schema with system fields at root level
const baseTaskSchema = z.object({
    // System fields
    path: z.string()
        .refine(
            (path) => {
                const result = pathValidator.validatePath(path);
                return result.isValid;
            },
            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid path format' })
        ),
    name: z.string().min(1).max(200),
    type: z.nativeEnum(TaskType),
    status: z.nativeEnum(TaskStatus),
    created: z.number(),
    updated: z.number(),
    version: z.number().positive(),
    projectPath: z.string().max(1000),

    // Optional fields
    description: z.string().max(2000).optional(),
    parentPath: z.string().optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50),
    subtasks: z.array(z.string()).max(100),

    // User-defined metadata
    metadata: taskMetadataSchema
});


/**
 * Validates parent-child task type relationships
 */
export function isValidTaskHierarchy(parentType: TaskType, childType: TaskType): { valid: boolean; reason?: string } {
    switch (parentType) {
        case TaskType.MILESTONE:
            // Milestones can contain tasks and groups
            return {
                valid: childType === TaskType.TASK || childType === TaskType.GROUP,
                reason: childType !== TaskType.TASK && childType !== TaskType.GROUP ?
                    `MILESTONE can only contain TASK or GROUP types, not ${childType}` : undefined
            };
        case TaskType.GROUP:
            // Groups can contain tasks
            return {
                valid: childType === TaskType.TASK,
                reason: childType !== TaskType.TASK ?
                    `GROUP can only contain TASK type, not ${childType}` : undefined
            };
        case TaskType.TASK:
            // Tasks cannot contain other tasks
            return {
                valid: false,
                reason: `TASK type cannot contain any subtasks (attempted to add ${childType})`
            };
        default:
            return {
                valid: false,
                reason: `Unknown task type: ${parentType}`
            };
    }
}

// Create task input schema
export const createTaskSchema = z.object({
    path: z.string()
        .refine(
            (path) => {
                const result = pathValidator.validatePath(path);
                return result.isValid;
            },
            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid path format' })
        ),
    name: z.string().min(1).max(200),
    parentPath: z.string()
        .refine(
            (path) => {
                const result = pathValidator.validatePath(path);
                return result.isValid;
            },
            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid parent path format' })
        )
        .optional(),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType).optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50).optional(),
    metadata: taskMetadataSchema.optional()
});

// Update task input schema
export const updateTaskSchema = z.object({
    name: z.string().min(1).max(200).optional(),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType).optional(),
    status: z.nativeEnum(TaskStatus).optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50).optional(),
    metadata: taskMetadataSchema.optional()
});

// Task response schema
export const taskResponseSchema = z.object({
    success: z.boolean(),
    data: z.unknown().optional(),
    error: z.object({
        code: z.string(),
        message: z.string()
    }).optional(),
    metadata: z.object({
        timestamp: z.number(),
        requestId: z.string(),
        projectPath: z.string(),
        affectedPaths: z.array(z.string())
    })
});

// Export type-safe validation functions
export function validateTask(task: unknown) {
    return baseTaskSchema.parse(task);
}

export function validateCreateTaskInput(input: unknown) {
    return createTaskSchema.parse(input);
}

export function validateUpdateTaskInput(input: unknown) {
    return updateTaskSchema.parse(input);
}

export function validateTaskResponse(response: unknown) {
    return taskResponseSchema.parse(response);
}

/**
 * Validates task status transitions and dependencies
 */
export async function validateTaskStatusTransition(
    task: z.infer<typeof baseTaskSchema>,
    newStatus: TaskStatus,
    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
): Promise<void> {
    // Cannot transition from COMPLETED/FAILED back to IN_PROGRESS
    if ((task.status === TaskStatus.COMPLETED || task.status === TaskStatus.FAILED) &&
        newStatus === TaskStatus.IN_PROGRESS) {
        throw createError(
            ErrorCodes.TASK_STATUS,
            `Cannot transition from ${task.status} to ${newStatus}`,
            'validateTaskStatusTransition',
            undefined,
            {
                taskPath: task.path,
                currentStatus: task.status,
                newStatus
            }
        );
    }

    // Check dependencies for COMPLETED status
    if (newStatus === TaskStatus.COMPLETED) {
        for (const depPath of task.dependencies) {
            const depTask = await getTaskByPath(depPath);
            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
                throw createError(
                    ErrorCodes.TASK_DEPENDENCY,
                    `Cannot complete task: dependency ${depPath} is not completed`,
                    'validateTaskStatusTransition',
                    undefined,
                    {
                        taskPath: task.path,
                        dependencyPath: depPath,
                        dependencyStatus: depTask?.status
                    }
                );
            }
        }
    }

    // Check dependencies for IN_PROGRESS status
    if (newStatus === TaskStatus.IN_PROGRESS) {
        const blockedByDeps = await isBlockedByDependencies(task, getTaskByPath);
        if (blockedByDeps) {
            throw createError(
                ErrorCodes.TASK_DEPENDENCY,
                'Cannot start task: blocked by incomplete dependencies',
                'validateTaskStatusTransition',
                undefined,
                {
                    taskPath: task.path,
                    dependencies: task.dependencies
                }
            );
        }
    }
}

/**
 * Checks if a task is blocked by its dependencies
 */
async function isBlockedByDependencies(
    task: z.infer<typeof baseTaskSchema>,
    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
): Promise<boolean> {
    for (const depPath of task.dependencies) {
        const depTask = await getTaskByPath(depPath);
        if (!depTask || depTask.status === TaskStatus.FAILED || 
            depTask.status === TaskStatus.BLOCKED || 
            depTask.status === TaskStatus.PENDING) {
            return true;
        }
    }
    return false;
}

/**
 * Detects circular dependencies in task relationships
 */
export async function detectDependencyCycle(
    task: z.infer<typeof baseTaskSchema>,
    newDeps: string[],
    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
): Promise<boolean> {
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    async function dfs(currentPath: string): Promise<boolean> {
        if (recursionStack.has(currentPath)) return true;
        if (visited.has(currentPath)) return false;

        visited.add(currentPath);
        recursionStack.add(currentPath);

        const current = await getTaskByPath(currentPath);
        if (!current) return false;

        // Check both existing and new dependencies
        const allDeps = currentPath === task.path ? newDeps : current.dependencies;
        for (const depPath of allDeps) {
            if (await dfs(depPath)) return true;
        }

        recursionStack.delete(currentPath);
        return false;
    }

    return await dfs(task.path);
}

export class TaskValidator {
  private readonly logger: Logger;
  private readonly pathValidator: PathValidator;

  constructor(private readonly storage: TaskStorage) {
    this.logger = Logger.getInstance().child({ component: 'TaskValidator' });
    this.pathValidator = new PathValidator({
      maxDepth: CONSTRAINTS.MAX_PATH_DEPTH,
      maxLength: 1000,
      allowedCharacters: /^[a-zA-Z0-9-_/]+$/,
      projectNamePattern: /^[a-zA-Z][a-zA-Z0-9-_]*$/,
      maxProjectNameLength: 100
    });
  }

  async validateCreate(input: CreateTaskInput): Promise<void> {
    try {
      // Validate required fields
      if (!input.name) {
        throw createError(
          ErrorCodes.INVALID_INPUT,
          'Task name is required'
        );
      }

      // Validate task type
      if (input.type && !Object.values(TaskType).includes(input.type)) {
        throw createError(
          ErrorCodes.INVALID_INPUT,
          `Invalid task type: ${input.type}`
        );
      }

      // Validate path and parent path
      const pathResult = input.parentPath ? 
        this.pathValidator.validateTaskPath(input.path, input.parentPath) :
        this.pathValidator.validatePath(input.path);

      if (!pathResult.isValid) {
        throw createError(
          ErrorCodes.INVALID_INPUT,
          pathResult.error || 'Invalid task path'
        );
      }

      // Validate parent path if provided
      if (input.parentPath) {
        const parent = await this.storage.getTask(input.parentPath);
        if (!parent) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            `Parent task not found: ${input.parentPath}`
          );
        }

        // Validate parent-child relationship
        if (parent.type === TaskType.TASK) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            'TASK type cannot have child tasks'
          );
        }
      }

      // Validate dependencies if provided
      if (input.dependencies?.length) {
        await this.validateDependencies(input.dependencies);
      }

      // Validate metadata if provided
      if (input.metadata) {
        this.validateMetadata(input.metadata);
      }
    } catch (error) {
      this.logger.error('Task creation validation failed', {
        error,
        input
      });
      throw error;
    }
  }

  async validateUpdate(path: string, updates: UpdateTaskInput): Promise<void> {
    try {
      const existingTask = await this.storage.getTask(path);
      if (!existingTask) {
        throw createError(
          ErrorCodes.TASK_NOT_FOUND,
          `Task not found: ${path}`
        );
      }

      // Validate task type change
      if (updates.type && updates.type !== existingTask.type) {
        // Check if task has children when changing to TASK type
        if (updates.type === TaskType.TASK) {
          const hasChildren = await this.storage.hasChildren(path);
          if (hasChildren) {
            throw createError(
              ErrorCodes.INVALID_INPUT,
              'Cannot change to TASK type when task has children'
            );
          }
        }
      }

      // Validate status value and change
      if (updates.status) {
        // Validate status enum value
        if (!Object.values(TaskStatus).includes(updates.status)) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            `Invalid status value: ${updates.status}`
          );
        }
        await this.validateStatusChange(updates.status, path);
      }

      // Validate dependencies change and check for cycles
      if (updates.dependencies) {
        await this.validateDependencies(updates.dependencies);
        const hasCycle = await detectDependencyCycle(
          existingTask,
          updates.dependencies,
          this.storage.getTask.bind(this.storage)
        );
        if (hasCycle) {
          throw createError(
            ErrorCodes.TASK_CYCLE,
            'Circular dependencies detected in task relationships'
          );
        }
      }

      // Validate metadata updates with schema
      if (updates.metadata) {
        try {
          taskMetadataSchema.parse(updates.metadata);
        } catch (error) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            `Invalid metadata: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
    } catch (error) {
      this.logger.error('Task update validation failed', {
        error,
        path,
        updates
      });
      throw error;
    }
  }

  private async validateDependencies(dependencies: string[]): Promise<void> {
    // Check for missing dependencies
    const missingDeps: string[] = [];
    for (const depPath of dependencies) {
      const depTask = await this.storage.getTask(depPath);
      if (!depTask) {
        missingDeps.push(depPath);
      }
    }

    if (missingDeps.length > 0) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        `Missing dependencies: ${missingDeps.join(', ')}`
      );
    }

    // Check for circular dependencies using shared utility
    const dummyTask: Task = {
      path: 'temp',
      name: 'Temporary Task',
      type: TaskType.TASK,
      status: TaskStatus.PENDING,
      created: Date.now(),
      updated: Date.now(),
      version: 1,
      projectPath: 'temp',
      dependencies: [],
      subtasks: [],
      metadata: {}
    };

    const hasCycle = await detectDependencyCycle(
      dummyTask,
      dependencies,
      this.storage.getTask.bind(this.storage)
    );

    if (hasCycle) {
      throw createError(
        ErrorCodes.TASK_CYCLE,
        'Circular dependencies detected in task relationships'
      );
    }
  }

  private async validateStatusChange(
    newStatus: TaskStatus,
    path: string
  ): Promise<void> {
    // Clear cache before validation
    if ('clearCache' in this.storage) {
      await (this.storage as any).clearCache();
    }

    const task = await this.storage.getTask(path);
    if (!task) {
      throw createError(
        ErrorCodes.TASK_NOT_FOUND,
        `Task not found: ${path}`
      );
    }

    // Validate version hasn't changed
    const currentTask = await this.storage.getTask(path);
    if (currentTask && currentTask.metadata.version !== task.metadata.version) {
      throw createError(
        ErrorCodes.CONCURRENT_MODIFICATION,
        'Task has been modified by another process'
      );
    }

    // Use shared validation utility
    await validateTaskStatusTransition(
      task,
      newStatus,
      this.storage.getTask.bind(this.storage)
    );

    // Check parent task constraints
    if (task.parentPath) {
      const parent = await this.storage.getTask(task.parentPath);
      if (parent) {
        const siblings = await this.storage.getSubtasks(parent.path);
        
        // Cannot complete if siblings are blocked
        if (newStatus === TaskStatus.COMPLETED && 
            siblings.some(s => s.status === TaskStatus.BLOCKED)) {
          throw createError(
            ErrorCodes.TASK_STATUS,
            'Cannot complete task while sibling tasks are blocked'
          );
        }

        // Cannot start if siblings have failed
        if (newStatus === TaskStatus.IN_PROGRESS && 
            siblings.some(s => s.status === TaskStatus.FAILED)) {
          throw createError(
            ErrorCodes.TASK_STATUS,
            'Cannot start task while sibling tasks have failed'
          );
        }
      }
    }
  }

  private validateMetadata(metadata: Record<string, unknown>): void {
    // Add any specific metadata validation rules here
    // For now, just ensure it's an object
    if (typeof metadata !== 'object' || metadata === null) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Metadata must be an object'
      );
    }
  }

}

================
File: src/tools/handler.ts
================
/**
 * Path-based task management tools
 */
import { TaskManager } from '../task-manager.js';
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { TaskType, TaskStatus, CreateTaskInput, UpdateTaskInput } from '../types/task.js';
import {
    createTaskSchema,
    updateTaskSchema,
    getTasksByStatusSchema,
    getTasksByPathSchema,
    getSubtasksSchema,
    deleteTaskSchema,
    bulkTaskSchema,
    clearAllTasksSchema,
    vacuumDatabaseSchema,
    repairRelationshipsSchema
} from './schemas.js';
import { DependencyAwareBatchProcessor } from '../task/core/batch/dependency-aware-batch-processor.js';

interface BulkOperation {
    type: 'create' | 'update' | 'delete';
    path: string;
    data?: Record<string, unknown>;
    id?: string;
    dependencies?: string[];
}

export interface Tool {
    name: string;
    description?: string;
    inputSchema: {
        type: "object";
        properties: Record<string, unknown>;
        required?: string[];
        description?: string;
    };
}

export interface ToolResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

export class ToolHandler {
    private readonly logger: Logger;
    private readonly tools: Map<string, Tool> = new Map();
    private readonly toolHandlers: Map<string, (args: Record<string, unknown>) => Promise<ToolResponse>> = new Map();

    constructor(private readonly taskManager: TaskManager) {
        this.logger = Logger.getInstance().child({ component: 'ToolHandler' });
        this.registerDefaultTools();
    }

    /**
     * Validates task hierarchy rules
     */
    private async validateTaskHierarchy(args: Record<string, unknown>, operation: 'create' | 'update'): Promise<void> {
        const taskType = (args.type || 'TASK').toString().toUpperCase();
        const parentPath = args.parentPath as string | undefined;

        // Validate task type is uppercase
        if (taskType !== taskType.toUpperCase()) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Task type must be uppercase (TASK, GROUP, or MILESTONE)'
            );
        }

        // Validate task type is valid
        if (!['TASK', 'GROUP', 'MILESTONE'].includes(taskType)) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Invalid task type. Must be TASK, GROUP, or MILESTONE'
            );
        }

        // If parent path is provided, validate parent type compatibility
        if (parentPath) {
            const parent = await this.taskManager.getTaskByPath(parentPath);
            if (!parent) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    `Parent task '${parentPath}' not found`
                );
            }

            // Validate parent-child type relationships
            switch (parent.type) {
                case TaskType.MILESTONE:
                    if (!['TASK', 'GROUP'].includes(taskType)) {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'MILESTONE can only contain TASK or GROUP types'
                        );
                    }
                    break;
                case TaskType.GROUP:
                    if (taskType !== 'TASK') {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'GROUP can only contain TASK types'
                        );
                    }
                    break;
                case TaskType.TASK:
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'TASK type cannot contain subtasks'
                    );
            }
        }

        // For updates, validate type changes don't break hierarchy
        if (operation === 'update' && taskType) {
            const path = args.path as string;
            const task = await this.taskManager.getTaskByPath(path);
            if (!task) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    `Task '${path}' not found`
                );
            }

            // Check if task has subtasks and is being changed to TASK type
            if (taskType === 'TASK') {
                const subtasks = await this.taskManager.getSubtasks(path);
                if (subtasks.length > 0) {
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'Cannot change to TASK type while having subtasks'
                    );
                }
            }

            // Check if changing to GROUP with non-TASK subtasks
            if (taskType === 'GROUP') {
                const subtasks = await this.taskManager.getSubtasks(path);
                const invalidSubtasks = subtasks.filter(s => s.type !== TaskType.TASK);
                if (invalidSubtasks.length > 0) {
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'GROUP can only contain TASK type subtasks'
                    );
                }
            }
        }
    }

    private registerDefaultTools(): void {
        const defaultTools: Array<Tool & { handler: (args: Record<string, unknown>) => Promise<ToolResponse> }> = [
            {
                name: 'create_task',
                description: createTaskSchema.properties.type.description,
                inputSchema: {
                    type: "object",
                    properties: createTaskSchema.properties,
                    required: createTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    // Validate hierarchy rules
                    await this.validateTaskHierarchy(args, 'create');
                    
                    // Create task input with proper type casting
                    const taskInput: CreateTaskInput = {
                        name: args.name as string,
                        path: args.path as string, // Path is now required
                        type: args.type ? (args.type as string).toUpperCase() as TaskType : undefined,
                        description: args.description as string | undefined,
                        parentPath: args.parentPath as string | undefined,
                        dependencies: Array.isArray(args.dependencies) ? args.dependencies as string[] : [],
                        notes: Array.isArray(args.notes) ? args.notes as string[] : undefined,
                        reasoning: args.reasoning as string | undefined,
                        metadata: args.metadata as Record<string, unknown> || {}
                    };
                    
                    const result = await this.taskManager.createTask(taskInput);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'update_task',
                description: updateTaskSchema.properties.updates.properties.type.description,
                inputSchema: {
                    type: "object",
                    properties: updateTaskSchema.properties,
                    required: updateTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const { path, updates } = args as { path: string; updates: Record<string, unknown> };
                    
                    // Validate hierarchy rules if type is being updated
                    if (updates.type) {
                        await this.validateTaskHierarchy({ ...updates, path }, 'update');
                    }
                    
                    // Create update input with proper type casting
                    const updateInput: UpdateTaskInput = {
                        name: updates.name as string | undefined,
                        type: updates.type ? (updates.type as string).toUpperCase() as TaskType : undefined,
                        description: updates.description as string | undefined,
                        status: updates.status as TaskStatus | undefined,
                        dependencies: Array.isArray(updates.dependencies) ? updates.dependencies as string[] : undefined,
                        notes: Array.isArray(updates.notes) ? updates.notes as string[] : undefined,
                        reasoning: updates.reasoning as string | undefined,
                        metadata: updates.metadata as Record<string, unknown> | undefined
                    };
                    
                    const result = await this.taskManager.updateTask(path, updateInput);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_tasks_by_status',
                description: getTasksByStatusSchema.properties.status.description,
                inputSchema: {
                    type: "object",
                    properties: getTasksByStatusSchema.properties,
                    required: getTasksByStatusSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.getTasksByStatus(args.status as unknown as TaskStatus);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_tasks_by_path',
                description: getTasksByPathSchema.properties.pathPattern.description,
                inputSchema: {
                    type: "object",
                    properties: getTasksByPathSchema.properties,
                    required: getTasksByPathSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.listTasks(args.pathPattern as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_subtasks',
                description: getSubtasksSchema.properties.path.description,
                inputSchema: {
                    type: "object",
                    properties: getSubtasksSchema.properties,
                    required: getSubtasksSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.getSubtasks(args.path as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'delete_task',
                description: deleteTaskSchema.properties.path.description,
                inputSchema: {
                    type: "object",
                    properties: deleteTaskSchema.properties,
                    required: deleteTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.deleteTask(args.path as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'bulk_task_operations',
                description: bulkTaskSchema.properties.operations.description,
                inputSchema: {
                    type: "object",
                    properties: bulkTaskSchema.properties,
                    required: bulkTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const { operations } = args as { operations: BulkOperation[] };

                    // Add dependencies based on operation order
                    const operationsWithDeps = operations.map((op, index) => ({
                        ...op,
                        id: op.path,
                        // Each operation depends on the previous one
                        dependencies: index > 0 ? [operations[index - 1].path] : []
                    }));

                    const batchProcessor = new DependencyAwareBatchProcessor({
                        validator: null,
                        logger: this.logger,
                        storage: this.taskManager.storage
                    }, {
                        maxBatchSize: 1,
                        concurrentBatches: 1,
                        maxRetries: 3,
                        retryDelay: 1000
                    });
                    
                    // Process operations sequentially with dependency ordering
                    const result = await batchProcessor.processInBatches(
                        operationsWithDeps.map(op => ({ id: op.path, data: op })),
                        1,
                        async (operation) => {
                            const op = operation.data as BulkOperation;
                        try {
                            switch (op.type) {
                                case 'create': {
                                    // Extract parent path from task path if not provided
                                    const pathSegments = op.path.split('/');
                                    const parentPath = op.data?.parentPath as string || 
                                        (pathSegments.length > 1 ? pathSegments.slice(0, -1).join('/') : undefined);

                                    const taskData: CreateTaskInput = {
                                        path: op.path,
                                        name: op.data?.name as string || pathSegments[pathSegments.length - 1] || 'Unnamed Task',
                                        type: (op.data?.type as string || 'TASK').toUpperCase() as TaskType,
                                        description: op.data?.description as string,
                                        dependencies: op.data?.dependencies as string[] || [],
                                        parentPath,
                                        metadata: {
                                            ...(op.data?.metadata || {}),
                                            created: Date.now(),
                                            updated: Date.now()
                                        }
                                    };

                                    // Validate hierarchy rules
                                    await this.validateTaskHierarchy(taskData, 'create');

                                    await this.taskManager.createTask(taskData);
                                    break;
                                }
                                case 'update': {
                                    const updateData: UpdateTaskInput = {
                                        status: op.data?.status as TaskStatus,
                                        metadata: op.data?.metadata as Record<string, unknown>,
                                        notes: op.data?.notes as string[],
                                        dependencies: op.data?.dependencies as string[],
                                        description: op.data?.description as string,
                                        name: op.data?.name as string,
                                        type: op.data?.type ? (op.data.type as string).toUpperCase() as TaskType : undefined
                                    };

                                    // Validate hierarchy rules if type is being updated
                                    if (updateData.type) {
                                        await this.validateTaskHierarchy({ ...updateData, path: op.path }, 'update');
                                    }

                                    await this.taskManager.updateTask(op.path, updateData);
                                    break;
                                }
                                case 'delete':
                                    await this.taskManager.deleteTask(op.path);
                                    break;
                                default:
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        `Invalid operation type: ${op.type}`
                                    );
                            }
                        } catch (error) {
                            this.logger.error('Operation failed', {
                                operation: op,
                                error
                            });
                            throw error;
                        }
                    });

                    return this.formatResponse({
                        success: result.metadata?.successCount === operationsWithDeps.length,
                        processedCount: result.metadata?.successCount || 0,
                        failedCount: result.metadata?.errorCount || 0,
                        errors: result.errors.map(err => ({
                            operation: err,
                            error: err.message,
                            context: undefined
                        }))
                    });
                }
            },
            {
                name: 'clear_all_tasks',
                description: clearAllTasksSchema.properties.confirm.description,
                inputSchema: {
                    type: "object",
                    properties: clearAllTasksSchema.properties,
                    required: clearAllTasksSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    await this.taskManager.clearAllTasks(args.confirm as boolean);
                    return this.formatResponse({ success: true, message: 'All tasks cleared' });
                }
            },
            {
                name: 'vacuum_database',
                description: vacuumDatabaseSchema.properties.analyze.description,
                inputSchema: {
                    type: "object",
                    properties: vacuumDatabaseSchema.properties,
                    required: vacuumDatabaseSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    await this.taskManager.vacuumDatabase(args.analyze as boolean);
                    return this.formatResponse({ success: true, message: 'Database optimized' });
                }
            },
            {
                name: 'repair_relationships',
                description: repairRelationshipsSchema.properties.dryRun.description,
                inputSchema: {
                    type: "object",
                    properties: repairRelationshipsSchema.properties,
                    required: repairRelationshipsSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.repairRelationships(
                        args.dryRun as boolean,
                        args.pathPattern as string | undefined
                    );
                    return this.formatResponse(result);
                }
            }
        ];

        for (const tool of defaultTools) {
            this.registerTool(tool);
        }
    }

    private registerTool(tool: Tool & { handler: (args: Record<string, unknown>) => Promise<ToolResponse> }): void {
        const { handler, ...toolDef } = tool;
        this.tools.set(tool.name, toolDef);
        this.toolHandlers.set(tool.name, handler);
        this.logger.debug('Registered tool', { name: tool.name });
    }

    async listTools(): Promise<{ tools: Tool[] }> {
        const tools = Array.from(this.tools.values());
        this.logger.info('Listed tools', { 
            count: tools.length,
            tools: tools.map(t => ({
                name: t.name,
                schema: t.inputSchema
            }))
        });
        return { tools };
    }

    async handleToolCall(request: { params: { name: string; arguments?: Record<string, unknown> } }): Promise<{
        _meta?: Record<string, unknown>;
        content: Array<{ type: string; text: string }>;
    }> {
        const { name, arguments: args = {} } = request.params;

        const tool = this.tools.get(name);
        if (!tool) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Unknown tool',
                'handleToolCall',
                undefined,
                { tool: name }
            );
        }

        const handler = this.toolHandlers.get(name);
        if (!handler) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Tool handler not found',
                'handleToolCall',
                undefined,
                { tool: name }
            );
        }

        try {
            // Validate dependencies are at root level
            if ((name === 'create_task' || name === 'update_task') && 
                (args as any).metadata?.dependencies) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    'Dependencies must be specified at root level, not in metadata'
                );
            }

            this.logger.debug('Executing tool', { name, args });
            const result = await handler(args);
            this.logger.debug('Tool execution completed', { name });
            return {
                _meta: {},
                ...result
            };
        } catch (error) {
            this.logger.error('Tool execution failed', {
                tool: name,
                error
            });
            throw error;
        }
    }

    async getStorageMetrics(): Promise<any> {
        return await this.taskManager.storage.getMetrics();
    }

    private formatResponse(result: unknown): ToolResponse {
        try {
            const sanitizedResult = JSON.parse(JSON.stringify(result, (key, value) => {
                if (typeof value === 'bigint') {
                    return value.toString();
                }
                if (key.toLowerCase().includes('secret') || 
                    key.toLowerCase().includes('password') ||
                    key.toLowerCase().includes('token')) {
                    return undefined;
                }
                return value;
            }));

            return {
                content: [{
                    type: 'text',
                    text: JSON.stringify(sanitizedResult, null, 2)
                }]
            };
        } catch (error) {
            this.logger.error('Failed to format response', { error });
            throw createError(
                ErrorCodes.INTERNAL_ERROR,
                'Failed to format response'
            );
        }
    }
}

================
File: src/tools/index.ts
================
/**
 * Tools module exports
 * Centralizes exports for tools-related functionality
 */

export * from './handler.js';
export * from './schemas.js';
export * from './utils.js';

================
File: src/tools/schemas.ts
================
/**
 * Path-based task management schemas for LLM agents
 */
import { TaskStatus, CONSTRAINTS } from '../types/task.js';

// Schema validation messages
const VALIDATION_MESSAGES = {
    PATH_FORMAT: 'Path can only contain alphanumeric characters, underscores, dots, and hyphens',
    PATH_DEPTH: `Path depth cannot exceed ${CONSTRAINTS.MAX_PATH_DEPTH} levels`,
    NAME_LENGTH: `Name cannot exceed ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
    DESC_LENGTH: `Description cannot exceed ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
    NOTE_LENGTH: `Notes cannot exceed ${CONSTRAINTS.NOTE_MAX_LENGTH} characters each`,
    REASONING_LENGTH: `Reasoning cannot exceed ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
    DEPENDENCIES_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_DEPENDENCIES} dependencies`,
    SUBTASKS_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_SUBTASKS} subtasks`,
    NOTES_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_NOTES} notes`,
    METADATA_LENGTH: `Metadata string fields cannot exceed ${CONSTRAINTS.METADATA_STRING_MAX_LENGTH} characters`,
    METADATA_ARRAY: `Metadata arrays cannot exceed ${CONSTRAINTS.MAX_ARRAY_ITEMS} items`
};

/** Creates a new task with path-based hierarchy and validation */
export const createTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Hierarchical task path (e.g., "server/api/authentication"). Use paths to organize related tasks.\n' +
                        `Constraints:\n` +
                        `- ${VALIDATION_MESSAGES.PATH_FORMAT}\n` +
                        `- ${VALIDATION_MESSAGES.PATH_DEPTH}`,
            pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$',
            maxLength: CONSTRAINTS.MAX_PATH_DEPTH * 50 // Reasonable max length per segment
        },
        name: {
            type: 'string',
            description: 'Clear, action-oriented task name (e.g., "Implement JWT authentication", "Refactor database queries").\n' +
                        `Maximum length: ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
            maxLength: CONSTRAINTS.NAME_MAX_LENGTH
        },
        parentPath: {
            type: 'string',
            description: 'Path of the parent task. Parent must be MILESTONE or GROUP type.\n' +
                        'Examples:\n' +
                        '- "project/backend" (under project backend milestone)\n' +
                        '- "project/backend/auth" (under auth group)',
        },
        description: {
            type: 'string',
            description: 'Detailed task description including:\n' +
                        '- Objective: What needs to be accomplished\n' +
                        '- Context: Why this task is needed\n' +
                        '- Technical details: Implementation considerations\n' +
                        '- Success criteria: How to verify completion\n' +
                        `Maximum length: ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
            maxLength: CONSTRAINTS.DESCRIPTION_MAX_LENGTH
        },
        type: {
            type: 'string',
            enum: ['TASK', 'MILESTONE', 'GROUP'],
            description: ' Task Type Hierarchy Rules (MUST BE UPPERCASE):\n\n' +
                        '1. MILESTONE (Top Level Container):\n' +
                        '    CAN contain: TASK and GROUP types\n' +
                        '    Purpose: Project phases, major deliverables\n' +
                        '    Example: "Backend Development", "Security Hardening"\n' +
                        '    Status: Completed when all subtasks done\n\n' +
                        '2. GROUP (Middle Level Container):\n' +
                        '    CAN contain: Only TASK types\n' +
                        '    CANNOT contain: Other GROUPs or MILESTONEs\n' +
                        '    Purpose: Feature sets, related task collections\n' +
                        '    Example: "Authentication Features", "API Endpoints"\n' +
                        '    Status: Reflects aggregate of subtask states\n\n' +
                        '3. TASK (Leaf Level):\n' +
                        '    CANNOT contain any subtasks\n' +
                        '    Purpose: Atomic units of work\n' +
                        '    Example: "Implement JWT", "Add Rate Limiting"\n' +
                        '    Status: Independently managed\n\n' +
                        'Common Errors to Avoid:\n' +
                        '- Adding subtasks to TASK type\n' +
                        '- Adding non-TASK items under GROUP\n' +
                        '- Creating circular dependencies\n' +
                        '- Exceeding path depth limits',
        },
        dependencies: {
            type: 'array',
            items: { 
                type: 'string',
                pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$'
            },
            maxItems: CONSTRAINTS.MAX_DEPENDENCIES,
            description: 'Paths of tasks that must be completed first. Tasks will be automatically blocked if dependencies are not met.\n' +
                        `Maximum dependencies: ${CONSTRAINTS.MAX_DEPENDENCIES}\n` +
                        'Dependencies can be specified here (recommended) or in metadata.dependencies (legacy).',
            uniqueItems: true
        },
        metadata: {
            type: 'object',
            properties: {
                priority: {
                    type: 'string',
                    enum: ['low', 'medium', 'high'],
                    description: 'Task urgency and impact level. Affects task ordering and scheduling.'
                },
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    maxItems: CONSTRAINTS.MAX_ARRAY_ITEMS,
                    description: 'Keywords for categorization and filtering (e.g., ["api", "security", "optimization"]). Used in path pattern matching.\n' +
                                `Maximum tags: ${CONSTRAINTS.MAX_ARRAY_ITEMS}`,
                    uniqueItems: true
                },
                assignee: {
                    type: 'string',
                    description: 'System or component responsible for the task. Used for task distribution and filtering.'
                },
                reasoning: {
                    type: 'string',
                    description: 'LLM reasoning about task decisions, importance, and approach. Provides context for status changes and dependencies.\n' +
                                `Maximum length: ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.REASONING_MAX_LENGTH
                },
                notes: {
                    type: 'array',
                    items: { 
                        type: 'string',
                        maxLength: CONSTRAINTS.NOTE_MAX_LENGTH
                    },
                    maxItems: CONSTRAINTS.MAX_NOTES,
                    description: 'Additional context, observations, and planning notes. Used to track progress and document decisions.\n' +
                                `Maximum notes: ${CONSTRAINTS.MAX_NOTES}\n` +
                                `Maximum length per note: ${CONSTRAINTS.NOTE_MAX_LENGTH} characters`
                }
            },
            description: 'Additional task context and tracking information. Fields affect:\n' +
                        '- Task organization (priority, tags, assignee)\n' +
                        '- Progress tracking (notes)\n' +
                        '- Decision history (reasoning)\n\n' +
                        'Note: dependencies in metadata.dependencies will be migrated to the main dependencies array.',
        }
    },
    required: ['name', 'path'],
};

/** Updates an existing task */
export const updateTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Path of the task to update.',
        },
        updates: {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'Updated task name with current action focus.\n' +
                                `Maximum length: ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.NAME_MAX_LENGTH
                },
                description: {
                    type: 'string',
                    description: 'Updated description with latest context, findings, and next steps.\n' +
                                `Maximum length: ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.DESCRIPTION_MAX_LENGTH
                },
                type: {
                    type: 'string',
                    enum: ['TASK', 'MILESTONE', 'GROUP'],
                    description: ' Task Type Rules (MUST BE UPPERCASE):\n' +
                                '- MILESTONE can contain TASK and GROUP\n' +
                                '- GROUP can only contain TASK\n' +
                                '- TASK cannot contain subtasks\n' +
                                'Changing type may require restructuring subtasks.',
                },
                status: {
                    type: 'string',
                    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                    description: 'Current execution state:\n' +
                               '- PENDING: Not yet started\n' +
                               '- IN_PROGRESS: Currently being processed\n' +
                               '- COMPLETED: Successfully finished\n' +
                               '- FAILED: Encountered unresolvable issues\n' +
                               '- BLOCKED: Waiting on dependencies or external factors\n\n' +
                               'Status Propagation Rules:\n' +
                               '- MILESTONE: Completed when all subtasks done\n' +
                               '- GROUP: Status based on subtask states\n' +
                               '- TASK: Independent status management',
                },
                dependencies: {
                    type: 'array',
                    items: { 
                        type: 'string',
                        pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$'
                    },
                    maxItems: CONSTRAINTS.MAX_DEPENDENCIES,
                    description: 'Updated task dependencies. Tasks will be automatically blocked if new dependencies are not met.\n' +
                                `Maximum dependencies: ${CONSTRAINTS.MAX_DEPENDENCIES}\n` +
                                'Status changes propagate through dependency chain.',
                    uniqueItems: true
                },
                metadata: {
                    type: 'object',
                    properties: {
                        priority: {
                            type: 'string',
                            enum: ['low', 'medium', 'high'],
                            description: 'Task urgency and impact level. Affects task ordering and scheduling.'
                        },
                        tags: {
                            type: 'array',
                            items: { type: 'string' },
                            maxItems: CONSTRAINTS.MAX_ARRAY_ITEMS,
                            description: 'Keywords for categorization and filtering (e.g., ["api", "security", "optimization"]). Used in path pattern matching.\n' +
                                      `Maximum tags: ${CONSTRAINTS.MAX_ARRAY_ITEMS}`,
                            uniqueItems: true
                        },
                        assignee: {
                            type: 'string',
                            description: 'Updated system/component assignment'
                        },
                        reasoning: {
                            type: 'string',
                            description: 'LLM reasoning about task decisions, importance, and approach. Provides context for status changes and dependencies.\n' +
                                      `Maximum length: ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
                            maxLength: CONSTRAINTS.REASONING_MAX_LENGTH
                        },
                        notes: {
                            type: 'array',
                            items: { 
                                type: 'string',
                                maxLength: CONSTRAINTS.NOTE_MAX_LENGTH
                            },
                            maxItems: CONSTRAINTS.MAX_NOTES,
                            description: 'Additional context, observations, and planning notes. Used to track progress and document decisions.\n' +
                                      `Maximum notes: ${CONSTRAINTS.MAX_NOTES}\n` +
                                      `Maximum length per note: ${CONSTRAINTS.NOTE_MAX_LENGTH} characters`
                        }
                    },
                    description: 'Task metadata fields affect:\n' +
                                '- Task organization (priority, tags, assignee)\n' +
                                '- Progress tracking (notes)\n' +
                                '- Decision history (reasoning)',
                },
            },
            description: 'Fields to update. Available fields:\n' +
                        '- name: Update task name\n' +
                        '- description: Update task details\n' +
                        '- type: Change task type (task/milestone/group)\n' +
                        '- status: Update execution state with automatic dependency checks\n' +
                        '- dependencies: Add/remove dependencies with validation\n' +
                        '- metadata: Update task metadata (priority, tags, notes, etc.)\n\n' +
                        'Status changes trigger:\n' +
                        '- Automatic dependency validation\n' +
                        '- Status propagation to parent tasks\n' +
                        '- Dependent task blocking\n' +
                        '- Child task status updates',
        },
    },
    required: ['path', 'updates'],
};

/** Gets tasks by status */
export const getTasksByStatusSchema = {
    type: 'object',
    properties: {
        status: {
            type: 'string',
            enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'] as TaskStatus[],
            description: 'Filter tasks by their execution state. Use to find tasks needing attention or verify completion.',
        },
        pathPattern: {
            type: 'string',
            description: 'Optional glob pattern to filter by path (e.g., "server/api/*"). Use to focus on specific subsystems.',
        }
    },
    required: ['status'],
};

/** Gets tasks by path pattern */
export const getTasksByPathSchema = {
    type: 'object',
    properties: {
        pathPattern: {
            type: 'string',
            description: 'Glob pattern to match task paths. Use to analyze specific areas of work (e.g., "server/*/security/*").',
        }
    },
    required: ['pathPattern'],
};

/** Gets subtasks of a task */
export const getSubtasksSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Parent task path. Returns immediate subtasks to analyze task breakdown and progress.',
        }
    },
    required: ['path'],
};

/** Deletes a task */
export const deleteTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Task path to delete. Will recursively remove all subtasks. Use with caution.',
        }
    },
    required: ['path'],
};

/** Clears all tasks from the database */
export const clearAllTasksSchema = {
    type: 'object',
    properties: {
        confirm: {
            type: 'boolean',
            description: 'Must be set to true to confirm deletion of all tasks. This operation cannot be undone.',
        }
    },
    required: ['confirm'],
};

/** Optimizes database storage and performance */
export const vacuumDatabaseSchema = {
    type: 'object',
    properties: {
        analyze: {
            type: 'boolean',
            description: 'Whether to analyze tables for query optimization after vacuum.',
            default: true
        }
    },
    required: [],
};

/** Repairs parent-child relationships and fixes inconsistencies */
export const repairRelationshipsSchema = {
    type: 'object',
    properties: {
        dryRun: {
            type: 'boolean',
            description: 'If true, only reports issues without fixing them.',
            default: false
        },
        pathPattern: {
            type: 'string',
            description: 'Optional glob pattern to limit repair scope (e.g., "project/*").'
        }
    },
    required: [],
};

/** Bulk task operations with validation */
export const bulkTaskSchema = {
    type: 'object',
    properties: {
        operations: {
            type: 'array',
            description: 'Sequence of atomic task operations. Use for coordinated updates and maintaining task relationships.',
            items: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['create', 'update', 'delete'],
                        description: 'Operation type:\n' +
                                   '- create: Add new task with full context\n' +
                                   '- update: Modify task with latest findings\n' +
                                   '- delete: Remove completed or obsolete task'
                    },
                    path: {
                        type: 'string',
                        description: 'Task path for the operation. For create, this sets the desired hierarchy.\n' +
                                   `Constraints:\n` +
                                   `- ${VALIDATION_MESSAGES.PATH_FORMAT}\n` +
                                   `- ${VALIDATION_MESSAGES.PATH_DEPTH}`,
                        pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$',
                        maxLength: CONSTRAINTS.MAX_PATH_DEPTH * 50
                    },
                    data: {
                        type: 'object',
                        description: 'Operation-specific data:\n' +
                                   '- create: Full task definition including dependencies and context\n' +
                                   '- update: Fields to modify including status and dependencies\n' +
                                   '- delete: Optional deletion context\n\n' +
                                   'Dependency handling:\n' +
                                   '- Dependencies are validated across all operations\n' +
                                   '- Status changes respect dependency constraints\n' +
                                   '- Circular dependencies are prevented\n' +
                                   '- Failed operations trigger rollback'
                    },
                },
                required: ['type', 'path'],
            },
        },
    },
    required: ['operations'],
};

================
File: src/tools/session-schemas.ts
================
/**
 * Session and Task List Management Schemas
 * Defines schemas for managing work sessions and task organization
 */

/** Creates a new task list in the current session. IMPORTANT: Requires an active session - use create_session first if you haven't already. Task lists organize related tasks and provide structure for task management. */
export const createTaskListSchema = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Name of the task list. Best practice: Use descriptive names that reflect the purpose or theme (e.g., "Q1 Feature Development", "Security Improvements").',
        },
        description: {
            type: 'string',
            description: 'Description of the task list. Best practice: Include goals, success criteria, and any relevant timelines or constraints.',
        },
        metadata: {
            type: 'object',
            properties: {
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags for categorizing the task list. Best practice: Use consistent prefixes (e.g., "project:", "team:", "quarter:") for better organization.',
                },
                context: {
                    type: 'string',
                    description: 'Additional context about the task list. Best practice: Include links to project documentation, milestones, or related resources.',
                }
            },
            description: 'Additional task list metadata. Best practice: Use for cross-referencing and organization.',
        },
        persistent: {
            type: 'boolean',
            description: 'Whether the task list should persist across sessions. Best practice: Use true for long-term projects, false for temporary task groupings.',
            default: true
        }
    },
    required: ['name'],
};

/** Switches to a different task list in the current session */
export const switchTaskListSchema = {
    type: 'object',
    properties: {
        taskListId: {
            type: 'string',
            description: 'ID of the task list to switch to. Best practice: Verify task list exists and contains active tasks before switching.',
        }
    },
    required: ['taskListId'],
};

/** Lists all task lists in the current session */
export const listTaskListsSchema = {
    type: 'object',
    properties: {
        includeArchived: {
            type: 'boolean',
            description: 'Whether to include archived task lists. Best practice: Use true when reviewing historical data or reactivating old projects.',
            default: false
        }
    }
};

/** Archives a task list */
export const archiveTaskListSchema = {
    type: 'object',
    properties: {
        taskListId: {
            type: 'string',
            description: 'ID of the task list to archive. Best practice: Ensure all tasks are completed or properly transferred before archiving.',
        }
    },
    required: ['taskListId'],
};

/** Creates a new session. IMPORTANT: This must be called first before any task operations can be performed. A session provides the required context for managing tasks and task lists. */
export const createSessionSchema = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Name of the session. Best practice: Use descriptive names that include purpose and date (e.g., "Feature Development - March 2024").',
        },
        metadata: {
            type: 'object',
            properties: {
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags for categorizing the session. Best practice: Include project phase, team, and priority indicators.',
                },
                context: {
                    type: 'string',
                    description: 'Additional context about the session. Best practice: Document goals, participants, and key decisions made during the session.',
                }
            },
            description: 'Additional session metadata. Best practice: Use for tracking session objectives and outcomes.',
        }
    },
    required: ['name'],
};

/** Switches to a different session */
export const switchSessionSchema = {
    type: 'object',
    properties: {
        sessionId: {
            type: 'string',
            description: 'ID of the session to switch to. Best practice: Save any pending changes in current session before switching.',
        }
    },
    required: ['sessionId'],
};

/** Lists all available sessions */
export const listSessionsSchema = {
    type: 'object',
    properties: {
        includeArchived: {
            type: 'boolean',
            description: 'Whether to include archived sessions. Best practice: Use for auditing or reviewing historical work patterns.',
            default: false
        }
    }
};

/** Archives a session */
export const archiveSessionSchema = {
    type: 'object',
    properties: {
        sessionId: {
            type: 'string',
            description: 'ID of the session to archive. Best practice: Document session outcomes and ensure all task lists are properly resolved before archiving.'
        }
    },
    required: ['sessionId']
};

/**
 * Best Practices for Session Management:
 * 
 * 1. Session Organization:
 *    - Create sessions for focused work periods or project phases
 *    - Use consistent naming conventions for better tracking
 *    - Document session goals and outcomes
 * 
 * 2. Task List Management:
 *    - Group related tasks into logical task lists
 *    - Keep task lists focused and manageable
 *    - Use metadata and tags for easy filtering
 * 
 * 3. Archiving Strategy:
 *    - Archive completed sessions with proper documentation
 *    - Ensure all tasks are resolved before archiving
 *    - Use archiving for maintaining clean workspace
 * 
 * 4. Metadata Usage:
 *    - Use consistent tag prefixes
 *    - Include relevant links and context
 *    - Track important decisions and rationale
 * 
 * 5. Session Switching:
 *    - Save work before switching sessions
 *    - Verify task list status when switching
 *    - Maintain context between sessions
 */

================
File: src/tools/utils.ts
================
/**
 * Utility functions for tool operations
 */

/**
 * Formats a response object for consistent output
 * @param response The response object to format
 * @returns Formatted response string
 */
export function formatResponse(response: unknown): string {
    return JSON.stringify(response, null, 2);
}

/**
 * Validates that required parameters are present in a request
 * @param params The parameters object to validate
 * @param required Array of required parameter names
 * @throws Error if any required parameter is missing
 */
export function validateRequiredParams(params: Record<string, unknown>, required: string[]): void {
    for (const param of required) {
        if (!(param in params)) {
            throw new Error(`Missing required parameter: ${param}`);
        }
    }
}

/**
 * Sanitizes a string for safe usage
 * @param input The string to sanitize
 * @returns Sanitized string
 */
export function sanitizeString(input: string): string {
    return input.trim();
}

/**
 * Validates string length is within limits
 * @param input The string to validate
 * @param maxLength Maximum allowed length
 * @param fieldName Name of the field for error message
 * @throws Error if string exceeds maximum length
 */
export function validateStringLength(input: string, maxLength: number, fieldName: string): void {
    if (input.length > maxLength) {
        throw new Error(`${fieldName} exceeds maximum length of ${maxLength} characters`);
    }
}

================
File: src/types/batch.ts
================
import { Task } from './task.js';

/**
 * Configuration for batch processing operations
 */
export interface BatchConfig {
    /** Maximum number of items per batch */
    batchSize: number;
    /** Maximum number of concurrent batch operations */
    concurrentBatches: number;
    /** Number of retry attempts for failed operations */
    retryCount: number;
    /** Delay between retry attempts in milliseconds */
    retryDelay: number;
}

/**
 * Result of a batch processing operation
 */
export interface BatchResult {
    /** Whether the batch operation was successful */
    success: boolean;
    /** Number of successfully processed items */
    processedCount: number;
    /** Number of failed items */
    failedCount: number;
    /** Detailed error information for failed items */
    errors: Array<BatchError>;
}

/**
 * Error information for a failed batch item
 */
export interface BatchError {
    /** The item that failed processing */
    item: unknown;
    /** The error that occurred */
    error: Error;
    /** Additional context about the failure */
    context?: BatchErrorContext;
}

/**
 * Context information for batch errors
 */
export interface BatchErrorContext {
    /** Size of the batch being processed */
    batchSize: number;
    /** Index of the current item in the batch */
    currentIndex: number;
    /** Number of items processed so far */
    processedCount: number;
    /** Reason for the failure */
    failureReason?: string;
    /** Additional context properties */
    [key: string]: unknown;
}

/**
 * Callbacks for tracking batch processing progress
 */
export interface BatchProgressCallback {
    /** Called when a batch starts processing */
    onBatchStart?: (batchIndex: number, totalBatches: number) => void;
    /** Called when a batch completes processing */
    onBatchComplete?: (batchIndex: number, result: BatchResult) => void;
    /** Called when an individual operation completes */
    onOperationComplete?: (itemIndex: number, totalItems: number) => void;
}

/**
 * Base interface for batch processors
 */
export interface BatchProcessor {
    processBatch<T>(
        batch: T[],
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;
    
    processInBatches<T>(
        items: T[],
        batchSize: number,
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;
}

/**
 * Interface for items with dependencies
 */
export interface DependentItem {
    /** Unique identifier for the item */
    id?: string;
    /** Path-based identifier for the item */
    path?: string;
    /** Dependencies that must be processed before this item */
    dependencies?: string[];
}

/**
 * Extended batch result for task operations
 */
export interface TaskBatchResult extends BatchResult {
    /** Paths of tasks affected by the operation */
    affectedTasks: string[];
    /** ID of the transaction if applicable */
    transactionId?: string;
    /** Validation errors encountered */
    validationErrors?: Array<{
        path: string;
        error: Error;
    }>;
}

/**
 * Configuration for task batch operations
 */
export interface TaskBatchOperation {
    /** Type of operation to perform */
    type: 'add' | 'update' | 'remove';
    /** Tasks to process */
    tasks: Task[];
    /** Additional options for the operation */
    options?: {
        /** Skip validation checks */
        skipValidation?: boolean;
        /** Force update even if conditions aren't met */
        forceUpdate?: boolean;
        /** Continue processing despite errors */
        ignoreErrors?: boolean;
    };
}

/**
 * Status update operation for tasks
 */
export interface StatusUpdate {
    /** Path of the task to update */
    taskPath: string;
    /** New status to apply */
    newStatus: Task['status'];
}

================
File: src/types/cache.ts
================
import { Task } from './task.js';

export interface CacheEntry<T> {
  value: T;
  expires: number;
  lastAccessed: number;
}

export interface CacheOptions {
  maxSize?: number;
  ttl?: number;
  cleanupInterval?: number;
  baseTTL?: number;
  maxTTL?: number;
}

export interface CacheMetricsData extends Record<string, unknown> {
  hits: number;
  misses: number;
  hitRatio: number;
  size: number;
  lastCleanup: number;
  invalidations: number;
  clears: number;
  memoryUsage: number;
}

export interface CacheCoordinatorOptions {
  maxMemory?: number;
  checkInterval?: number;
  pressureThreshold?: number;
  debugMode?: boolean;
}

export interface TaskCacheEntry extends CacheEntry<Task> {
  dependencies?: string[];
  dependents?: string[];
}

export interface CacheStats {
  size: number;
  hits: number;
  misses: number;
  hitRatio: number;
  memoryUsage: number;
  lastCleanup: number;
}

================
File: src/types/config.ts
================
/**
 * Configuration types
 */
import { LogLevel } from '../types/logging.js';

/**
 * Environment types
 */
export const Environments = {
    DEVELOPMENT: 'development',
    PRODUCTION: 'production',
    TEST: 'test'
} as const;

export type Environment = typeof Environments[keyof typeof Environments];

/**
 * Environment configuration
 */
export interface EnvironmentConfig {
    /** Node environment */
    NODE_ENV: Environment;
    /** Log level */
    LOG_LEVEL: LogLevel;
    /** Task storage directory */
    TASK_STORAGE_DIR: string;
}

/**
 * Logging configuration
 */
export interface LoggingConfig {
    /** Log level */
    level: LogLevel;
    /** Enable console logging */
    console: boolean;
    /** Enable file logging */
    file: boolean;
    /** Log directory */
    dir?: string;
    /** Maximum log files */
    maxFiles: number;
    /** Maximum log file size */
    maxSize: number;
}

/**
 * Storage configuration
 */
export interface StorageConfig {
    /** Base directory */
    baseDir: string;
    /** Storage name */
    name: string;
    /** Connection settings */
    connection?: {
        /** Maximum retries */
        maxRetries?: number;
        /** Retry delay in milliseconds */
        retryDelay?: number;
        /** Busy timeout in milliseconds */
        busyTimeout?: number;
    };
    /** Performance settings */
    performance?: {
        /** WAL mode checkpoint interval */
        checkpointInterval?: number;
        /** Cache size in pages */
        cacheSize?: number;
        /** Memory map size */
        mmapSize?: number;
        /** Page size */
        pageSize?: number;
    };
}

/**
 * Application configuration
 */
export interface Config {
    /** Environment */
    env: Environment;
    /** Logging configuration */
    logging: LoggingConfig;
    /** Storage configuration */
    storage: StorageConfig;
}

================
File: src/types/error.ts
================
/**
 * Error-related type definitions
 */

/**
 * Error codes enumeration
 * @description Defines all possible error codes in the system
 */
export const ErrorCodes = {
    // Task-related errors
    TASK_NOT_FOUND: 'TASK_NOT_FOUND',
    TASK_VALIDATION: 'TASK_VALIDATION',
    TASK_DEPENDENCY: 'TASK_DEPENDENCY',
    TASK_STATUS: 'TASK_STATUS',
    TASK_DUPLICATE: 'TASK_DUPLICATE',
    TASK_INVALID_TYPE: 'TASK_INVALID_TYPE',
    TASK_INVALID_STATUS: 'TASK_INVALID_STATUS',
    TASK_INVALID_PARENT: 'TASK_INVALID_PARENT',
    TASK_OPERATION_FAILED: 'TASK_OPERATION_FAILED',
    
    // Storage-related errors
    STORAGE_READ: 'STORAGE_READ',
    STORAGE_WRITE: 'STORAGE_WRITE',
    STORAGE_INIT: 'STORAGE_INIT',
    STORAGE_DELETE: 'STORAGE_DELETE',
    STORAGE_PERMISSION: 'STORAGE_PERMISSION',
    STORAGE_NOT_FOUND: 'STORAGE_NOT_FOUND',
    STORAGE_TRANSACTION: 'STORAGE_TRANSACTION',
    STORAGE_ROLLBACK: 'STORAGE_ROLLBACK',
    STORAGE_COMMIT: 'STORAGE_COMMIT',
    
    // Configuration errors
    CONFIG_MISSING: 'CONFIG_MISSING',
    CONFIG_INVALID: 'CONFIG_INVALID',
    CONFIG_TYPE: 'CONFIG_TYPE',
    CONFIG_VALIDATION: 'CONFIG_VALIDATION',
    CONFIG_REQUIRED: 'CONFIG_REQUIRED',
    
    // Server errors
    SERVER_INIT: 'SERVER_INIT',
    SERVER_SHUTDOWN: 'SERVER_SHUTDOWN',
    SERVER_CONNECTION: 'SERVER_CONNECTION',
    SERVER_TIMEOUT: 'SERVER_TIMEOUT',
    SERVER_OVERLOAD: 'SERVER_OVERLOAD',
    
    // Tool-related errors
    TOOL_NOT_FOUND: 'TOOL_NOT_FOUND',
    TOOL_EXECUTION: 'TOOL_EXECUTION',
    TOOL_VALIDATION: 'TOOL_VALIDATION',
    TOOL_TIMEOUT: 'TOOL_TIMEOUT',
    TOOL_PERMISSION: 'TOOL_PERMISSION',
    
    // General errors
    INTERNAL_ERROR: 'INTERNAL_ERROR',
    INVALID_INPUT: 'INVALID_INPUT',
    OPERATION_FAILED: 'OPERATION_FAILED',
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    PERMISSION_DENIED: 'PERMISSION_DENIED',
    NOT_IMPLEMENTED: 'NOT_IMPLEMENTED',
    TIMEOUT: 'TIMEOUT'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

/**
 * Base error interface
 * @description Common properties for all errors
 */
export interface BaseError {
    /** Error name/type */
    name: string;
    /** Error message */
    message: string;
    /** Error code */
    code: ErrorCode;
    /** Error stack trace */
    stack?: string;
    /** Additional error details */
    details?: unknown;
}

/**
 * Error severity levels
 * @description Defines the severity of errors for logging and handling
 */
export const ErrorSeverity = {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
    FATAL: 'fatal'
} as const;

export type ErrorSeverityLevel = typeof ErrorSeverity[keyof typeof ErrorSeverity];

/**
 * Extended error interface with severity
 * @description Error interface with additional severity information
 */
export interface ExtendedError extends BaseError {
    /** Error severity level */
    severity: ErrorSeverityLevel;
    /** Timestamp when the error occurred */
    timestamp: string;
    /** Request ID associated with the error */
    requestId?: string;
    /** Session ID associated with the error */
    sessionId?: string;
    /** User ID associated with the error */
    userId?: string;
    /** Additional context about the error */
    context?: Record<string, unknown>;
}

/**
 * Error response interface
 * @description Standard error response format
 */
export interface ErrorResponse {
    /** Operation success status (always false for errors) */
    success: false;
    /** Error information */
    error: {
        /** Error code */
        code: ErrorCode;
        /** Error message */
        message: string;
        /** Additional error details */
        details?: unknown;
    };
    /** Response metadata */
    metadata?: {
        /** Operation timestamp */
        timestamp: string;
        /** Request identifier */
        requestId: string;
        /** Session identifier */
        sessionId: string;
    };
}

/**
 * Error handler options interface
 * @description Configuration options for error handling
 */
export interface ErrorHandlerOptions {
    /** Whether to include stack traces in errors */
    includeStack?: boolean;
    /** Default error severity level */
    defaultSeverity?: ErrorSeverityLevel;
    /** Whether to log errors automatically */
    autoLog?: boolean;
    /** Custom error transformers */
    transformers?: {
        [key: string]: (error: unknown) => ErrorResponse;
    };
}

/**
 * Error category mapping
 * @description Maps error codes to their categories for better organization
 */
export const ErrorCategories = {
    TASK: [
        ErrorCodes.TASK_NOT_FOUND,
        ErrorCodes.TASK_VALIDATION,
        ErrorCodes.TASK_DEPENDENCY,
        ErrorCodes.TASK_STATUS,
        ErrorCodes.TASK_DUPLICATE,
        ErrorCodes.TASK_INVALID_TYPE,
        ErrorCodes.TASK_INVALID_STATUS,
        ErrorCodes.TASK_INVALID_PARENT,
        ErrorCodes.TASK_OPERATION_FAILED
    ],
    STORAGE: [
        ErrorCodes.STORAGE_READ,
        ErrorCodes.STORAGE_WRITE,
        ErrorCodes.STORAGE_INIT,
        ErrorCodes.STORAGE_DELETE,
        ErrorCodes.STORAGE_PERMISSION,
        ErrorCodes.STORAGE_NOT_FOUND,
        ErrorCodes.STORAGE_TRANSACTION,
        ErrorCodes.STORAGE_ROLLBACK,
        ErrorCodes.STORAGE_COMMIT
    ],
    CONFIG: [
        ErrorCodes.CONFIG_MISSING,
        ErrorCodes.CONFIG_INVALID,
        ErrorCodes.CONFIG_TYPE,
        ErrorCodes.CONFIG_VALIDATION,
        ErrorCodes.CONFIG_REQUIRED
    ],
    SERVER: [
        ErrorCodes.SERVER_INIT,
        ErrorCodes.SERVER_SHUTDOWN,
        ErrorCodes.SERVER_CONNECTION,
        ErrorCodes.SERVER_TIMEOUT,
        ErrorCodes.SERVER_OVERLOAD
    ],
    TOOL: [
        ErrorCodes.TOOL_NOT_FOUND,
        ErrorCodes.TOOL_EXECUTION,
        ErrorCodes.TOOL_VALIDATION,
        ErrorCodes.TOOL_TIMEOUT,
        ErrorCodes.TOOL_PERMISSION
    ],
    GENERAL: [
        ErrorCodes.INTERNAL_ERROR,
        ErrorCodes.INVALID_INPUT,
        ErrorCodes.OPERATION_FAILED,
        ErrorCodes.VALIDATION_ERROR,
        ErrorCodes.PERMISSION_DENIED,
        ErrorCodes.NOT_IMPLEMENTED,
        ErrorCodes.TIMEOUT
    ]
} as const;

export type ErrorCategory = keyof typeof ErrorCategories;

/**
 * Error metadata interface
 * @description Additional metadata for error tracking and analysis
 */
export interface ErrorMetadata {
    /** Error category */
    category: ErrorCategory;
    /** Error severity */
    severity: ErrorSeverityLevel;
    /** Whether the error is retryable */
    retryable: boolean;
    /** Suggested recovery action */
    recovery?: string;
    /** Related documentation link */
    docs?: string;
    /** Additional metadata */
    [key: string]: unknown;
}

/**
 * Error mapping type
 * @description Maps error codes to their metadata
 */
export type ErrorMapping = {
    [K in ErrorCode]: ErrorMetadata;
};

================
File: src/types/events.ts
================
/**
 * System event types and interfaces
 */
import { MonitoringMetrics } from './storage.js';

// Base event type
export type AtlasEvent = SystemEvent | TaskEvent | CacheEvent | ErrorEvent | TransactionEvent | BatchEvent;

// Event handler types
export type EventHandler<T extends AtlasEvent> = (event: T) => void | Promise<void>;

export interface EventSubscription {
    unsubscribe: () => void;
}

// Transaction event interface
export interface TransactionEvent {
    type: EventTypes;
    timestamp: number;
    transactionId: string;
    metadata?: Record<string, unknown>;
}

// Batch event interface
export interface BatchEvent {
    type: EventTypes;
    timestamp: number;
    batchId: string;
    metadata?: Record<string, unknown>;
}

export enum EventTypes {
    // System events
    SYSTEM_STARTUP = 'system_startup',
    SYSTEM_SHUTDOWN = 'system_shutdown',
    SYSTEM_ERROR = 'system_error',

    // Tool events
    TOOL_STARTED = 'tool_started',
    TOOL_COMPLETED = 'tool_completed',
    TOOL_FAILED = 'tool_failed',

    // Storage events
    STORAGE_WAL_ENABLED = 'storage_wal_enabled',
    STORAGE_WAL_CHECKPOINT = 'storage_wal_checkpoint',
    STORAGE_VACUUM = 'storage_vacuum',
    STORAGE_ANALYZE = 'storage_analyze',

    // Transaction events
    TRANSACTION_STARTED = 'transaction_started',
    TRANSACTION_COMMITTED = 'transaction_committed',
    TRANSACTION_ROLLED_BACK = 'transaction_rolled_back',
    TRANSACTION_TIMEOUT = 'transaction_timeout',
    TRANSACTION_ERROR = 'transaction_error',

    // Task events
    TASK_CREATED = 'task_created',
    TASK_UPDATED = 'task_updated',
    TASK_DELETED = 'task_deleted',
    TASK_STATUS_CHANGED = 'task_status_changed',

    // Cache events
    MEMORY_PRESSURE = 'memory_pressure',
    CACHE_CLEARED = 'cache_cleared',
    CACHE_INVALIDATED = 'cache_invalidated'
}

export interface SystemEventMetadata {
    // Tool execution
    tool?: string;
    args?: unknown;
    success?: boolean;
    error?: Error;

    // System info
    version?: string;
    environment?: string;
    component?: string;
    operation?: string;
    reason?: string;

    // Resource usage
    memoryUsage?: {
        heapUsed: number;
        heapTotal: number;
        rss: number;
    };
    threshold?: number;

    // Transaction info
    transactionId?: string;
    connectionId?: string;
    isolation?: string;
    duration?: number;

    // Storage info
    dbPath?: string;
    checkpointCount?: number;
    walMode?: boolean;
    metrics?: MonitoringMetrics;
    unhealthyConnections?: string[];
    healthStatus?: {
        isHealthy: boolean;
        errorCount: number;
        avgResponseTime: number;
    };
}

export interface SystemEvent {
    type: EventTypes;
    timestamp: number;
    metadata?: SystemEventMetadata;
}

export interface ErrorEvent {
    type: EventTypes.SYSTEM_ERROR;
    timestamp: number;
    error: Error;
    context?: {
        component: string;
        operation: string;
        args?: unknown;
    };
}

export interface TaskEvent {
    type: EventTypes;
    timestamp: number;
    taskId: string;
    task: unknown;
    metadata?: Record<string, unknown>;
    changes?: {
        before: unknown;
        after: unknown;
    };
}

export interface CacheEvent {
    type: EventTypes;
    timestamp: number;
    metadata: {
        memoryUsage: {
            heapUsed: number;
            heapTotal: number;
            rss: number;
        };
        threshold: number;
    };
}

================
File: src/types/index.ts
================
/**
 * Common type definitions
 */
export * from './indexing.js';

/**
 * Validation result interface
 */
export interface ValidationResult<T = unknown> {
    /** Whether validation succeeded */
    success: boolean;
    /** Validated data if successful */
    data?: T;
    /** Validation errors if failed */
    errors?: Array<{
        /** Field path */
        path: string[];
        /** Error message */
        message: string;
        /** Received value */
        received?: unknown;
        /** Expected type/value */
        expected?: string;
    }>;
}

/**
 * Utility type for making all properties optional recursively
 */
export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Utility type for making all properties required recursively
 */
export type DeepRequired<T> = {
    [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

/**
 * Utility type for making all properties readonly recursively
 */
export type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

/**
 * Utility type for extracting keys of type from object
 */
export type KeysOfType<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];

/**
 * Utility type for omitting properties by type
 */
export type OmitByType<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};

/**
 * Utility type for picking properties by type
 */
export type PickByType<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};

/**
 * Utility type for making properties mutable
 */
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

/**
 * Utility type for making properties immutable
 */
export type Immutable<T> = {
    readonly [P in keyof T]: T[P];
};

/**
 * Utility type for type predicate functions
 */
export type TypePredicate = (value: unknown) => boolean;

/**
 * Utility type for async functions
 */
export type AsyncFunction<T = void> = () => Promise<T>;

/**
 * Utility type for constructor functions
 */
export type Constructor<T = object> = new (...args: any[]) => T;

/**
 * Utility type for function parameters
 */
export type Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;

/**
 * Utility type for function return type
 */
export type ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never;

/**
 * Utility type for promise value type
 */
export type PromiseType<T extends Promise<any>> = T extends Promise<infer U> ? U : never;

/**
 * Utility type for array element type
 */
export type ArrayElement<T extends readonly any[]> = T extends readonly (infer U)[] ? U : never;

/**
 * Utility type for object values
 */
export type ObjectValues<T> = T[keyof T];

/**
 * Utility type for object keys
 */
export type ObjectKeys<T> = keyof T;

/**
 * Utility type for non-undefined values
 */
export type NonUndefined<T> = T extends undefined ? never : T;

/**
 * Utility type for non-null values
 */
export type NonNull<T> = T extends null ? never : T;

/**
 * Utility type for non-nullable values
 */
export type NonNullable<T> = T extends null | undefined ? never : T;

/**
 * Utility type for required keys
 */
export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

/**
 * Utility type for optional keys
 */
export type OptionalKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

================
File: src/types/indexing.ts
================
/**
 * Task indexing type definitions
 */

import { Task, TaskStatus } from './task.js';

/**
 * Task index structure
 */
export interface TaskIndex extends Task {
    path: string;
    status: TaskStatus;
    parentPath?: string;
    dependencies: string[];
    subtasks: string[];
}

/**
 * Index manager configuration
 */
export interface IndexConfig {
    batchSize: number;
    parallelOperations: boolean;
}

/**
 * Index operation result
 */
export interface IndexOperationResult {
    success: boolean;
    error?: Error;
}

/**
 * Index manager interface
 */
export interface IndexManager {
    /**
     * Indexes a task and its dependencies
     */
    indexTask(task: Task): Promise<void>;

    /**
     * Removes a task from all indexes
     */
    unindexTask(task: Task): Promise<void>;

    /**
     * Gets a task by its exact path
     */
    getTaskByPath(path: string): Promise<TaskIndex | null>;

    /**
     * Gets tasks by path pattern (supports * and ** wildcards)
     */
    getTasksByPattern(pattern: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks by status with optional pattern filtering
     */
    getTasksByStatus(status: TaskStatus, pattern?: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks by parent path
     */
    getTasksByParent(parentPath: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks that depend on a task
     */
    getDependentTasks(path: string): Promise<TaskIndex[]>;

    /**
     * Gets project tasks by pattern
     */
    getProjectTasks(pattern: string): Promise<TaskIndex[]>;

    /**
     * Clears all indexes
     */
    clear(): void;

    /**
     * Gets index statistics
     */
    getStats(): IndexStats;
}

/**
 * Index statistics
 */
export interface IndexStats {
    totalTasks: number;
    byStatus: Record<TaskStatus, number>;
    byDepth: Record<number, number>;
    averageDepth: number;
}

================
File: src/types/logging.ts
================
/**
 * Logging-related type definitions
 */

/**
 * Log levels enumeration
 * @description Defines the possible log levels using Winston's standard levels
 */
export const LogLevels = {
    ERROR: 'error',   // 0
    WARN: 'warn',     // 1
    INFO: 'info',     // 2
    HTTP: 'http',     // 3
    VERBOSE: 'verbose', // 4
    DEBUG: 'debug',   // 5
    SILLY: 'silly'    // 6
} as const;

export type LogLevel = typeof LogLevels[keyof typeof LogLevels];

/**
 * Log entry interface
 * @description Represents a single log entry
 */
export interface LogEntry {
    /** Log timestamp */
    timestamp: string;
    /** Log level */
    level: LogLevel;
    /** Log message */
    message: string;
    /** Additional context */
    context?: Record<string, unknown>;
    /** Error information if applicable */
    error?: {
        /** Error name */
        name: string;
        /** Error message */
        message: string;
        /** Error stack trace */
        stack?: string;
        /** Error code */
        code?: string;
        /** Additional error details */
        details?: unknown;
    };
}

/**
 * Logger configuration interface
 * @description Configuration options for the logger
 */
export interface LoggerConfig {
    /** Minimum log level to record */
    minLevel: LogLevel;
    /** Log directory path */
    logDir?: string;
    /** Whether to log to console */
    console?: boolean;
    /** Whether to log to file */
    file?: boolean;
    /** Maximum number of log files */
    maxFiles?: number;
    /** Maximum size of each log file in bytes */
    maxFileSize?: number;
    /** Whether to disable colored console output */
    noColors?: boolean;
}

/**
 * Log formatter interface
 * @description Interface for log formatters
 */
export interface LogFormatter {
    /** Format a log entry */
    format(entry: LogEntry): string;
}

/**
 * Log transport interface
 * @description Interface for log transports (console, file, etc.)
 */
export interface LogTransport {
    /** Write a log entry */
    write(entry: LogEntry): Promise<void>;
    /** Initialize the transport */
    initialize?(): Promise<void>;
    /** Close the transport */
    close?(): Promise<void>;
}

/**
 * Child logger context interface
 * @description Context for child loggers
 */
export interface ChildLoggerContext {
    /** Component name */
    component?: string;
    /** Request ID */
    requestId?: string;
    /** Session ID */
    sessionId?: string;
    /** User ID */
    userId?: string;
    /** Additional context */
    [key: string]: unknown;
}

/**
 * Logger interface
 * @description Interface for logger instances
 */
export interface Logger {
    /** Log at DEBUG level */
    debug(message: string, context?: Record<string, unknown>): void;
    /** Log at INFO level */
    info(message: string, context?: Record<string, unknown>): void;
    /** Log at WARN level */
    warn(message: string, context?: Record<string, unknown>): void;
    /** Log at ERROR level */
    error(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
    /** Log at ERROR level (alias for error, maintains backward compatibility) */
    fatal(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
    /** Create a child logger with additional context */
    child(context: ChildLoggerContext): Logger;
    /** Initialize the logger */
    initialize(): Promise<void>;
}

/**
 * Log file info interface
 * @description Information about a log file
 */
export interface LogFileInfo {
    /** File name */
    name: string;
    /** File path */
    path: string;
    /** File size in bytes */
    size: number;
    /** Creation timestamp */
    created: string;
    /** Last modified timestamp */
    modified: string;
}

/**
 * Log rotation options interface
 * @description Options for log rotation
 */
export interface LogRotationOptions {
    /** Maximum file size in bytes */
    maxSize: number;
    /** Maximum number of files */
    maxFiles: number;
    /** Whether to compress old logs */
    compress?: boolean;
    /** Pattern for date in file names */
    datePattern?: string;
}

/**
 * Log query options interface
 * @description Options for querying logs
 */
export interface LogQueryOptions {
    /** Start timestamp */
    from?: string;
    /** End timestamp */
    to?: string;
    /** Log levels to include */
    levels?: LogLevel[];
    /** Search text */
    search?: string;
    /** Context filters */
    context?: Record<string, unknown>;
    /** Maximum number of entries */
    limit?: number;
    /** Number of entries to skip */
    offset?: number;
    /** Sort direction */
    order?: 'asc' | 'desc';
}

/**
 * Log query result interface
 * @description Result of a log query
 */
export interface LogQueryResult {
    /** Log entries */
    entries: LogEntry[];
    /** Total number of matching entries */
    total: number;
    /** Query metadata */
    metadata: {
        /** Query timestamp */
        timestamp: string;
        /** Query duration in milliseconds */
        duration: number;
        /** Applied filters */
        filters: Record<string, unknown>;
    };
}

================
File: src/types/project.ts
================
/**
 * Project-related type definitions
 */

/**
 * Project status enumeration
 */
export enum ProjectStatus {
    ACTIVE = 'active',
    ARCHIVED = 'archived',
    COMPLETED = 'completed'
}

/**
 * Project metadata interface
 */
export interface ProjectMetadata {
    created: number;
    updated: number;
    owner: string;
    tags?: string[];
    status: ProjectStatus;
    version: number;
    description?: string;
    category?: string;
    priority?: 'low' | 'medium' | 'high';
    dueDate?: number;
    customFields?: Record<string, unknown>;
}

/**
 * Project interface
 */
export interface Project {
    path: string;           // Unique project identifier (e.g., "auth-system")
    name: string;           // Display name
    description?: string;
    metadata: ProjectMetadata;
    rootTaskPaths: string[];  // Top-level task paths
}

/**
 * Project creation input
 */
export interface CreateProjectInput {
    path: string;
    name: string;
    description?: string;
    metadata?: {
        owner?: string;
        tags?: string[];
        category?: string;
        priority?: 'low' | 'medium' | 'high';
        dueDate?: number;
        customFields?: Record<string, unknown>;
    };
}

/**
 * Project update input
 */
export interface UpdateProjectInput {
    name?: string;
    description?: string;
    metadata?: Partial<Omit<ProjectMetadata, 'created' | 'updated' | 'version'>>;
}

/**
 * Project operation response
 */
export interface ProjectResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: unknown;
    };
    metadata?: {
        timestamp: number;
        requestId: string;
        projectPath: string;
        affectedTasks?: string[];
        transactionId?: string;
    };
}

/**
 * Project validation utilities
 */
export const PROJECT_PATH_REGEX = /^[a-z0-9][a-z0-9-]*[a-z0-9]$/;
export const MAX_PROJECT_PATH_LENGTH = 64;
export const MAX_PROJECT_NAME_LENGTH = 100;
export const MAX_PROJECT_DESCRIPTION_LENGTH = 1000;

export function validateProjectPath(path: string): boolean {
    return (
        PROJECT_PATH_REGEX.test(path) &&
        path.length <= MAX_PROJECT_PATH_LENGTH &&
        !path.includes('/')
    );
}

export function validateProjectName(name: string): boolean {
    return (
        name.trim().length > 0 &&
        name.length <= MAX_PROJECT_NAME_LENGTH
    );
}

export function validateProjectDescription(description?: string): boolean {
    return !description || description.length <= MAX_PROJECT_DESCRIPTION_LENGTH;
}

/**
 * Project error codes
 */
export enum ProjectErrorCode {
    INVALID_PATH = 'PROJECT_INVALID_PATH',
    INVALID_NAME = 'PROJECT_INVALID_NAME',
    INVALID_DESCRIPTION = 'PROJECT_INVALID_DESCRIPTION',
    DUPLICATE_PATH = 'PROJECT_DUPLICATE_PATH',
    NOT_FOUND = 'PROJECT_NOT_FOUND',
    ARCHIVED = 'PROJECT_ARCHIVED',
    INVALID_STATUS = 'PROJECT_INVALID_STATUS',
    INVALID_METADATA = 'PROJECT_INVALID_METADATA'
}

================
File: src/types/session.ts
================
/**
 * Session and Task List Types
 */

/**
 * Session metadata
 */
export interface SessionMetadata {
    /** Creation timestamp */
    created: number;
    /** Last update timestamp */
    updated: number;
    /** Session tags */
    tags?: string[];
    /** Additional context */
    context?: string;
    /** Whether the session is archived */
    archived?: boolean;
}

/**
 * Session storage interface
 */
export interface SessionStorage {
    /** Initialize storage */
    initialize(): Promise<void>;
    /** Save session */
    saveSession(session: Session): Promise<void>;
    /** Load session by ID */
    loadSession(sessionId: string): Promise<Session>;
    /** Load all sessions */
    loadAllSessions(): Promise<Session[]>;
    /** Delete session */
    deleteSession(sessionId: string): Promise<void>;
    /** Save task list */
    saveTaskList(taskList: TaskList): Promise<void>;
    /** Load task list by ID */
    loadTaskList(taskListId: string): Promise<TaskList>;
    /** Load all task lists */
    loadAllTaskLists(): Promise<TaskList[]>;
    /** Delete task list */
    deleteTaskList(taskListId: string): Promise<void>;
    /** Save active state */
    saveActiveState(state: {
        activeSessionId?: string;
        activeTaskListId?: string;
    }): Promise<void>;
    /** Load active state */
    loadActiveState(): Promise<{
        activeSessionId?: string;
        activeTaskListId?: string;
    }>;
    /** Close storage */
    close(): Promise<void>;
}

/**
 * Session manager interface
 */
export interface SessionManager {
    /** Initialize manager */
    initialize(): Promise<void>;
    /** Create new session */
    createSession(input: CreateSessionInput): Promise<Session>;
    /** Get session by ID */
    getSession(sessionId: string): Promise<Session>;
    /** List all sessions */
    listSessions(includeArchived?: boolean): Promise<Session[]>;
    /** Archive session */
    archiveSession(sessionId: string): Promise<void>;
    /** Create task list */
    createTaskList(input: CreateTaskListInput): Promise<TaskList>;
    /** Get task list by ID */
    getTaskList(taskListId: string): Promise<TaskList>;
    /** List all task lists */
    listTaskLists(includeArchived?: boolean): Promise<TaskList[]>;
    /** Archive task list */
    archiveTaskList(taskListId: string): Promise<void>;
    /** Switch active session */
    switchSession(sessionId: string): Promise<void>;
    /** Switch active task list */
    switchTaskList(taskListId: string): Promise<void>;
    /** Get active session */
    getActiveSession(): Promise<Session | null>;
    /** Get active task list */
    getActiveTaskList(): Promise<TaskList | null>;
}

/**
 * Session entity
 */
export interface Session {
    /** Unique session ID */
    id: string;
    /** Session name */
    name: string;
    /** Session metadata */
    metadata: SessionMetadata;
    /** Active task list ID */
    activeTaskListId?: string;
    /** Task list IDs in this session */
    taskListIds: string[];
}

/**
 * Task list metadata
 */
export interface TaskListMetadata {
    /** Creation timestamp */
    created: number;
    /** Last update timestamp */
    updated: number;
    /** Task list tags */
    tags?: string[];
    /** Additional context */
    context?: string;
    /** Whether the task list is archived */
    archived?: boolean;
    /** Whether the task list persists across sessions */
    persistent?: boolean;
}

/**
 * Task list entity
 */
export interface TaskList {
    /** Unique task list ID */
    id: string;
    /** Task list name */
    name: string;
    /** Task list description */
    description?: string;
    /** Task list metadata */
    metadata: TaskListMetadata;
    /** Root task IDs */
    rootTaskIds: string[];
}

/**
 * Session creation input
 */
export interface CreateSessionInput {
    /** Session name */
    name: string;
    /** Session metadata */
    metadata?: {
        /** Session tags */
        tags?: string[];
        /** Additional context */
        context?: string;
    };
}

/**
 * Task list creation input
 */
export interface CreateTaskListInput {
    /** Task list name */
    name: string;
    /** Task list description */
    description?: string;
    /** Task list metadata */
    metadata?: {
        /** Task list tags */
        tags?: string[];
        /** Additional context */
        context?: string;
    };
    /** Whether the task list should persist across sessions */
    persistent?: boolean;
}

/**
 * Session response wrapper
 */
export interface SessionResponse {
    /** Response data */
    data: Session;
    /** Response metadata */
    metadata: {
        /** Operation timestamp */
        timestamp: number;
        /** Operation type */
        operation: 'create' | 'update' | 'delete';
    };
}

/**
 * Task list response wrapper
 */
export interface TaskListResponse {
    /** Response data */
    data: TaskList;
    /** Response metadata */
    metadata: {
        /** Operation timestamp */
        timestamp: number;
        /** Operation type */
        operation: 'create' | 'update' | 'delete';
    };
}

/**
 * Session error codes
 */
export enum SessionErrorCode {
    /** Session not found */
    SESSION_NOT_FOUND = 'SESSION_NOT_FOUND',
    /** Session validation failed */
    SESSION_VALIDATION = 'SESSION_VALIDATION',
    /** Session already exists */
    SESSION_EXISTS = 'SESSION_EXISTS',
    /** Session limit exceeded */
    SESSION_LIMIT = 'SESSION_LIMIT',
    /** Invalid session operation */
    SESSION_INVALID_OP = 'SESSION_INVALID_OP'
}

/**
 * Task list error codes
 */
export enum TaskListErrorCode {
    /** Task list not found */
    TASK_LIST_NOT_FOUND = 'TASK_LIST_NOT_FOUND',
    /** Task list validation failed */
    TASK_LIST_VALIDATION = 'TASK_LIST_VALIDATION',
    /** Task list already exists */
    TASK_LIST_EXISTS = 'TASK_LIST_EXISTS',
    /** Task list limit exceeded */
    TASK_LIST_LIMIT = 'TASK_LIST_LIMIT',
    /** Invalid task list operation */
    TASK_LIST_INVALID_OP = 'TASK_LIST_INVALID_OP'
}

================
File: src/types/storage.ts
================
/**
 * Storage types and interfaces
 */
import { Task, TaskStatus, CreateTaskInput, UpdateTaskInput } from './task.js';
import { MonitoringConfig } from '../storage/monitoring/index.js';

export interface StorageConfig {
    baseDir: string;
    name: string;
    connection?: {
        maxConnections?: number;
        idleTimeout?: number;
        busyTimeout?: number;
    };
    performance?: {
        cacheSize?: number;
        pageSize?: number;
        mmapSize?: number;
    };
    monitoring?: MonitoringConfig;
}

export interface StorageMetrics {
    tasks: {
        total: number;
        byStatus: Record<TaskStatus, number>;
        noteCount: number;
        dependencyCount: number;
    };
    storage: {
        totalSize: number;
        pageSize: number;
        pageCount: number;
        walSize: number;
        cache: {
            hitRate: number;
            memoryUsage: number;
            entryCount: number;
        };
    };
}

export interface TaskStorage {
    initialize(): Promise<void>;
    close(): Promise<void>;
    
    // Transaction management
    beginTransaction(): Promise<void>;
    commitTransaction(): Promise<void>;
    rollbackTransaction(): Promise<void>;
    
    // Task operations
    createTask(input: CreateTaskInput): Promise<Task>;
    updateTask(path: string, updates: UpdateTaskInput): Promise<Task>;
    deleteTask(path: string): Promise<void>;
    getTask(path: string): Promise<Task | null>;
    getTasks(paths: string[]): Promise<Task[]>;
    getTasksByPattern(pattern: string): Promise<Task[]>;
    getTasksByStatus(status: string): Promise<Task[]>;
    getSubtasks(parentPath: string): Promise<Task[]>;
    hasChildren(path: string): Promise<boolean>;
    getDependentTasks(path: string): Promise<Task[]>;
    saveTasks(tasks: Task[]): Promise<void>;
    saveTask(task: Task): Promise<void>;
    deleteTasks(paths: string[]): Promise<void>;
    clearAllTasks(): Promise<void>;
    
    // Maintenance operations
    vacuum(): Promise<void>;
    analyze(): Promise<void>;
    checkpoint(): Promise<void>;
    clearCache(): Promise<void>;
    getMetrics(): Promise<StorageMetrics>;
    repairRelationships(dryRun?: boolean): Promise<{ fixed: number; issues: string[] }>;
}

export interface CacheStats {
    hits: number;
    misses: number;
    hitRate: number;
    size: number;
    memoryUsage: number;
}

export interface ConnectionStats {
    total: number;
    active: number;
    idle: number;
    errors: number;
    avgResponseTime: number;
}

export interface QueryStats {
    total: number;
    errors: number;
    avgExecutionTime: number;
    slowQueries: number;
}

export interface MonitoringMetrics {
    cache: CacheStats;
    connections: ConnectionStats;
    queries: QueryStats;
    timestamp: number;
}

================
File: src/types/task.ts
================
/**
 * Task type definitions
 */

export enum TaskType {
    TASK = 'TASK',
    MILESTONE = 'MILESTONE',
    GROUP = 'GROUP'
}

export enum TaskStatus {
    PENDING = 'PENDING',
    IN_PROGRESS = 'IN_PROGRESS',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED',
    BLOCKED = 'BLOCKED'
}

/**
 * User-defined metadata for tasks
 * All fields are optional and can be customized
 */
export interface TaskMetadata extends Record<string, unknown> {
    priority?: 'low' | 'medium' | 'high';
    tags?: string[];
    reasoning?: string;  // LLM's reasoning about task decisions
    toolsUsed?: string[];  // Tools used by LLM to accomplish task
    resourcesAccessed?: string[];  // Resources accessed by LLM
    contextUsed?: string[];  // Key context pieces used in decision making
    // Each string field max 1000 chars, arrays max 100 items
}

/**
 * Core task interface with system fields at root level
 */
export interface Task {
    // System fields (required)
    path: string;  // Max depth of 8 levels
    name: string;  // Max 200 chars
    type: TaskType;
    status: TaskStatus;
    created: number;  // Timestamp of creation
    updated: number;  // Timestamp of last update
    version: number;  // Incremental version number
    projectPath: string;  // Root project path

    // Optional fields
    description?: string;  // Max 2000 chars
    parentPath?: string;
    notes?: string[];  // Each note max 1000 chars
    reasoning?: string;  // Max 2000 chars - LLM's reasoning about the task
    dependencies: string[];  // Max 50 dependencies
    subtasks: string[];  // Max 100 subtasks
    
    // User-defined metadata (flexible)
    metadata: TaskMetadata;  // Custom fields defined by user
}

export interface CreateTaskInput extends Record<string, unknown> {
    path: string;  // Now required
    name: string;
    parentPath?: string;
    description?: string;
    type?: TaskType;
    notes?: string[];
    reasoning?: string;
    dependencies?: string[];
    metadata?: Partial<TaskMetadata>;
}

export interface UpdateTaskInput extends Record<string, unknown> {
    name?: string;
    description?: string;
    type?: TaskType;
    status?: TaskStatus;
    parentPath?: string;
    notes?: string[];
    reasoning?: string;
    dependencies?: string[];
    metadata?: Partial<TaskMetadata>;
}

export interface TaskResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
    };
    metadata: {
        timestamp: number;
        requestId: string;
        projectPath: string;
        affectedPaths: string[];
    };
}

// Field length constraints
export const CONSTRAINTS = {
    NAME_MAX_LENGTH: 200,
    DESCRIPTION_MAX_LENGTH: 2000,
    NOTE_MAX_LENGTH: 1000,
    REASONING_MAX_LENGTH: 2000,
    METADATA_STRING_MAX_LENGTH: 1000,
    MAX_DEPENDENCIES: 50,
    MAX_SUBTASKS: 100,
    MAX_NOTES: 100,
    MAX_ARRAY_ITEMS: 100,
    MAX_PATH_DEPTH: 8
} as const;

/**
 * Gets the task name from a path
 */
export function getTaskName(path: string): string {
    const segments = path.split('/');
    return segments[segments.length - 1];
}

/**
 * Gets the parent path from a task path
 */
export function getParentPath(path: string): string | undefined {
    const segments = path.split('/');
    return segments.length > 1 ? segments.slice(0, -1).join('/') : undefined;
}

================
File: src/types/transaction.ts
================
import { Task } from './task.js';

export type TransactionStatus = 'pending' | 'committed' | 'rolled_back';

export interface Transaction {
  id: string;
  operations: Operation[];
  timestamp: number;
  status: TransactionStatus;
  timeout?: number;
  metadata?: {
    retryCount?: number;
    parentTransaction?: string;
    initiator?: string;
  };
}

export interface Operation {
  id: string;
  type: 'create' | 'update' | 'delete';
  timestamp: number;
  path: string;
  task?: Task;
  tasks?: Task[];
  previousState?: Partial<Task>;
  metadata?: Record<string, any>;
}

export interface TransactionResult {
  success: boolean;
  transactionId: string;
  error?: Error;
  metadata?: {
    duration: number;
    retryCount?: number;
  };
}

export interface TransactionOptions {
  timeout?: number;
  retryLimit?: number;
  retryDelay?: number;
  requireLock?: boolean;
}

export const DEFAULT_TRANSACTION_OPTIONS: TransactionOptions = {
  timeout: 30000, // 30 seconds
  retryLimit: 3,
  retryDelay: 1000, // 1 second
  requireLock: true
};

================
File: src/utils/id-generator.ts
================
/**
 * ID Generator Utility
 * Generates short, unique identifiers for tasks, sessions, and other entities
 * 
 * Using 8 characters from a 62-character alphabet (a-z, A-Z, 0-9) gives:
 * - 62^8 = 218,340,105,584,896 possible combinations
 * - Collision probability of ~0.1% after 13.5 million IDs (birthday problem)
 * - At 1000 IDs/second, would take ~6.9 years to have a 1% collision probability
 */

import { customAlphabet } from 'nanoid';

// Constants
const ID_LENGTH = 8;
const ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

// Sequence counters for readable IDs
let sessionCounter = 1;
let taskCounter = 1;

// Create ID generator with specified alphabet and length
const generateId = customAlphabet(ALPHABET, ID_LENGTH);

/**
 * Generates a readable session ID
 * Format: session-XXX where XXX is a sequential number
 */
export function generateSessionId(): string {
    const id = `session-${sessionCounter.toString().padStart(3, '0')}`;
    sessionCounter++;
    return id;
}

/**
 * Generates a readable task ID
 * Format: task-XXX where XXX is a sequential number
 */
export function generateTaskId(): string {
    const id = `task-${taskCounter.toString().padStart(3, '0')}`;
    taskCounter++;
    return id;
}

/**
 * Generates a short, unique identifier (for other entities)
 * Format: 8 characters using [0-9A-Za-z]
 * Example: "xK7cPq2Z"
 */
export function generateShortId(): string {
    return generateId();
}

/**
 * Validates if a string matches any of the valid ID formats
 */
export function isValidShortId(value: string): boolean {
    if (!value) return false;
    return new RegExp(`^[${ALPHABET}]{${ID_LENGTH}}$`).test(value);
}

/**
 * Generates a deterministic ID for testing/development
 * @param prefix - Optional 2-character prefix
 * @param sequence - Sequence number (0-999999)
 */
export function generateTestId(prefix = 'ts', sequence = 0): string {
    const seq = sequence.toString().padStart(6, '0');
    return `${prefix}${seq}`.slice(0, ID_LENGTH);
}

// Export constants for use in validation schemas
export const ID_CONSTANTS = {
    LENGTH: ID_LENGTH,
    ALPHABET,
    PATTERN: new RegExp(`^[${ALPHABET}]{${ID_LENGTH}}$`)
} as const;

================
File: src/utils/path-utils.ts
================
import { createError, ErrorCodes } from '../errors/index.js';

/**
 * Utilities for handling task paths with validation and normalization
 */
export class PathUtils {
  /**
   * Normalizes a path string by:
   * - Converting to lowercase
   * - Replacing spaces with hyphens
   * - Removing invalid characters
   * - Normalizing slashes
   */
  static normalize(path: string): string {
    // First convert Windows backslashes to forward slashes
    const normalized = path.replace(/\\/g, '/');
    
    return normalized.toLowerCase()
      .trim()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-\/]/g, '')
      .replace(/\/+/g, '/') // Normalize multiple slashes to single
      .replace(/^\/+|\/+$/g, ''); // Trim leading/trailing slashes
  }

  /**
   * Extracts the project path (first segment) from a full path
   */
  static getProjectPath(path: string): string {
    const normalized = this.normalize(path);
    const segments = normalized.split('/');
    if (segments.length === 0) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Invalid path: empty path'
      );
    }
    return segments[0];
  }

  /**
   * Checks if a path is a valid subpath of another path
   */
  static isSubPath(parentPath: string, childPath: string): boolean {
    const normalizedParent = this.normalize(parentPath);
    const normalizedChild = this.normalize(childPath);
    return normalizedChild.startsWith(`${normalizedParent}/`);
  }

  /**
   * Generates a valid path from a name and optional parent path
   */
  static generatePath(name: string, parentPath?: string): string {
    const safeName = this.normalize(name);
    if (!safeName) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Invalid name: cannot generate path from empty name'
      );
    }
    return parentPath ? `${this.normalize(parentPath)}/${safeName}` : safeName;
  }

  /**
   * Validates a path string against path requirements
   * Throws an error if the path is invalid
   */
  static validatePath(path: string): void {
    if (!path) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path cannot be empty'
      );
    }

    const normalized = this.normalize(path);
    
    // Check for full path format
    if (!normalized.includes('/')) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path must be fully qualified (e.g., "project/feature/task")'
      );
    }

    // Validate path format (allow both forward and backslashes in input, but normalize to forward slashes)
    const pathRegex = /^[a-z0-9-]+(?:[\/\\][a-z0-9-]+)*$/;
    if (!pathRegex.test(normalized)) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path must contain only letters, numbers, hyphens, and forward slashes'
      );
    }

    // Check path depth (prevent excessive nesting)
    const depth = normalized.split('/').length;
    if (depth > 10) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path depth exceeds maximum allowed (10 levels)'
      );
    }
  }

  /**
   * Gets the parent path of a given path
   * Returns null if the path has no parent (is a root path)
   */
  static getParentPath(path: string): string | null {
    const normalized = this.normalize(path);
    const lastSlashIndex = normalized.lastIndexOf('/');
    return lastSlashIndex === -1 ? null : normalized.substring(0, lastSlashIndex);
  }

  /**
   * Gets the name (last segment) of a path
   */
  static getName(path: string): string {
    const normalized = this.normalize(path);
    const segments = normalized.split('/');
    return segments[segments.length - 1];
  }
}

================
File: src/utils/pattern-matcher.ts
================
import { sep, posix } from 'path';

/**
 * Pattern matching utilities for task paths with cross-platform support
 */

/**
 * Normalizes path separators to forward slashes for consistent pattern matching
 */
function normalizePath(path: string): string {
    return path.split(sep).join(posix.sep);
}

/**
 * Converts a glob pattern to a regular expression with platform-agnostic path handling
 * Supports:
 * - * for single level matching
 * - ** for recursive matching
 * - ? for single character matching
 */
export function globToRegex(pattern: string): RegExp {
    // Normalize path separators first
    const normalizedPattern = normalizePath(pattern);
    
    const escapedPattern = normalizedPattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
        .replace(/\*\*/g, '{{RECURSIVE}}') // Temp placeholder for **
        .replace(/\*/g, `[^${posix.sep}]+`) // * matches anything except path separator
        .replace(/\?/g, '.') // ? matches single char
        .replace(/{{RECURSIVE}}/g, '.*'); // ** matches anything including path separator

    return new RegExp(`^${escapedPattern}$`);
}

/**
 * Converts a glob pattern to an SQL LIKE/GLOB pattern with platform-agnostic path handling
 */
export function globToSqlPattern(pattern: string): string {
    // Normalize path separators first
    const normalizedPattern = normalizePath(pattern);
    
    return normalizedPattern
        .replace(/\*\*/g, '%') // ** for recursive match
        .replace(/\*/g, '%') // * for single level match
        .replace(/\?/g, '_'); // ? for single character
}

/**
 * Generates all possible glob patterns for a given path with platform-agnostic handling
 * Example: "a/b/c" generates:
 * - "a/b/c"
 * - "a/b/*"
 * - "a/*\/c"
 * - "a/**"
 * - "*\/b/c"
 * - etc.
 */
export function generatePathPatterns(path: string): string[] {
    // Normalize path separators first
    const normalizedPath = normalizePath(path);
    const segments = normalizedPath.split(posix.sep);
    const patterns: Set<string> = new Set();

    // Add exact path
    patterns.add(normalizedPath);

    // Add single wildcard patterns
    for (let i = 0; i < segments.length; i++) {
        const pattern = [
            ...segments.slice(0, i),
            '*',
            ...segments.slice(i + 1)
        ].join(posix.sep);
        patterns.add(pattern);
    }

    // Add recursive patterns
    for (let i = 0; i < segments.length - 1; i++) {
        const pattern = [...segments.slice(0, i), '**'].join(posix.sep);
        patterns.add(pattern);
    }

    // Add combinations of * and **
    for (let i = 0; i < segments.length - 1; i++) {
        for (let j = i + 1; j < segments.length; j++) {
            const pattern = [
                ...segments.slice(0, i),
                '*',
                ...segments.slice(i + 1, j),
                '**'
            ].join(posix.sep);
            patterns.add(pattern);
        }
    }

    return Array.from(patterns);
}

/**
 * Tests if a path matches a glob pattern with platform-agnostic path handling
 */
export function matchesPattern(path: string, pattern: string): boolean {
    // Normalize both path and pattern before matching
    return globToRegex(pattern).test(normalizePath(path));
}

================
File: src/validation/config.ts
================
/**
 * Configuration validation schemas
 */
import { z } from 'zod';
import { LogLevels } from '../types/logging.js';
import { Environments } from '../types/config.js';

/**
 * Environment variables validation schema
 */
export const envVarsSchema = z.object({
    NODE_ENV: z.enum([
        Environments.DEVELOPMENT,
        Environments.PRODUCTION,
        Environments.TEST
    ]).optional(),
    LOG_LEVEL: z.enum([
        LogLevels.ERROR,
        LogLevels.WARN,
        LogLevels.INFO,
        LogLevels.HTTP,
        LogLevels.VERBOSE,
        LogLevels.DEBUG,
        LogLevels.SILLY
    ]).optional(),
    TASK_STORAGE_DIR: z.string().optional()
});

/**
 * Logging configuration validation schema
 */
export const loggingConfigSchema = z.object({
    level: z.enum([
        LogLevels.ERROR,
        LogLevels.WARN,
        LogLevels.INFO,
        LogLevels.HTTP,
        LogLevels.VERBOSE,
        LogLevels.DEBUG,
        LogLevels.SILLY
    ]),
    console: z.boolean().optional(),
    file: z.boolean().optional(),
    dir: z.string().optional(),
    maxFiles: z.number().int().positive().optional(),
    maxSize: z.number().int().positive().optional(),
    noColors: z.boolean().optional()
});

/**
 * Storage connection configuration validation schema
 */
export const storageConnectionConfigSchema = z.object({
    maxRetries: z.number().int().positive().optional(),
    retryDelay: z.number().int().nonnegative().optional(),
    busyTimeout: z.number().int().nonnegative().optional()
});

/**
 * Storage performance configuration validation schema
 */
export const storagePerformanceConfigSchema = z.object({
    checkpointInterval: z.number().int().nonnegative().optional(),
    cacheSize: z.number().int().nonnegative().optional(),
    mmapSize: z.number().int().nonnegative().optional(),
    pageSize: z.number().int().nonnegative().optional()
});

/**
 * Storage configuration validation schema
 */
export const storageConfigSchema = z.object({
    baseDir: z.string(),
    name: z.string(),
    connection: storageConnectionConfigSchema.optional(),
    performance: storagePerformanceConfigSchema.optional()
});

/**
 * Complete configuration validation schema
 */
export const configSchema = z.object({
    env: z.enum([
        Environments.DEVELOPMENT,
        Environments.PRODUCTION,
        Environments.TEST
    ]),
    logging: loggingConfigSchema,
    storage: storageConfigSchema
});

================
File: src/validation/id-schema.ts
================
/**
 * Shared ID validation schemas using the new short ID format
 */

import { z } from 'zod';
import { ID_CONSTANTS } from '../utils/id-generator.js';

// Legacy UUID pattern
const UUID_PATTERN = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

// Base ID schema for reuse across different entity types
export const baseIdSchema = z.string().regex(
    ID_CONSTANTS.PATTERN,
    `Task/Entity ID must be exactly ${ID_CONSTANTS.LENGTH} characters long and contain only alphanumeric characters [${ID_CONSTANTS.ALPHABET}]. Example: "xK7cPq2Z". You cannot use descriptive names like "Project Setup" as IDs.`
);

// Helper function to validate ID format
export function validateIdFormat(id: string, context: string = 'ID'): void {
    if (!ID_CONSTANTS.PATTERN.test(id)) {
        throw new Error(
            `Invalid ${context}: Must be exactly ${ID_CONSTANTS.LENGTH} characters long and contain only alphanumeric characters [${ID_CONSTANTS.ALPHABET}]. ` +
            `Received: "${id}". Example valid ID: "xK7cPq2Z"`
        );
    }
}

// Transitional schema that accepts both short IDs and UUIDs
export const transitionalIdSchema = z.string().refine(
    (val) => ID_CONSTANTS.PATTERN.test(val) || UUID_PATTERN.test(val),
    `ID must be either ${ID_CONSTANTS.LENGTH} characters long containing only [${ID_CONSTANTS.ALPHABET}] or a valid UUID`
);

// Specific entity ID schemas with custom error messages
export const taskIdSchema = baseIdSchema.describe('Task ID');
export const sessionIdSchema = transitionalIdSchema.describe('Session ID');
export const taskListIdSchema = baseIdSchema.describe('Task List ID');

// Array of IDs schema for dependencies, subtasks, etc.
export const idArraySchema = z.array(baseIdSchema);

// Optional ID schema for nullable fields
export const optionalIdSchema = baseIdSchema.optional();

// Example usage in a task schema:
export const taskReferenceSchema = z.object({
    id: taskIdSchema,
    parentId: optionalIdSchema,
    dependencies: idArraySchema.default([]),
    subtasks: idArraySchema.default([])
});

// Example usage in a session schema:
export const sessionReferenceSchema = z.object({
    id: sessionIdSchema,
    activeTaskListId: optionalIdSchema,
    taskListIds: idArraySchema.default([])
});

// Export types for use in other modules
export type TaskReference = z.infer<typeof taskReferenceSchema>;
export type SessionReference = z.infer<typeof sessionReferenceSchema>;

================
File: src/validation/index.ts
================
/**
 * Validation module exports
 * Provides a centralized point for configuration, logging, shared ID validation,
 * and path validation rules
 */

export * from './config.js';
export * from './logging.js';
export * from './id-schema.js';
export * from './path-validator.js';

================
File: src/validation/logging.ts
================
/**
 * Logging validation schemas
 */
import { z } from 'zod';
import { LogLevels } from '../types/logging.js';

/**
 * Log level validation schema
 */
export const logLevelSchema = z.enum([
    LogLevels.ERROR,
    LogLevels.WARN,
    LogLevels.INFO,
    LogLevels.HTTP,
    LogLevels.VERBOSE,
    LogLevels.DEBUG,
    LogLevels.SILLY
]);

/**
 * Log entry validation schema
 */
export const logEntrySchema = z.object({
    timestamp: z.string(),
    level: logLevelSchema,
    message: z.string(),
    context: z.record(z.unknown()).optional(),
    error: z.object({
        name: z.string(),
        message: z.string(),
        stack: z.string().optional(),
        code: z.string().optional(),
        details: z.unknown().optional()
    }).optional()
});

/**
 * Logger configuration validation schema
 */
export const loggerConfigSchema = z.object({
    minLevel: logLevelSchema,
    logDir: z.string().optional(),
    console: z.boolean().optional(),
    file: z.boolean().optional(),
    maxFiles: z.number().int().positive().optional(),
    maxFileSize: z.number().int().positive().optional(),
    noColors: z.boolean().optional()
});

/**
 * Log query options validation schema
 */
export const logQueryOptionsSchema = z.object({
    from: z.string().optional(),
    to: z.string().optional(),
    levels: z.array(logLevelSchema).optional(),
    search: z.string().optional(),
    context: z.record(z.unknown()).optional(),
    limit: z.number().int().positive().optional(),
    offset: z.number().int().nonnegative().optional(),
    order: z.enum(['asc', 'desc']).optional()
});

/**
 * Log rotation options validation schema
 */
export const logRotationOptionsSchema = z.object({
    maxSize: z.number().int().positive(),
    maxFiles: z.number().int().positive(),
    compress: z.boolean().optional(),
    datePattern: z.string().optional()
});

/**
 * Log file info validation schema
 */
export const logFileInfoSchema = z.object({
    name: z.string(),
    path: z.string(),
    size: z.number().int().nonnegative(),
    created: z.string(),
    modified: z.string()
});

================
File: src/validation/path-validator.ts
================
import { ErrorCodes, createError } from '../errors/index.js';
import { Logger } from '../logging/index.js';

/**
 * Rules for validating task paths and project names
 */
export interface PathValidationRules {
    maxDepth: number;
    maxLength: number;
    allowedCharacters: RegExp;
    projectNamePattern: RegExp;
    maxProjectNameLength: number;
}

/**
 * Result of path validation including sanitized path if valid
 */
export interface PathValidationResult {
    isValid: boolean;
    sanitizedPath?: string;
    error?: string;
}

/**
 * Validates and sanitizes task paths and project names
 * Enforces business rules for path structure and naming
 */
export class PathValidator {
    private static logger: Logger;

    private static getLogger(): Logger {
        if (!PathValidator.logger) {
            PathValidator.logger = Logger.getInstance().child({ component: 'PathValidator' });
        }
        return PathValidator.logger;
    }
    private rules: PathValidationRules;

    constructor(rules?: Partial<PathValidationRules>) {
        this.rules = {
            maxDepth: rules?.maxDepth ?? 5,
            maxLength: rules?.maxLength ?? 255,
            allowedCharacters: rules?.allowedCharacters ?? /^[a-zA-Z0-9-_/]+$/,
            projectNamePattern: rules?.projectNamePattern ?? /^[a-zA-Z][a-zA-Z0-9-_]*$/,
            maxProjectNameLength: rules?.maxProjectNameLength ?? 50
        };
    }

    /**
     * Validates a task path against all rules
     * Returns sanitized path if valid
     */
    validatePath(path: string): PathValidationResult {
        try {
            // Check for empty path
            if (!path) {
                return {
                    isValid: false,
                    error: 'Path cannot be empty'
                };
            }

            // Check for parent directory traversal
            if (path.includes('..')) {
                return {
                    isValid: false,
                    error: 'Path cannot contain parent directory traversal (..)'
                };
            }

            // Check path length
            if (path.length > this.rules.maxLength) {
                return {
                    isValid: false,
                    error: `Path length exceeds maximum of ${this.rules.maxLength} characters`
                };
            }

            // Check path depth
            const segments = path.split('/').filter(Boolean);
            if (segments.length > this.rules.maxDepth) {
                return {
                    isValid: false,
                    error: `Path depth exceeds maximum of ${this.rules.maxDepth} levels`
                };
            }

            // Validate project name (first segment)
            const projectName = segments[0];
            if (!this.validateProjectName(projectName)) {
                return {
                    isValid: false,
                    error: `Invalid project name: ${projectName}. Must match pattern ${this.rules.projectNamePattern} and be <= ${this.rules.maxProjectNameLength} characters`
                };
            }

            // Check for invalid characters
            if (!this.rules.allowedCharacters.test(path)) {
                return {
                    isValid: false,
                    error: 'Path contains invalid characters. Only alphanumeric, dash, and underscore allowed'
                };
            }

            // Sanitize path
            const sanitizedPath = this.sanitizePath(path);
            return {
                isValid: true,
                sanitizedPath
            };
        } catch (error) {
            PathValidator.getLogger().error('Path validation error', { error, path });
            throw createError(
                ErrorCodes.VALIDATION_ERROR,
                'Path validation failed',
                'validatePath',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Validates a project name against naming rules
     */
    validateProjectName(name: string): boolean {
        if (!name) return false;
        if (name.length > this.rules.maxProjectNameLength) return false;
        return this.rules.projectNamePattern.test(name);
    }

    /**
     * Sanitizes a path by normalizing slashes and removing redundant separators
     */
    private sanitizePath(path: string): string {
        // Normalize slashes
        let sanitized = path.replace(/\\/g, '/');
        
        // Remove leading/trailing slashes
        sanitized = sanitized.replace(/^\/+|\/+$/g, '');
        
        // Normalize multiple slashes
        sanitized = sanitized.replace(/\/+/g, '/');
        
        return sanitized;
    }

    /**
     * Validates a task path and its parent path together
     * Ensures parent-child relationship is valid
     */
    validateTaskPath(path: string, parentPath?: string): PathValidationResult {
        // First validate the task path
        const pathResult = this.validatePath(path);
        if (!pathResult.isValid) {
            return pathResult;
        }

        // If no parent path, task path is valid
        if (!parentPath) {
            return pathResult;
        }

        // Validate parent path
        const parentResult = this.validatePath(parentPath);
        if (!parentResult.isValid) {
            return {
                isValid: false,
                error: `Invalid parent path: ${parentResult.error}`
            };
        }

        // Ensure task is actually a child of the parent
        const sanitizedPath = pathResult.sanitizedPath!;
        const sanitizedParent = parentResult.sanitizedPath!;
        
        if (!sanitizedPath.startsWith(`${sanitizedParent}/`)) {
            return {
                isValid: false,
                error: `Task path ${sanitizedPath} is not a child of parent path ${sanitizedParent}`
            };
        }

        // Ensure only one level of nesting from parent
        const pathDepth = sanitizedPath.split('/').length;
        const parentDepth = sanitizedParent.split('/').length;
        if (pathDepth !== parentDepth + 1) {
            return {
                isValid: false,
                error: `Task must be direct child of parent. Path ${sanitizedPath} is nested too deeply under ${sanitizedParent}`
            };
        }

        return {
            isValid: true,
            sanitizedPath: pathResult.sanitizedPath
        };
    }
}

================
File: src/index.ts
================
import { Logger } from './logging/index.js';
import { TaskManager } from './task-manager.js';
import { createStorage } from './storage/index.js';
import { AtlasServer } from './server/index.js';
import { EventManager } from './events/event-manager.js';
import { EventTypes } from './types/events.js';
import { BaseError, ErrorCodes, createError } from './errors/index.js';
import { ConfigManager } from './config/index.js';
import { join } from 'path';
import { promises as fs } from 'fs';

import { TaskStorage } from './types/storage.js';
import { CreateTaskInput, UpdateTaskInput, TaskStatus } from './types/task.js';

let server: AtlasServer;
let storage: TaskStorage;
let taskManager: TaskManager;

async function main() {
    // Load environment variables from .env file if present
    try {
        const { config } = await import('dotenv');
        config();
    } catch (error) {
        // Ignore error if .env file doesn't exist
    }

    // Get home directory in a cross-platform way
    const homeDir = process.env.HOME || process.env.USERPROFILE || '';

    const logDir = process.env.ATLAS_STORAGE_DIR ? 
        join(process.env.ATLAS_STORAGE_DIR, 'logs') : 
        join(homeDir, 'Documents', 'Cline', 'mcp-workspace', 'ATLAS', 'logs');

    // Create log directory with proper permissions (mode is ignored on Windows)
    await fs.mkdir(logDir, { recursive: true, ...(process.platform !== 'win32' && { mode: 0o755 }) });

    // Initialize logger with explicit file permissions and await initialization
    const logger = await Logger.initialize({
        console: true,
        file: true,
        minLevel: 'debug',
        logDir: logDir,  // Ensure logDir is explicitly set
        maxFileSize: 5 * 1024 * 1024, // 5MB
        maxFiles: 5,
        noColors: false  // Enable colors for better readability
    });
    logger.info('Logger initialized', { logDir, permissions: '0755' });

    // Ensure logger is fully initialized before proceeding
    await new Promise(resolve => setTimeout(resolve, 100));

    // Increase event listener limits to prevent warnings
    process.setMaxListeners(20);

    // Initialize components in correct order
    const eventManager = await EventManager.initialize();
    const configManager = await ConfigManager.initialize({
        logging: {
            console: true,
            file: true,
            level: 'debug',
            maxFiles: 5,
            maxSize: 5242880, // 5MB
            dir: logDir
        },
        storage: {
            baseDir: process.env.ATLAS_STORAGE_DIR || 'atlas-tasks',
            name: process.env.ATLAS_STORAGE_NAME || 'atlas-tasks',
            connection: {
                maxRetries: 1,
                retryDelay: 500,
                busyTimeout: 2000
            },
            performance: {
                checkpointInterval: 60000,
                cacheSize: 1000,
                mmapSize: 1024 * 1024 * 1024, // 1GB
                pageSize: 4096
            }
        }
    });

    const config = configManager.getConfig();

    try {

        // Emit system startup event
        eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_STARTUP,
            timestamp: Date.now(),
            metadata: {
                version: '0.1.0',
                environment: process.env.NODE_ENV || 'development'
            }
        });

        // Initialize storage with mutex
        storage = await createStorage(config.storage!);
        
        // Initialize task manager with existing storage instance
        taskManager = await TaskManager.getInstance(storage);

        // Run maintenance after initialization
        await storage.vacuum();
        await storage.analyze();
        await storage.checkpoint();

        // Initialize server only if it doesn't exist
        if (!server) {
            server = await AtlasServer.getInstance(
            {
                name: 'atlas-mcp-server',
                version: '0.1.0',
                maxRequestsPerMinute: 600,
                requestTimeout: 30000,
                shutdownTimeout: 5000
            },
            {
                listTools: async () => ({
                    tools: [
                        // Task CRUD operations
                        {
                            name: 'create_task',
                            description: 'Create a new task in the hierarchical task structure. Tasks can be organized in a tree-like structure with parent-child relationships and dependencies. Each task has a unique path identifier, metadata, and status tracking.\n\nBest Practices:\n- Use descriptive path names that reflect the task hierarchy (e.g., "project/feature/subtask")\n- Set appropriate task types (TASK for work items, GROUP for organization, MILESTONE for major checkpoints)\n- Include detailed descriptions for better context\n- Use metadata for custom fields like priority, tags, or deadlines\n- Consider dependencies carefully to avoid circular references\n\nExample:\n{\n  "path": "website/auth/login-form",\n  "name": "Implement login form",\n  "description": "Create React component for user authentication",\n  "type": "TASK",\n  "parentPath": "website/auth",\n  "dependencies": ["website/auth/api-endpoints"],\n  "metadata": {\n    "priority": "high",\n    "estimatedHours": 4,\n    "tags": ["frontend", "security"]\n  }\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    path: { 
                                        type: 'string',
                                        description: 'Optional: Unique path identifier for the task (e.g., "project/feature/subtask"). If not provided, will be generated from name'
                                    },
                                    name: { 
                                        type: 'string',
                                        description: 'Required: Display name of the task. This is the only required field'
                                    },
                                    description: { 
                                        type: 'string',
                                        description: 'Optional: Detailed description of the task'
                                    },
                                    type: { 
                                        type: 'string', 
                                        enum: ['TASK', 'GROUP', 'MILESTONE'],
                                        description: 'Optional: Type of task: TASK (individual task), GROUP (container), or MILESTONE (major checkpoint). Defaults to TASK'
                                    },
                                    parentPath: { 
                                        type: 'string',
                                        description: 'Optional: Path of the parent task if this is a subtask. Used for hierarchical organization'
                                    },
                                    dependencies: { 
                                        type: 'array', 
                                        items: { type: 'string' },
                                        description: 'Optional: Array of task paths that must be completed before this task can start. Used for dependency tracking'
                                    },
                                    metadata: { 
                                        type: 'object',
                                        description: 'Optional: Additional task metadata like priority, tags, or custom fields. Can store any JSON-serializable data'
                                    }
                                },
                                required: ['name']
                            }
                        },
                        {
                            name: 'update_task',
                            description: 'Update an existing task\'s properties including status, dependencies, and metadata. All changes are validated for consistency and dependency cycles.\n\nBest Practices:\n- Update only the fields that need to change\n- Use appropriate status values to track progress\n- Validate dependencies before updating\n- Keep metadata consistent across updates\n- Consider impact on dependent tasks\n\nExample:\n{\n  "path": "website/auth/login-form",\n  "updates": {\n    "status": "IN_PROGRESS",\n    "description": "Updated implementation details...",\n    "metadata": {\n      "assignee": "john.doe",\n      "progress": 50\n    }\n  }\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    path: { 
                                        type: 'string',
                                        description: 'Required: Path of the task to update. Must be an existing task path'
                                    },
                                    updates: {
                                        type: 'object',
                                        description: 'Required: Fields to update on the task. At least one update field must be provided',
                                        properties: {
                                                name: { 
                                                    type: 'string',
                                                    description: 'Optional: New display name for the task'
                                                },
                                                description: { 
                                                    type: 'string',
                                                    description: 'Optional: New detailed description for the task'
                                                },
                                                status: { 
                                                    type: 'string', 
                                                    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                                                    description: 'Optional: New status for the task. Must be one of the defined status values'
                                                },
                                                dependencies: { 
                                                    type: 'array', 
                                                    items: { type: 'string' },
                                                    description: 'Optional: New list of dependency task paths. Replaces existing dependencies'
                                                },
                                                metadata: { 
                                                    type: 'object',
                                                    description: 'Optional: Updated task metadata. Merges with existing metadata'
                                                }
                                        }
                                    }
                                },
                                required: ['path', 'updates']
                            }
                        },
                        {
                            name: 'delete_task',
                            description: 'Delete a task and all its subtasks recursively. This operation cascades through the task hierarchy and cannot be undone.\n\nBest Practices:\n- Verify task path carefully before deletion\n- Check for dependent tasks that may be affected\n- Consider archiving important tasks instead of deletion\n- Back up task data if needed before deletion\n- Update dependent task references after deletion\n\nExample:\n{\n  "path": "website/auth"\n  // Will delete auth task and all subtasks like login-form, etc.\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    path: { 
                                        type: 'string',
                                        description: 'Required: Path of the task to delete. Will recursively delete this task and all its subtasks'
                                    }
                                },
                                required: ['path']
                            }
                        },
                        {
                            name: 'get_tasks_by_status',
                            description: 'Retrieve all tasks with a specific status. Useful for monitoring progress, finding blocked tasks, or generating status reports.\n\nStatus Values:\n- PENDING: Not started\n- IN_PROGRESS: Currently being worked on\n- COMPLETED: Finished successfully\n- FAILED: Encountered errors/issues\n- BLOCKED: Waiting on dependencies\n\nExample:\n{\n  "status": "BLOCKED"\n  // Returns all blocked tasks for investigation\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    status: { 
                                        type: 'string', 
                                        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                                        description: 'Required: Status value to filter tasks by. Must be one of the defined status values'
                                    }
                                },
                                required: ['status']
                            }
                        },
                        {
                            name: 'get_tasks_by_path',
                            description: 'Retrieve tasks matching a glob pattern. Supports flexible path matching for finding related tasks.\n\nPattern Examples:\n- "project/*": Direct children of project\n- "project/**": All tasks under project (recursive)\n- "*/feature": Feature tasks in any project\n- "auth/login*": All login-related tasks in auth\n\nBest Practices:\n- Use specific patterns to limit results\n- Consider hierarchy depth when using **\n- Combine with status/metadata filtering\n\nExample:\n{\n  "pattern": "website/auth/**"\n  // Returns all tasks under auth hierarchy\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    pattern: { 
                                        type: 'string',
                                        description: 'Required: Glob pattern to match task paths. Supports * for single level and ** for recursive matching'
                                    }
                                },
                                required: ['pattern']
                            }
                        },
                        {
                            name: 'get_subtasks',
                            description: 'Retrieve all direct subtasks of a given task. Returns only immediate children, not the entire subtree.\n\nBest Practices:\n- Use for targeted task management\n- Combine with get_tasks_by_path for deep hierarchies\n- Check subtask status for progress tracking\n- Monitor subtask dependencies\n\nExample:\n{\n  "parentPath": "website/auth"\n  // Returns direct subtasks like login-form, signup-form, etc.\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    parentPath: { 
                                        type: 'string',
                                        description: 'Required: Path of the parent task to get subtasks for. Must be an existing task path'
                                    }
                                },
                                required: ['parentPath']
                            }
                        },
                        {
                            name: 'bulk_task_operations',
                            description: 'Execute multiple task operations atomically in a single transaction. Ensures data consistency by rolling back all changes if any operation fails.\n\nSupported Operations:\n- create: Add new tasks\n- update: Modify existing tasks\n- delete: Remove tasks and subtasks\n\nBest Practices:\n- Group related changes together\n- Order operations to handle dependencies\n- Keep transactions focused and minimal\n- Include proper error handling\n- Validate data before submission\n\nExample:\n{\n  "operations": [\n    {\n      "type": "create",\n      "path": "website/auth/oauth",\n      "data": {\n        "name": "OAuth Integration",\n        "type": "TASK"\n      }\n    },\n    {\n      "type": "update",\n      "path": "website/auth/login-form",\n      "data": {\n        "status": "COMPLETED"\n      }\n    }\n  ]\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    operations: {
                                        type: 'array',
                                        description: 'Required: Array of task operations to execute atomically. Must contain at least one operation. All operations are executed in a single transaction - if any operation fails, all changes are rolled back',
                                        items: {
                                            type: 'object',
                                            properties: {
                                                type: { 
                                                    type: 'string', 
                                                    enum: ['create', 'update', 'delete'],
                                                    description: 'Type of operation to perform'
                                                },
                                                path: { 
                                                    type: 'string',
                                                    description: 'Task path the operation applies to'
                                                },
                                                data: { 
                                                    type: 'object',
                                                    description: 'Operation data (CreateTaskInput for create, UpdateTaskInput for update)'
                                                }
                                            },
                                            required: ['type', 'path']
                                        }
                                    }
                                },
                                required: ['operations']
                            }
                        },
                        // Database maintenance operations
                        {
                            name: 'clear_all_tasks',
                            description: 'Clear all tasks from the database and reset all caches. This is a destructive operation that requires explicit confirmation.\n\nBest Practices:\n- Use only for complete system reset\n- Backup data before clearing\n- Verify confirmation requirement\n- Plan for cache rebuild time\n- Consider selective deletion instead\n\nExample:\n{\n  "confirm": true\n  // Must be explicitly set to true\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    confirm: { 
                                        type: 'boolean',
                                        description: 'Required: Must be explicitly set to true to confirm deletion. This is a safety measure for this destructive operation'
                                    }
                                },
                                required: ['confirm']
                            }
                        },
                        {
                            name: 'vacuum_database',
                            description: 'Optimize database storage and performance by cleaning up unused space and updating statistics.\n\nBest Practices:\n- Run during low-usage periods\n- Schedule regular maintenance\n- Monitor space reclamation\n- Update statistics for query optimization\n- Back up before major operations\n\nExample:\n{\n  "analyze": true\n  // Also updates query statistics\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    analyze: { 
                                        type: 'boolean',
                                        description: 'Optional: Whether to run ANALYZE after VACUUM to update database statistics. Defaults to false'
                                    }
                                }
                            }
                        },
                        {
                            name: 'repair_relationships',
                            description: 'Repair parent-child relationships and fix inconsistencies in the task hierarchy. Validates and corrects task relationships, orphaned tasks, and broken dependencies.\n\nBest Practices:\n- Run in dry-run mode first\n- Fix critical paths immediately\n- Schedule regular validation\n- Monitor repair results\n- Back up before repairs\n\nExample:\n{\n  "dryRun": true,\n  "pathPattern": "website/**"\n  // Check website hierarchy without making changes\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    dryRun: { 
                                        type: 'boolean',
                                        description: 'Optional: If true, only report issues without fixing them. Useful for safely checking what would be repaired. Defaults to false'
                                    },
                                    pathPattern: { 
                                        type: 'string',
                                        description: 'Optional: Pattern to limit which tasks to check relationships for. If not provided, checks all tasks'
                                    }
                                }
                            }
                        }
                    ]
                }),
                handleToolCall: async (request) => {
                    const name = request.params?.name as string;
                    const args = request.params?.arguments as Record<string, any>;
                    const eventManager = EventManager.getInstance();
                    let result;

                    try {
                        // Emit tool start event
                        eventManager.emitSystemEvent({
                            type: EventTypes.TOOL_STARTED,
                            timestamp: Date.now(),
                            metadata: {
                                tool: name,
                                args
                            }
                        });

                        switch (name) {
                        case 'create_task':
                            result = await taskManager.createTask(args as CreateTaskInput);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'update_task':
                            result = await taskManager.updateTask(args.path as string, args.updates as UpdateTaskInput);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'delete_task':
                            await taskManager.deleteTask(args.path as string);
                            return {
                                content: [{
                                    type: 'text',
                                    text: 'Task deleted successfully'
                                }]
                            };
                        case 'get_tasks_by_status':
                            result = await taskManager.getTasksByStatus(args.status as TaskStatus);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'get_tasks_by_path':
                            result = await taskManager.listTasks(args.pattern as string);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'get_subtasks':
                            result = await taskManager.getSubtasks(args.parentPath as string);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'bulk_task_operations':
                            result = await taskManager.bulkTaskOperations(args.operations as Array<{ type: 'create' | 'update' | 'delete', path: string, data?: CreateTaskInput | UpdateTaskInput }>);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'clear_all_tasks':
                            await taskManager.clearAllTasks(args.confirm as boolean);
                            return {
                                content: [{
                                    type: 'text',
                                    text: 'All tasks cleared successfully'
                                }]
                            };
                        case 'vacuum_database':
                            await taskManager.vacuumDatabase(args.analyze as boolean);
                            return {
                                content: [{
                                    type: 'text',
                                    text: 'Database vacuumed successfully'
                                }]
                            };
                        case 'repair_relationships':
                            result = await taskManager.repairRelationships(args.dryRun as boolean, args.pathPattern as string | undefined);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        default:
                            throw createError(
                                ErrorCodes.INVALID_INPUT,
                                `Unknown tool: ${name}`,
                                'handleToolCall'
                            );
                    }
                } catch (error) {
                    // Emit tool error event
                    eventManager.emitErrorEvent({
                        type: EventTypes.SYSTEM_ERROR,
                        timestamp: Date.now(),
                        error: error instanceof Error ? error : new Error(String(error)),
                        context: {
                            component: 'ToolHandler',
                            operation: name,
                            args
                        }
                    });

                    // Format error response
                    const errorMessage = error instanceof BaseError 
                        ? error.getUserMessage()
                        : String(error);

                    return {
                        content: [{
                            type: 'text',
                            text: JSON.stringify({
                                error: errorMessage,
                                code: error instanceof BaseError ? error.code : ErrorCodes.INTERNAL_ERROR
                            }, null, 2)
                        }],
                        isError: true
                    };
                }
                },
                getStorageMetrics: async () => await storage.getMetrics(),
                clearCaches: async () => {
                    await taskManager.clearCaches();
                },
                cleanup: async () => {
                    await taskManager.close();
                }
            }
        );
        }
    } catch (error) {
        // Emit system error event
        eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_ERROR,
            timestamp: Date.now(),
            metadata: {
                error: error instanceof Error ? error : new Error(String(error))
            }
        });

        logger.error('Failed to start server', error);
        process.exit(1);
    }

    // Handle graceful shutdown
    const shutdown = async (reason: string = 'graceful_shutdown') => {
        try {
            // Emit system shutdown event
            eventManager.emitSystemEvent({
                type: EventTypes.SYSTEM_SHUTDOWN,
                timestamp: Date.now(),
                metadata: { reason }
            });

            // Cleanup in specific order to ensure proper shutdown
            try {
                // First stop accepting new requests
                if (server) {
                    await server.shutdown();
                }

                // Then cleanup task manager and its resources
                if (taskManager) {
                    await taskManager.cleanup();
                }

                // Finally close storage
                if (storage) {
                    await storage.close();
                }

                // Clear event manager
                eventManager.removeAllListeners();

                // Force final cleanup
                if (global.gc) {
                    global.gc();
                }

                // Remove process event listeners
                process.removeAllListeners();
            } catch (cleanupError) {
                logger.error('Error during component cleanup', cleanupError);
                // Continue with shutdown despite cleanup errors
            }

            // Final logging before exit
            logger.info('Server shutdown completed', { reason });
            
            // Exit after cleanup
            process.nextTick(() => process.exit(0));
        } catch (error) {
            logger.error('Error during shutdown', error);
            process.nextTick(() => process.exit(1));
        }
    };

    // Handle various shutdown signals with Windows compatibility
    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('beforeExit', () => shutdown('beforeExit'));
    
    // Windows-specific handling for CTRL+C and other termination signals
    if (process.platform === 'win32') {
        const readline = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        
        readline.on('SIGINT', () => {
            process.emit('SIGINT');
        });

        // Handle Windows-specific process termination
        process.on('SIGHUP', () => shutdown('SIGHUP'));
        process.on('SIGBREAK', () => shutdown('SIGBREAK'));
    }

    process.on('exit', () => {
        try {
            // Synchronous cleanup for exit event
            if (global.gc) {
                global.gc();
            }
        } catch (error) {
            console.error('Error during final cleanup:', error);
        }
    });
}

main().catch((error) => {
    // Get logger instance if available, otherwise fallback to console
    try {
        const logger = Logger.getInstance();
        logger.fatal('Fatal error during startup', error);
    } catch {
        // If logger isn't initialized, fallback to console
        console.error('Fatal error:', error);
    }
    process.exit(1);
});

================
File: src/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-26T20:11:36.247Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
config/
  index.ts
errors/
  index.ts
events/
  event-manager.ts
logging/
  index.ts
server/
  health-monitor.ts
  index.ts
  metrics-collector.ts
  rate-limiter.ts
  request-tracer.ts
storage/
  core/
    connection/
      health.ts
      manager.ts
      pool.ts
      state.ts
    query/
      builder.ts
      executor.ts
      optimizer.ts
    schema/
      backup.ts
      migrations.ts
      validator.ts
    transactions/
      manager.ts
      scope.ts
    wal/
      manager.ts
    index.ts
  monitoring/
    health.ts
    index.ts
    metrics.ts
  sqlite/
    index.ts
    init.ts
    storage.ts
  connection-manager.ts
  factory.ts
  index.ts
  sqlite-storage.ts
task/
  core/
    batch/
      common/
        batch-utils.ts
      base-batch-processor.ts
      dependency-aware-batch-processor.ts
      generic-batch-processor.ts
      index.ts
      status-update-batch.ts
      task-status-batch-processor.ts
    cache/
      cache-coordinator.ts
      cache-manager.ts
      cache-metrics.ts
      index.ts
    indexing/
      index-manager.ts
      index.ts
    transactions/
      index.ts
      transaction-manager.ts
    index.ts
    task-store.ts
  operations/
    index.ts
    task-operations.ts
  validation/
    index.ts
    task-validator.ts
tools/
  handler.ts
  index.ts
  schemas.ts
  session-schemas.ts
  utils.ts
types/
  batch.ts
  cache.ts
  config.ts
  error.ts
  events.ts
  index.ts
  indexing.ts
  logging.ts
  project.ts
  session.ts
  storage.ts
  task.ts
  transaction.ts
utils/
  id-generator.ts
  path-utils.ts
  pattern-matcher.ts
validation/
  config.ts
  id-schema.ts
  index.ts
  logging.ts
  path-validator.ts
index.ts
task-manager.ts

================================================================
Repository Files
================================================================

================
File: config/index.ts
================
/**
 * Configuration module
 * Handles application configuration management
 */

import { ConfigError, ErrorCodes } from '../errors/index.js';
import { LogLevel, LogLevels } from '../types/logging.js';
import { resolve, join } from 'path';
import { homedir } from 'os';

/**
 * Environment variable names
 */
export const EnvVars = {
    NODE_ENV: 'NODE_ENV',
    LOG_LEVEL: 'LOG_LEVEL',
    ATLAS_STORAGE_DIR: 'ATLAS_STORAGE_DIR',
    ATLAS_STORAGE_NAME: 'ATLAS_STORAGE_NAME'
} as const;

/**
 * Environment types
 */
export const Environments = {
    DEVELOPMENT: 'development',
    PRODUCTION: 'production',
    TEST: 'test'
} as const;

/**
 * Logging configuration type
 */
export interface LoggingConfig {
    level: LogLevel;
    console: boolean;
    file: boolean;
    dir?: string;
    maxFiles: number;
    maxSize: number;
}

/**
 * Storage configuration type
 */
export interface StorageConfig {
    baseDir: string;
    name: string;
    connection?: {
        maxRetries?: number;
        retryDelay?: number;
        busyTimeout?: number;
    };
    performance?: {
        checkpointInterval?: number;
        cacheSize?: number;
        mmapSize?: number;
        pageSize?: number;
    };
}

/**
 * Application configuration type
 */
export interface AppConfig {
    env: string;
    logging: LoggingConfig;
    storage: StorageConfig;  // Make storage required
}

export interface PartialAppConfig {
    env?: string;
    logging?: Partial<LoggingConfig>;
    storage?: Partial<StorageConfig>;
}

/**
 * Configuration schema
 */
export const configSchema = {
    env: {
        type: 'string',
        enum: [
            Environments.DEVELOPMENT,
            Environments.PRODUCTION,
            Environments.TEST
        ],
        default: Environments.DEVELOPMENT
    },
    logging: {
        type: 'object',
        properties: {
            level: {
                type: 'string',
                enum: Object.values(LogLevels),
                default: LogLevels.INFO
            },
            console: {
                type: 'boolean',
                default: true
            },
            file: {
                type: 'boolean',
                default: false
            },
            dir: {
                type: 'string',
                optional: true
            },
            maxFiles: {
                type: 'number',
                minimum: 1,
                default: 5
            },
            maxSize: {
                type: 'number',
                minimum: 1024,
                default: 5242880 // 5MB
            }
        },
        required: ['level']
    },
    storage: {
        type: 'object',
        properties: {
            baseDir: {
                type: 'string'
            },
            name: {
                type: 'string'
            },
            connection: {
                type: 'object',
                properties: {
                    maxRetries: {
                        type: 'number',
                        minimum: 1,
                        optional: true
                    },
                    retryDelay: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    busyTimeout: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    }
                },
                optional: true
            },
            performance: {
                type: 'object',
                properties: {
                    checkpointInterval: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    cacheSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    mmapSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    },
                    pageSize: {
                        type: 'number',
                        minimum: 0,
                        optional: true
                    }
                },
                optional: true
            }
        },
        required: ['baseDir', 'name']
    }
};

/**
 * Default logging configuration
 */
const defaultLoggingConfig: LoggingConfig = {
    level: LogLevels.INFO,
    console: true,
    file: true,
    dir: 'logs',
    maxFiles: 5,
    maxSize: 5242880
};

/**
 * Default configuration values
 */
export const defaultConfig: AppConfig = {
    env: Environments.DEVELOPMENT,
    logging: defaultLoggingConfig,
    storage: {
        baseDir: join(process.platform === 'win32' ? 
            process.env.LOCALAPPDATA || join(homedir(), 'AppData', 'Local') :
            process.env.XDG_DATA_HOME || join(homedir(), '.local', 'share'),
            'atlas-mcp', 'storage'
        ),
        name: 'atlas-tasks',
        connection: {
            maxRetries: 3,
            retryDelay: 1000,
            busyTimeout: 5000
        },
        performance: {
            checkpointInterval: 300000, // 5 minutes
            cacheSize: 2000,
            mmapSize: 30000000000, // 30GB
            pageSize: 4096
        }
    }
};

/**
 * Configuration manager class
 */
export class ConfigManager {
    private static instance: ConfigManager | null = null;
    private static initializationPromise: Promise<ConfigManager> | null = null;
    private config: AppConfig;
    private initialized = false;

    private constructor() {
        this.config = defaultConfig;
    }

    /**
     * Gets the configuration manager instance
     */
    static getInstance(): ConfigManager {
        if (!ConfigManager.instance || !ConfigManager.instance.initialized) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Configuration not initialized. Call ConfigManager.initialize() first.'
            );
        }
        return ConfigManager.instance;
    }

    /**
     * Initializes the configuration manager with custom config
     */
    static async initialize(config?: PartialAppConfig): Promise<ConfigManager> {
        // Return existing instance if available
        if (ConfigManager.instance && ConfigManager.instance.initialized) {
            return ConfigManager.instance;
        }

        // If initialization is in progress, wait for it
        if (ConfigManager.initializationPromise) {
            return ConfigManager.initializationPromise;
        }

        // Start new initialization with mutex
        ConfigManager.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (ConfigManager.instance && ConfigManager.instance.initialized) {
                    return ConfigManager.instance;
                }

                ConfigManager.instance = new ConfigManager();
                if (config) {
                    await ConfigManager.instance.updateConfig(config);
                }
                ConfigManager.instance.initialized = true;
                return ConfigManager.instance;
            } catch (error) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    `Failed to initialize configuration: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                ConfigManager.initializationPromise = null;
            }
        })();

        return ConfigManager.initializationPromise;
    }

    /**
     * Gets the current configuration
     */
    getConfig(): AppConfig {
        return { ...this.config };
    }

    /**
     * Updates the configuration
     */
    async updateConfig(updates: PartialAppConfig): Promise<void> {
        const newConfig = {
            ...this.config,
            ...updates,
            logging: {
                ...this.config.logging,
                ...(updates.logging || {})
            },
            storage: {
                ...this.config.storage,
                ...(updates.storage || {})
            }
        };

        // Load environment config and create directories
        const envConfig = await this.loadEnvConfig(newConfig);
        
        // Merge with environment config
        const finalConfig = {
            ...newConfig,
            storage: {
                ...newConfig.storage,
                ...envConfig.storage
            }
        };

        this.validateConfig(finalConfig);
        this.config = finalConfig;
    }

    /**
     * Gets platform-specific user data directory
     */
    private getUserDataDir(): string {
        // Try environment variables first
        if (process.env.LOCALAPPDATA) {
            return process.env.LOCALAPPDATA;
        }
        if (process.env.XDG_DATA_HOME) {
            return process.env.XDG_DATA_HOME;
        }

        // Fall back to platform-specific defaults
        const home = homedir();
        return process.platform === 'win32'
            ? join(home, 'AppData', 'Local')
            : join(home, '.local', 'share');
    }

    /**
     * Loads configuration from environment variables and ensures directories exist
     */
    private async loadEnvConfig(customConfig: PartialAppConfig): Promise<AppConfig> {
        const currentEnv = process.env[EnvVars.NODE_ENV];
        const currentLogLevel = process.env[EnvVars.LOG_LEVEL];
        
        // Handle storage directory with platform-agnostic paths
        let storageDir = customConfig.storage?.baseDir || process.env[EnvVars.ATLAS_STORAGE_DIR];
        let storageName = customConfig.storage?.name || process.env[EnvVars.ATLAS_STORAGE_NAME];
        
        // Use defaults if env vars not provided
        if (!storageDir) {
            const userDataDir = this.getUserDataDir();
            storageDir = join(userDataDir, 'atlas-mcp', 'storage');
        }

        if (!storageName) {
            storageName = 'atlas-tasks';
        }

        // Ensure absolute path and create directory if needed
        storageDir = resolve(storageDir);
        try {
            const fs = await import('fs/promises');
            await fs.mkdir(storageDir, { 
                recursive: true,
                // Skip mode on Windows as it's ignored
                ...(process.platform !== 'win32' && { mode: 0o755 })
            });
        } catch (error) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                `Failed to create storage directory: ${error instanceof Error ? error.message : String(error)}`
            );
        }

        const config: AppConfig = {
            env: currentEnv || Environments.DEVELOPMENT,
            storage: {
                baseDir: storageDir,
                name: storageName,
                connection: {
                    maxRetries: 3,
                    retryDelay: 1000,
                    busyTimeout: 5000
                },
                performance: {
                    checkpointInterval: 300000, // 5 minutes
                    cacheSize: 2000,
                    mmapSize: 30000000000, // 30GB
                    pageSize: 4096
                }
            },
            logging: { ...defaultLoggingConfig }
        };

        if (currentEnv) {
            if (!Object.values(Environments).includes(currentEnv as any)) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    'Invalid environment'
                );
            }
            config.env = currentEnv;
        }

        if (currentLogLevel) {
            const level = currentLogLevel.toLowerCase();
            if (!Object.values(LogLevels).includes(level as any)) {
                throw new ConfigError(
                    ErrorCodes.CONFIG_INVALID,
                    'Invalid log level'
                );
            }
            config.logging.level = level as LogLevel;
        }

        return config;
    }

    /**
     * Validates configuration against schema
     */
    private validateConfig(config: AppConfig): void {
        if (!config.storage?.baseDir) {
            throw new ConfigError(
                ErrorCodes.CONFIG_MISSING,
                'Storage directory must be provided'
            );
        }

        if (!config.storage?.name) {
            throw new ConfigError(
                ErrorCodes.CONFIG_MISSING,
                'Storage name must be provided'
            );
        }

        if (config.logging?.level && !Object.values(LogLevels).includes(config.logging.level)) {
            throw new ConfigError(
                ErrorCodes.CONFIG_INVALID,
                'Invalid log level'
            );
        }
    }
}

/**
 * Creates a default configuration manager
 */
export function createDefaultConfig(): ConfigManager {
    return ConfigManager.getInstance();
}

================
File: errors/index.ts
================
/**
 * Error codes and error creation utility
 */
export const ErrorCodes = {
    // Migration errors
    MIGRATION_ERROR: 'MIGRATION_1001',
    // Task errors (1000-1999)
    TASK_NOT_FOUND: 'TASK_1001',
    TASK_VALIDATION: 'TASK_1002',
    TASK_DEPENDENCY: 'TASK_1003',
    TASK_STATUS: 'TASK_1004',
    TASK_DUPLICATE: 'TASK_1005',
    TASK_CYCLE: 'TASK_1006',
    TASK_INVALID_PATH: 'TASK_1007',
    TASK_PARENT_NOT_FOUND: 'TASK_1008',
    TASK_PARENT_TYPE: 'TASK_1009',

    // Storage errors (2000-2999)
    STORAGE_ERROR: 'STORAGE_2001',
    STORAGE_READ: 'STORAGE_2002',
    STORAGE_WRITE: 'STORAGE_2003',
    STORAGE_DELETE: 'STORAGE_2004',
    STORAGE_INIT: 'STORAGE_2005',
    STORAGE_CLOSE: 'STORAGE_2006',

    // Transaction errors (3000-3999)
    TRANSACTION_ERROR: 'TRANSACTION_3001',
    TRANSACTION_TIMEOUT: 'TRANSACTION_3002',
    TRANSACTION_DEADLOCK: 'TRANSACTION_3003',
    TRANSACTION_ROLLBACK: 'TRANSACTION_3004',
    TRANSACTION_COMMIT: 'TRANSACTION_3005',
    TRANSACTION_ISOLATION: 'TRANSACTION_3006',
    TRANSACTION_NESTED: 'TRANSACTION_3007',

    // Connection errors (4000-4999)
    CONNECTION_ERROR: 'CONNECTION_4001',
    CONNECTION_TIMEOUT: 'CONNECTION_4002',
    CONNECTION_LIMIT: 'CONNECTION_4003',
    CONNECTION_CLOSED: 'CONNECTION_4004',
    CONNECTION_BUSY: 'CONNECTION_4005',

    // Operation errors (5000-5999)
    INVALID_INPUT: 'OPERATION_5001',
    INVALID_STATE: 'OPERATION_5002',
    CONCURRENT_MODIFICATION: 'OPERATION_5003',
    INTERNAL_ERROR: 'OPERATION_5004',
    TIMEOUT: 'OPERATION_5005',
    OPERATION_FAILED: 'OPERATION_5006',
    VALIDATION_ERROR: 'OPERATION_5007',

    // Configuration errors (6000-6999)
    CONFIG_INVALID: 'CONFIG_6001',
    CONFIG_MISSING: 'CONFIG_6002'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

export interface ErrorDetails {
    code: ErrorCode;
    message: string;
    operation?: string;
    cause?: string;
    details?: Record<string, unknown>;
}

export class BaseError extends Error {
    readonly code: ErrorCode;
    readonly operation?: string;
    readonly details?: Record<string, unknown>;

    constructor(details: ErrorDetails) {
        super(details.message);
        this.name = 'BaseError';
        this.code = details.code;
        this.operation = details.operation;
        this.details = details.details;
    }

    getUserMessage(): string {
        return this.message;
    }

    toJSON(): Record<string, unknown> {
        return {
            code: this.code,
            message: this.message,
            operation: this.operation,
            details: this.details
        };
    }
}

/**
 * Create a standardized error with proper code and context
 */
export class ConfigError extends BaseError {
    constructor(code: ErrorCode, message: string, details?: Record<string, unknown>) {
        super({
            code,
            message,
            details
        });
        this.name = 'ConfigError';
    }
}

export function createError(
    code: ErrorCode,
    message: string,
    operation?: string,
    cause?: string,
    details?: Record<string, unknown>
): BaseError {
    const fullMessage = cause ? `${message}: ${cause}` : message;
    return new BaseError({
        code,
        message: fullMessage,
        operation,
        details
    });
}

/**
 * Check if an error is a specific type
 */
export function isErrorType(error: unknown, code: ErrorCode): boolean {
    return error instanceof BaseError && error.code === code;
}

/**
 * Retryable error codes
 */
export const RetryableErrorCodes = {
    CONNECTION_BUSY: ErrorCodes.CONNECTION_BUSY,
    TRANSACTION_DEADLOCK: ErrorCodes.TRANSACTION_DEADLOCK,
    CONNECTION_TIMEOUT: ErrorCodes.CONNECTION_TIMEOUT,
    STORAGE_ERROR: ErrorCodes.STORAGE_ERROR
} as const;

export type RetryableErrorCode = typeof RetryableErrorCodes[keyof typeof RetryableErrorCodes];

/**
 * Check if an error is retryable
 */
export function isRetryableError(error: unknown): boolean {
    if (!(error instanceof BaseError)) return false;

    return Object.values(RetryableErrorCodes).includes(error.code as RetryableErrorCode);
}

/**
 * Format error for logging
 */
export function formatError(error: unknown): Record<string, unknown> {
    if (error instanceof BaseError) {
        return error.toJSON();
    }

    if (error instanceof Error) {
        return {
            message: error.message,
            name: error.name,
            stack: error.stack
        };
    }

    return {
        message: String(error)
    };
}

================
File: events/event-manager.ts
================
import { EventEmitter } from 'events';
import { Logger } from '../logging/index.js';
import {
  AtlasEvent,
  EventHandler,
  EventSubscription,
  EventTypes,
  TaskEvent,
  CacheEvent,
  ErrorEvent,
  BatchEvent,
  TransactionEvent,
  SystemEvent
} from '../types/events.js';

export class EventManager {
  private static instance: EventManager | null = null;
  private static initializationPromise: Promise<EventManager> | null = null;
  private readonly emitter: EventEmitter;
  private static logger: Logger;
  private readonly maxListeners: number = 100;
  private readonly debugMode: boolean;
  private initialized = false;

  private static initLogger(): void {
    if (!EventManager.logger) {
      EventManager.logger = Logger.getInstance().child({ component: 'EventManager' });
    }
  }

  private constructor() {
    EventManager.initLogger();
    this.emitter = new EventEmitter();
    this.emitter.setMaxListeners(this.maxListeners);
    this.debugMode = process.env.NODE_ENV === 'development';
    this.setupErrorHandling();
  }

  static async initialize(): Promise<EventManager> {
    // Return existing instance if available
    if (EventManager.instance) {
      return EventManager.instance;
    }

    // If initialization is in progress, wait for it
    if (EventManager.initializationPromise) {
      return EventManager.initializationPromise;
    }

    // Start new initialization with mutex
    EventManager.initializationPromise = (async () => {
      try {
        // Double-check instance hasn't been created while waiting
        if (EventManager.instance) {
          return EventManager.instance;
        }

        EventManager.instance = new EventManager();
        EventManager.instance.initialized = true;
        return EventManager.instance;
      } catch (error) {
        throw new Error(`Failed to initialize EventManager: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        EventManager.initializationPromise = null;
      }
    })();

    return EventManager.initializationPromise;
  }

  static getInstance(): EventManager {
    if (!EventManager.instance || !EventManager.instance.initialized) {
      throw new Error('EventManager not initialized. Call EventManager.initialize() first.');
    }
    return EventManager.instance;
  }

  emit<T extends AtlasEvent>(event: T): void {
    try {
      if (this.debugMode) {
        const debugInfo: Record<string, unknown> = {
          type: event.type,
          timestamp: event.timestamp
        };

        // Handle different event types' metadata/context
        if ('metadata' in event) {
          debugInfo.metadata = event.metadata;
        } else if ('context' in event) {
          debugInfo.context = event.context;
        }

        EventManager.logger.debug('Emitting event', debugInfo);
      }

      // Add timestamp if not present
      if (!event.timestamp) {
        event.timestamp = Date.now();
      }

      this.emitter.emit(event.type, event);

      // Emit to wildcard listeners
      this.emitter.emit('*', event);
    } catch (error) {
      EventManager.logger.error('Event emission failed', {
        error,
        event: {
          type: event.type,
          timestamp: event.timestamp
        }
      });

      // Emit error event
      this.emitError('event_emission_failed', error as Error, {
        eventType: event.type
      });
    }
  }

  on<T extends AtlasEvent>(
    type: EventTypes | '*',
    handler: EventHandler<T>
  ): EventSubscription {
    if (this.debugMode) {
      EventManager.logger.debug('Adding event listener', { type });
    }

    // Wrap handler to catch errors
    const wrappedHandler = async (event: T) => {
      try {
        await handler(event);
      } catch (error) {
        EventManager.logger.error('Event handler error', {
          error,
          eventType: type
        });
        this.emitError('event_handler_error', error as Error, {
          eventType: type
        });
      }
    };

    this.emitter.on(type, wrappedHandler);

    // Return subscription object
    return {
      unsubscribe: () => {
        this.emitter.off(type, wrappedHandler);
        if (this.debugMode) {
          EventManager.logger.debug('Removed event listener', { type });
        }
      }
    };
  }

  once<T extends AtlasEvent>(
    type: EventTypes | '*',
    handler: EventHandler<T>
  ): EventSubscription {
    if (this.debugMode) {
      EventManager.logger.debug('Adding one-time event listener', { type });
    }

    // Wrap handler to catch errors
    const wrappedHandler = async (event: T) => {
      try {
        await handler(event);
      } catch (error) {
        EventManager.logger.error('One-time event handler error', {
          error,
          eventType: type
        });
        this.emitError('event_handler_error', error as Error, {
          eventType: type,
          oneTime: true
        });
      }
    };

    this.emitter.once(type, wrappedHandler);

    // Return subscription object
    return {
      unsubscribe: () => {
        this.emitter.off(type, wrappedHandler);
        if (this.debugMode) {
          EventManager.logger.debug('Removed one-time event listener', { type });
        }
      }
    };
  }

  removeAllListeners(type?: EventTypes | '*'): void {
    if (type) {
      this.emitter.removeAllListeners(type);
      if (this.debugMode) {
        EventManager.logger.debug('Removed all listeners for event type', { type });
      }
    } else {
      this.emitter.removeAllListeners();
      if (this.debugMode) {
        EventManager.logger.debug('Removed all event listeners');
      }
    }
  }

  listenerCount(type: EventTypes | '*'): number {
    return this.emitter.listenerCount(type);
  }

  private setupErrorHandling(): void {
    // Handle emitter errors
    this.emitter.on('error', (error: Error) => {
      EventManager.logger.error('EventEmitter error', { error });
    });

    // Handle uncaught promise rejections in handlers
    process.on('unhandledRejection', (reason, promise) => {
      EventManager.logger.error('Unhandled promise rejection in event handler', {
        reason,
        promise
      });
    });
  }

  private emitError(
    context: string,
    error: Error,
    metadata?: Record<string, unknown>
  ): void {
    const errorEvent: ErrorEvent = {
      type: EventTypes.SYSTEM_ERROR,
      timestamp: Date.now(),
      error,
      context: {
        component: 'EventManager',
        operation: context,
        ...metadata
      }
    };

    try {
      this.emitter.emit(EventTypes.SYSTEM_ERROR, errorEvent);
    } catch (emitError) {
      // Last resort error logging
      EventManager.logger.error('Failed to emit error event', {
        originalError: error,
        emitError,
        context
      });
    }
  }

  // Typed event emission helpers
  emitTaskEvent(event: TaskEvent): void {
    this.emit(event);
  }

  emitCacheEvent(event: CacheEvent): void {
    this.emit(event);
  }

  emitErrorEvent(event: ErrorEvent): void {
    this.emit(event);
  }

  emitBatchEvent(event: BatchEvent): void {
    this.emit(event);
  }

  emitTransactionEvent(event: TransactionEvent): void {
    this.emit(event);
  }

  emitSystemEvent(event: SystemEvent): void {
    this.emit(event);
  }
}

================
File: logging/index.ts
================
/**
 * Logging module
 * Provides centralized logging functionality with structured output
 */

import { createLogger, format, transports, Logger as WinstonLogger, config as winstonConfig } from 'winston';
import { join } from 'path';
import { mkdirSync } from 'fs';
import { BaseError, ErrorCodes } from '../errors/index.js';
import { LogLevel, LogLevels, LoggerConfig } from '../types/logging.js';

/**
 * Logger class
 * Provides structured logging with context and error handling
 */
export class Logger {
    private static instance: Logger;
    private logger: WinstonLogger;

    private config: LoggerConfig;
    private isShuttingDown = false;

    private constructor(config: LoggerConfig) {
        this.config = config;
        this.logger = this.createLogger(config);
        
        // Handle process events
        process.on('SIGINT', () => this.handleShutdown());
        process.on('SIGTERM', () => this.handleShutdown());
        process.on('exit', () => this.handleShutdown());
    }

    /**
     * Handle graceful shutdown
     */
    private handleShutdown(): void {
        if (this.isShuttingDown) return;
        this.isShuttingDown = true;

        // Close transports
        this.logger.close();
    }

    /**
     * Recreate logger if needed
     */
    private lastHealthCheck = 0;
    private readonly HEALTH_CHECK_INTERVAL = 5000; // 5 seconds

    private ensureLogger(): void {
        if (this.isShuttingDown) return;

        const now = Date.now();
        // Only check every 5 seconds to reduce memory pressure
        if (now - this.lastHealthCheck < this.HEALTH_CHECK_INTERVAL) {
            return;
        }
        
        try {
            // Test if logger is working
            this.logger.log({
                level: 'debug',
                message: 'Logger health check'
            });
            this.lastHealthCheck = now;
        } catch (error) {
            const err = error as Error;
            if (err?.message?.includes('EPIPE')) {
                // Recreate logger with same config
                this.logger = this.createLogger(this.config);
                this.lastHealthCheck = now;
            }
        }
    }

    /**
     * Gets the logger instance
     */
    private static initializationPromise: Promise<Logger> | null = null;

    static getInstance(): Logger {
        if (!Logger.instance) {
            throw new BaseError({
                code: ErrorCodes.INVALID_STATE,
                message: 'Logger not initialized. Call Logger.initialize() first.'
            });
        }
        return Logger.instance;
    }

    /**
     * Initializes the logger with configuration
     */
    static async initialize(config: LoggerConfig): Promise<Logger> {
        // Return existing instance if available
        if (Logger.instance) {
            return Logger.instance;
        }

        // If initialization is in progress, wait for it
        if (Logger.initializationPromise) {
            return Logger.initializationPromise;
        }

        // Start new initialization with mutex
        Logger.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (Logger.instance) {
                    return Logger.instance;
                }

                Logger.instance = new Logger(config);
                return Logger.instance;
            } catch (error) {
                throw new BaseError({
                    code: ErrorCodes.STORAGE_INIT,
                    message: 'Failed to initialize logger',
                    details: { error: error instanceof Error ? error.message : String(error) }
                });
            } finally {
                Logger.initializationPromise = null;
            }
        })();

        return Logger.initializationPromise;
    }

    /**
     * Creates a child logger with additional context
     */
    child(context: Record<string, unknown>): Logger {
        const childLogger = new Logger({
            minLevel: LogLevels.INFO,
            console: true
        });
        childLogger.logger = this.logger.child(context);
        return childLogger;
    }

    /**
     * Logs a debug message
     */
    debug(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.DEBUG, message, context);
    }

    /**
     * Logs an info message
     */
    info(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.INFO, message, context);
    }

    /**
     * Logs a warning message
     */
    warn(message: string, context?: Record<string, unknown>): void {
        this.log(LogLevels.WARN, message, context);
    }

    /**
     * Logs an error message
     */
    error(message: string, error?: unknown, context?: Record<string, unknown>): void {
        const errorInfo = this.formatError(error);
        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
    }

    /**
     * Logs a fatal error message (maps to error level for Winston compatibility)
     */
    fatal(message: string, error?: unknown, context?: Record<string, unknown>): void {
        const errorInfo = this.formatError(error);
        this.log(LogLevels.ERROR, message, { ...context, error: errorInfo });
    }

    /**
     * Creates the Winston logger instance
     */
    private createLogger(config: LoggerConfig): WinstonLogger {
        const loggerTransports = [];

        // Console transport
        if (config.console) {
            const formats = [format.simple()];
            if (!config.noColors) {
                formats.unshift(format.colorize());
            }
            loggerTransports.push(
                new transports.Console({
                    format: format.combine(...formats)
                })
            );
        }

        // File transport
        if (config.file && config.logDir) {
            // Ensure log directory exists with platform-appropriate permissions
            mkdirSync(config.logDir, { 
                recursive: true, 
                // Skip mode on Windows as it's ignored
                ...(process.platform !== 'win32' && { mode: 0o755 })
            });

            const errorLogPath = join(config.logDir, 'error.log');
            const combinedLogPath = join(config.logDir, 'combined.log');

            loggerTransports.push(
                new transports.File({
                    filename: errorLogPath,
                    level: LogLevels.ERROR,
                    maxsize: config.maxFileSize,
                    maxFiles: config.maxFiles,
                    tailable: true // Ensure logs can be read while being written
                }),
                new transports.File({
                    filename: combinedLogPath,
                    maxsize: config.maxFileSize,
                    maxFiles: config.maxFiles,
                    tailable: true
                })
            );
        }

        return createLogger({
            level: config.minLevel,
            format: format.combine(
                format.timestamp(),
                format.json()
            ),
            transports: loggerTransports,
            levels: winstonConfig.npm.levels // Use standard npm levels
        });
    }

    /**
     * Formats an error for logging
     */
    private formatError(error: unknown): Record<string, unknown> | undefined {
        if (!error) return undefined;

        if (error instanceof BaseError) {
            return {
                name: error.name,
                message: error.message,
                code: error.code,
                details: error.details,
                stack: error.stack,
                operation: error.operation,
                timestamp: Date.now()
            };
        }

        if (error instanceof Error) {
            return {
                name: error.name,
                message: error.message,
                stack: error.stack,
                timestamp: Date.now()
            };
        }

        if (error && typeof error === 'object') {
            try {
                return {
                    name: 'ObjectError',
                    message: JSON.stringify(error, null, 2),
                    raw: error,
                    timestamp: Date.now()
                };
            } catch (e) {
                return {
                    name: 'UnserializableError',
                    message: 'Error object could not be stringified',
                    type: typeof error,
                    timestamp: Date.now()
                };
            }
        }

        return {
            name: 'UnknownError',
            message: String(error),
            type: typeof error,
            timestamp: Date.now()
        };
    }

    /**
     * Internal log method
     */
    private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {
        if (this.isShuttingDown) return;

        try {
            // Ensure logger is working
            this.ensureLogger();

            // Ensure context is properly stringified
            const safeContext = context ? this.sanitizeContext(context) : undefined;
            
            this.logger.log({
                level,
                message,
                timestamp: Date.now(),
                ...safeContext
            });
        } catch (error) {
            // If logging fails, write to stderr as fallback
            const fallbackMessage = JSON.stringify({
                level,
                message,
                timestamp: Date.now(),
                error: this.formatError(error)
            });
            process.stderr.write(fallbackMessage + '\n');
        }
    }

    /**
     * Sanitizes context objects for logging
     */
    private sanitizeContext(context: Record<string, unknown>): Record<string, unknown> {
        const sanitized: Record<string, unknown> = {};
        
        for (const [key, value] of Object.entries(context)) {
            if (value instanceof Error || (value && typeof value === 'object')) {
                sanitized[key] = this.formatError(value);
            } else {
                sanitized[key] = value;
            }
        }
        
        return sanitized;
    }
}

/**
 * Creates a logger instance with default configuration
 */
export function createDefaultLogger(): Logger {
    try {
        return Logger.getInstance();
    } catch (error) {
        throw new BaseError({
            code: ErrorCodes.STORAGE_INIT,
            message: 'Failed to create default logger',
            details: { error: error instanceof Error ? error.message : String(error) }
        });
    }
}

/**
 * Re-export types
 */
export type { LogLevel, LoggerConfig } from '../types/logging.js';
export { LogLevels } from '../types/logging.js';

================
File: server/health-monitor.ts
================
/**
 * Health monitoring for system components
 */
import { Logger } from '../logging/index.js';
import { StorageMetrics } from '../types/storage.js';
import { Metrics } from './metrics-collector.js';
import { TaskStatus } from '../types/task.js';

export interface HealthConfig {
    checkInterval?: number;      // How often to run health checks (ms)
    failureThreshold?: number;   // How many consecutive failures before shutdown
    shutdownGracePeriod?: number; // How long to wait before force shutdown (ms)
    clientPingTimeout?: number;  // How long to wait for client ping (ms)
}

export interface HealthStatus {
    healthy: boolean;
    components: {
        storage: boolean;
        rateLimiter: boolean;
        metrics: boolean;
        clientConnected: boolean;
    };
    details?: Record<string, unknown>;
    timestamp: number;
    consecutiveFailures?: number;
    [key: string]: unknown;
}

export interface ComponentStatus {
    storage: StorageMetrics;
    rateLimiter: {
        current: number;
        limit: number;
        windowMs: number;
    };
    metrics: Metrics;
}

export class HealthMonitor {
    private logger: Logger;
    private checkInterval: NodeJS.Timeout | null = null;
    private lastClientPing: number = Date.now();
    private consecutiveFailures: number = 0;
    private readonly config: Required<HealthConfig>;
    private shutdownCallback?: () => Promise<void>;

    constructor(config: HealthConfig = {}) {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
        this.config = {
            checkInterval: config.checkInterval || 30000,      // 30 seconds
            failureThreshold: config.failureThreshold || 3,    // 3 strikes
            shutdownGracePeriod: config.shutdownGracePeriod || 5000, // 5 seconds
            clientPingTimeout: config.clientPingTimeout || 60000 // 1 minute
        };
    }

    /**
     * Start periodic health monitoring
     */
    start(shutdownCallback: () => Promise<void>): void {
        this.shutdownCallback = shutdownCallback;
        this.checkInterval = setInterval(() => this.runHealthCheck(), this.config.checkInterval);
        this.logger.info('Health monitoring started', {
            interval: this.config.checkInterval,
            failureThreshold: this.config.failureThreshold
        });
    }

    /**
     * Stop health monitoring
     */
    stop(): void {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
            this.checkInterval = null;
        }
        this.logger.info('Health monitoring stopped');
    }

    /**
     * Record a client ping
     */
    recordClientPing(): void {
        this.lastClientPing = Date.now();
        this.consecutiveFailures = 0; // Reset failures on successful ping
    }

    /**
     * Run a health check and handle failures
     */
    private async runHealthCheck(): Promise<void> {
        try {
            const status = await this.getCurrentStatus();
            const health = await this.check(status);

            if (!health.healthy) {
                this.consecutiveFailures++;
                this.logger.warn('Health check failed', {
                    consecutiveFailures: this.consecutiveFailures,
                    threshold: this.config.failureThreshold,
                    details: health.details
                });

                if (this.consecutiveFailures >= this.config.failureThreshold) {
                    await this.initiateShutdown();
                }
            } else {
                this.consecutiveFailures = 0;
            }
        } catch (error) {
            this.logger.error('Health check error', { error });
            this.consecutiveFailures++;
            if (this.consecutiveFailures >= this.config.failureThreshold) {
                await this.initiateShutdown();
            }
        }
    }

    /**
     * Get current status of all components
     */
    private async getCurrentStatus(): Promise<ComponentStatus> {
        return {
            storage: {
                tasks: {
                    total: 0,
                    byStatus: {
                        [TaskStatus.PENDING]: 0,
                        [TaskStatus.IN_PROGRESS]: 0,
                        [TaskStatus.COMPLETED]: 0,
                        [TaskStatus.FAILED]: 0,
                        [TaskStatus.BLOCKED]: 0
                    },
                    noteCount: 0,
                    dependencyCount: 0
                },
                storage: {
                    totalSize: 0,
                    pageSize: 4096,
                    pageCount: 0,
                    walSize: 0,
                    cache: {
                        hitRate: 0,
                        memoryUsage: 0,
                        entryCount: 0
                    }
                }
            },
            rateLimiter: { current: 0, limit: 100, windowMs: 60000 },
            metrics: {
                requests: {
                    total: 0,
                    success: 0,
                    failed: 0,
                    avgDuration: 0
                },
                tools: {}
            }
        };
    }

    /**
     * Initiate graceful shutdown
     */
    private async initiateShutdown(): Promise<void> {
        this.logger.error('Initiating shutdown due to health check failures', {
            consecutiveFailures: this.consecutiveFailures
        });

        if (this.shutdownCallback) {
            try {
                const shutdownTimeout = setTimeout(() => {
                    this.logger.error('Force shutdown due to timeout');
                    process.exit(1);
                }, this.config.shutdownGracePeriod);

                await this.shutdownCallback();
                clearTimeout(shutdownTimeout);
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during shutdown', { error });
                process.exit(1);
            }
        } else {
            process.exit(1);
        }
    }

    /**
     * Check system health
     */
    async check(status: ComponentStatus): Promise<HealthStatus> {
        const now = Date.now();
        const health: HealthStatus = {
            healthy: true,
            components: {
                storage: true,
                rateLimiter: true,
                metrics: true,
                clientConnected: true
            },
            details: {},
            timestamp: now,
            consecutiveFailures: this.consecutiveFailures
        };

        // Check client connectivity
        const timeSinceLastPing = now - this.lastClientPing;
        if (timeSinceLastPing > this.config.clientPingTimeout) {
            health.components.clientConnected = false;
            health.healthy = false;
            health.details!.client = `No ping received for ${Math.round(timeSinceLastPing / 1000)}s`;
        }

        try {
            try {
                // Check storage health with safe access
                const hasStorageMetrics = status.storage?.tasks && status.storage?.storage;
                if (!hasStorageMetrics) {
                    health.components.storage = false;
                    health.healthy = false;
                    health.details!.storage = 'Storage metrics unavailable';
                }

                // Check rate limiter with safe defaults
                const rateLimiter = status.rateLimiter || { current: 0, limit: 100 };
                if (rateLimiter.current >= rateLimiter.limit) {
                    health.components.rateLimiter = false;
                    health.healthy = false;
                    health.details!.rateLimiter = 'Rate limit reached';
                }

                // Check metrics with safe calculation
                const metrics = status.metrics?.requests || { failed: 0, total: 0 };
                const errorRate = metrics.total > 0 ? metrics.failed / metrics.total : 0;
                if (errorRate > 0.1) { // More than 10% error rate
                    health.components.metrics = false;
                    health.healthy = false;
                    health.details!.metrics = `High error rate: ${(errorRate * 100).toFixed(2)}%`;
                }
            } catch (error) {
                // Log specific component check errors but continue
                this.logger.error('Component check error', { error });
                health.healthy = false;
                health.details!.error = error instanceof Error ? error.message : String(error);
            }

            this.logger.debug('Health check completed', { health });
            return health;
        } catch (error) {
            this.logger.error('Health check failed', { error });
            return {
                healthy: false,
                components: {
                    storage: false,
                    rateLimiter: false,
                    metrics: false,
                    clientConnected: false
                },
                details: {
                    error: error instanceof Error ? error.message : String(error)
                },
                timestamp: Date.now()
            };
        }
    }
}

================
File: server/index.ts
================
/**
 * Server module for Atlas MCP Server
 * Handles server initialization, transport setup, and graceful shutdown
 */
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
    CallToolRequestSchema,
    ErrorCode,
    ListToolsRequestSchema,
    McpError,
    Request
} from '@modelcontextprotocol/sdk/types.js';
import { Logger } from '../logging/index.js';
import { RateLimiter } from './rate-limiter.js';
import { HealthMonitor, ComponentStatus } from './health-monitor.js';
import { MetricsCollector, MetricEvent } from './metrics-collector.js';
import { RequestTracer, TraceEvent } from './request-tracer.js';

export interface ServerConfig {
    name: string;
    version: string;
    maxRequestsPerMinute?: number;
    requestTimeout?: number;
    shutdownTimeout?: number;
}

export interface ToolHandler {
    listTools: () => Promise<any>;
    handleToolCall: (request: Request) => Promise<any>;
    getStorageMetrics: () => Promise<any>;
    clearCaches?: () => Promise<void>;
    cleanup?: () => Promise<void>;
}

/**
 * AtlasServer class encapsulates MCP server functionality
 * Handles server lifecycle, transport, and error management
 */
export class AtlasServer {
    private static instance: AtlasServer;
    private static isInitializing: boolean = false;
    private static serverPromise: Promise<void> | null = null;
    private static logger: Logger;
    private readonly server: Server;

    private static initLogger(): void {
        if (!AtlasServer.logger) {
            AtlasServer.logger = Logger.getInstance().child({ component: 'AtlasServer' });
        }
    }
    private readonly rateLimiter: RateLimiter;
    private readonly healthMonitor: HealthMonitor;
    private readonly metricsCollector: MetricsCollector;
    private readonly requestTracer: RequestTracer;
    private isShuttingDown: boolean = false;
    private isInitialized: boolean = false;
    private readonly activeRequests: Set<string> = new Set();
    private memoryMonitor?: NodeJS.Timeout;
    private readonly MAX_MEMORY_USAGE = 2 * 1024 * 1024 * 1024; // 2GB threshold
    private readonly MEMORY_CHECK_INTERVAL = 30000; // 30 seconds

    /**
     * Gets the singleton instance of AtlasServer
     */
    public static async getInstance(config: ServerConfig, toolHandler: ToolHandler): Promise<AtlasServer> {
        AtlasServer.initLogger();

        // Return existing instance if available
        if (AtlasServer.instance?.isInitialized) {
            AtlasServer.logger?.debug('Returning existing server instance');
            return AtlasServer.instance;
        }

        // If initialization is in progress, wait for it
        if (AtlasServer.isInitializing) {
            AtlasServer.logger?.debug('Server initialization in progress, waiting...');
            await AtlasServer.serverPromise;
            return AtlasServer.instance;
        }

        AtlasServer.isInitializing = true;
        AtlasServer.serverPromise = (async () => {
            try {
                AtlasServer.logger?.info('Starting server initialization');
                if (!AtlasServer.instance) {
                    AtlasServer.instance = new AtlasServer(config, toolHandler);
                }
                await AtlasServer.instance.initializeServer();
            } catch (error) {
                throw new McpError(
                    ErrorCode.InternalError,
                    `Failed to initialize AtlasServer: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                AtlasServer.isInitializing = false;
                AtlasServer.serverPromise = null;
            }
        })();

        await AtlasServer.serverPromise;
        return AtlasServer.instance;
    }

    /**
     * Creates a new AtlasServer instance
     */
    private constructor(
        private readonly config: ServerConfig,
        private readonly toolHandler: ToolHandler
    ) {
        // Initialize components
        this.rateLimiter = new RateLimiter(config.maxRequestsPerMinute || 600);
        this.healthMonitor = new HealthMonitor({
            checkInterval: 30000,
            failureThreshold: 3,
            shutdownGracePeriod: config.shutdownTimeout || 30000,
            clientPingTimeout: 60000
        });
        this.metricsCollector = new MetricsCollector();
        this.requestTracer = new RequestTracer();

        // Initialize MCP server
        this.server = new Server(
            {
                name: config.name,
                version: config.version,
            },
            {
                capabilities: {
                    tools: {
                        create_task: {},
                        update_task: {},
                        delete_task: {},
                        get_tasks_by_status: {},
                        get_tasks_by_path: {},
                        get_subtasks: {},
                        bulk_task_operations: {},
                        clear_all_tasks: {},
                        vacuum_database: {},
                        repair_relationships: {}
                    },
                },
            }
        );

        this.setupErrorHandling();
        this.setupToolHandlers();
        this.setupHealthCheck();
        this.setupMemoryMonitoring();
    }

    /**
     * Sets up error handling for the server
     */
    private setupErrorHandling(): void {
        this.server.onerror = (error: unknown) => {
            const metricEvent: MetricEvent = {
                type: 'error',
                timestamp: Date.now(),
                error: error instanceof Error ? error.message : String(error)
            };
            this.metricsCollector.recordError(metricEvent);
            
            const errorContext = {
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                } : error,
                metrics: this.metricsCollector.getMetrics()
            };

            AtlasServer.logger.error('[MCP Error]', errorContext);
        };

        process.on('SIGINT', async () => {
            await this.shutdown();
        });

        process.on('SIGTERM', async () => {
            await this.shutdown();
        });

        process.on('unhandledRejection', (reason, promise) => {
            AtlasServer.logger.error('Unhandled Rejection:', {
                reason,
                promise,
                metrics: this.metricsCollector.getMetrics()
            });
        });

        process.on('uncaughtException', (error) => {
            const errorMessage = error instanceof Error 
                ? { name: error.name, message: error.message, stack: error.stack }
                : error && typeof error === 'object'
                    ? JSON.stringify(error)
                    : String(error);
            
            AtlasServer.logger.error('Uncaught Exception:', {
                error: errorMessage,
                metrics: this.metricsCollector.getMetrics()
            });
            this.shutdown().finally(() => process.exit(1));
        });
    }

    /**
     * Sets up tool request handlers with middleware
     */
    private setupToolHandlers(): void {
        // Handler for listing available tools
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const traceEvent: TraceEvent = {
                type: 'list_tools',
                timestamp: Date.now()
            };
            
            try {
                await this.rateLimiter.checkLimit();
                this.activeRequests.add(requestId);
                
                // Record client activity
                this.recordClientActivity();
                
                this.requestTracer.startTrace(requestId, traceEvent);
                const response = await this.toolHandler.listTools();
                
                const metricEvent: MetricEvent = {
                    type: 'list_tools',
                    timestamp: Date.now(),
                    duration: Date.now() - traceEvent.timestamp
                };
                this.metricsCollector.recordSuccess(metricEvent);

                return response;
            } catch (error) {
                this.handleToolError(error);
                throw error; // Ensure error propagation
            } finally {
                this.activeRequests.delete(requestId);
                this.requestTracer.endTrace(requestId, {
                    ...traceEvent,
                    timestamp: Date.now()
                });
            }
        });

        // Handler for tool execution requests
        this.server.setRequestHandler(CallToolRequestSchema, async (request: Request) => {
            if (!request.params?.name) {
                throw new McpError(ErrorCode.InvalidRequest, 'Missing tool name');
            }
            const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const traceEvent: TraceEvent = {
                type: 'tool_execution',
                tool: String(request.params.name),
                timestamp: Date.now()
            };
            
            try {
                if (this.isShuttingDown) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        'Server is shutting down'
                    );
                }

                await this.rateLimiter.checkLimit();
                this.activeRequests.add(requestId);
                
                // Record client activity
                this.recordClientActivity();
                
                this.requestTracer.startTrace(requestId, traceEvent);
                const response = await Promise.race([
                    this.toolHandler.handleToolCall(request),
                    this.createTimeout(this.config.requestTimeout || 30000)
                ]);
                
                const metricEvent: MetricEvent = {
                    type: 'tool_execution',
                    tool: String(request.params.name),
                    timestamp: Date.now(),
                    duration: Date.now() - traceEvent.timestamp
                };
                this.metricsCollector.recordSuccess(metricEvent);

                return response;
            } catch (error) {
                this.handleToolError(error);
                throw error; // Ensure error propagation
            } finally {
                this.activeRequests.delete(requestId);
                this.requestTracer.endTrace(requestId, {
                    ...traceEvent,
                    timestamp: Date.now()
                });
            }
        });
    }

    /**
     * Sets up health check endpoint
     */
    private setupHealthCheck(): void {
        // Start health monitor with shutdown callback
        this.healthMonitor.start(async () => {
            AtlasServer.logger.info('Health monitor triggered shutdown');
            await this.shutdown();
        });

        // Set up periodic status checks
        setInterval(async () => {
            try {
                const status: ComponentStatus = {
                    storage: await this.toolHandler.getStorageMetrics(),
                    rateLimiter: this.rateLimiter.getStatus(),
                    metrics: this.metricsCollector.getMetrics()
                };
                await this.healthMonitor.check(status);
            } catch (error) {
                AtlasServer.logger.error('Health check error:', { error });
            }
        }, 30000);
    }

    /**
     * Record client activity
     */
    private recordClientActivity(): void {
        this.healthMonitor.recordClientPing();
    }

    /**
     * Creates a timeout promise
     */
    private createTimeout(ms: number): Promise<never> {
        return new Promise((_, reject) => {
            setTimeout(() => {
                reject(new McpError(
                    ErrorCode.InternalError,
                    `Request timed out after ${ms}ms`
                ));
            }, ms);
        });
    }

    /**
     * Transforms errors into McpErrors
     */
    private handleToolError(error: unknown): void {
        const errorMessage = error instanceof Error 
            ? error.message 
            : error && typeof error === 'object'
                ? JSON.stringify(error)
                : String(error);

        const metricEvent: MetricEvent = {
            type: 'error',
            timestamp: Date.now(),
            error: errorMessage
        };
        this.metricsCollector.recordError(metricEvent);

        if (error instanceof McpError) {
            return;
        }

        const errorDetails = error instanceof Error 
            ? { name: error.name, message: error.message, stack: error.stack }
            : error && typeof error === 'object'
                ? JSON.stringify(error)
                : String(error);

        AtlasServer.logger.error('Unexpected error in tool handler:', {
            error: errorDetails,
            metrics: this.metricsCollector.getMetrics()
        });
        
        throw new McpError(
            ErrorCode.InternalError,
            error instanceof Error ? error.message : 'An unexpected error occurred',
            error instanceof Error ? error.stack : undefined
        );
    }

    /**
     * Starts the server
     */
    private async initializeServer(): Promise<void> {
        if (this.isInitialized) {
            AtlasServer.logger.debug('Server already initialized');
            return;
        }

        try {
            const transport = new StdioServerTransport();
            await this.server.connect(transport);
            
            this.isInitialized = true;
            AtlasServer.logger.info(`${this.config.name} v${this.config.version} running on stdio`, {
                metrics: this.metricsCollector.getMetrics()
            });
        } catch (error) {
            AtlasServer.logger.error('Failed to start server:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            throw error;
        }
    }

    /**
     * Sets up memory monitoring to prevent leaks
     */
    private setupMemoryMonitoring(): void {
        this.memoryMonitor = setInterval(() => {
            const memUsage = process.memoryUsage();
            
            // Log memory stats
            AtlasServer.logger.debug('Memory usage:', {
                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`
            });

            // Trigger cleanup if memory usage is too high
            if (memUsage.heapUsed > this.MAX_MEMORY_USAGE) {
                AtlasServer.logger.warn('High memory usage detected, triggering cleanup', {
                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                    threshold: `${Math.round(this.MAX_MEMORY_USAGE / 1024 / 1024)}MB`
                });
                
                // Force garbage collection if available
                if (global.gc) {
                    AtlasServer.logger.info('Forcing garbage collection');
                    global.gc();
                }

                // Clear caches
                this.toolHandler.clearCaches?.();
            }
        }, this.MEMORY_CHECK_INTERVAL);
    }

    /**
     * Gracefully shuts down the server and cleans up resources
     */
    async shutdown(): Promise<void> {
        if (this.isShuttingDown) {
            return;
        }

        this.isShuttingDown = true;
        AtlasServer.logger.info('Starting graceful shutdown...');

        try {
            // Wait for active requests to complete
            const timeout = this.config.shutdownTimeout || 30000;
            const shutdownStart = Date.now();

            while (this.activeRequests.size > 0) {
                if (Date.now() - shutdownStart > timeout) {
                    AtlasServer.logger.warn('Shutdown timeout reached, forcing shutdown', {
                        activeRequests: this.activeRequests.size
                    });
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Clear monitoring intervals
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
            }
            
            // Clean up resources
            await this.toolHandler.cleanup?.();
            
            // Close server
            await this.server.close();
            
            // Force final garbage collection
            if (global.gc) {
                global.gc();
            }
            AtlasServer.logger.info('Server closed successfully', {
                metrics: this.metricsCollector.getMetrics()
            });
        } catch (error) {
            AtlasServer.logger.error('Error during shutdown:', {
                error,
                metrics: this.metricsCollector.getMetrics()
            });
            throw error;
        }
    }
}

================
File: server/metrics-collector.ts
================
/**
 * Metrics collection for monitoring and analysis
 */
import { Logger } from '../logging/index.js';

export interface MetricEvent {
    type: string;
    tool?: string;
    timestamp: number;
    duration?: number;
    success?: boolean;
    error?: string;
    [key: string]: unknown;
}

export interface Metrics {
    requests: {
        total: number;
        success: number;
        failed: number;
        avgDuration: number;
    };
    tools: Record<string, {
        total: number;
        success: number;
        failed: number;
        avgDuration: number;
        errors: Record<string, number>;
    }>;
}

export class MetricsCollector {
    private events: MetricEvent[] = [];
    private logger: Logger;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'MetricsCollector' });
    }

    recordSuccess(event: MetricEvent): void {
        this.events.push({
            ...event,
            success: true,
            timestamp: event.timestamp || Date.now()
        });
        this.logger.debug('Recorded success metric', { event });
    }

    recordError(event: MetricEvent): void {
        this.events.push({
            ...event,
            success: false,
            timestamp: event.timestamp || Date.now()
        });
        this.logger.debug('Recorded error metric', { event });
    }

    getMetrics(): Metrics {
        const now = Date.now();
        const recentEvents = this.events.filter(e => now - e.timestamp < 3600000); // Last hour

        const metrics: Metrics = {
            requests: {
                total: recentEvents.length,
                success: recentEvents.filter(e => e.success).length,
                failed: recentEvents.filter(e => !e.success).length,
                avgDuration: this.calculateAvgDuration(recentEvents)
            },
            tools: {}
        };

        // Calculate per-tool metrics
        const toolEvents = recentEvents.filter(e => e.tool);
        const tools = new Set(toolEvents.map(e => e.tool!));

        for (const tool of tools) {
            const toolMetrics = toolEvents.filter(e => e.tool === tool);
            metrics.tools[tool] = {
                total: toolMetrics.length,
                success: toolMetrics.filter(e => e.success).length,
                failed: toolMetrics.filter(e => !e.success).length,
                avgDuration: this.calculateAvgDuration(toolMetrics),
                errors: this.calculateErrorFrequency(toolMetrics)
            };
        }

        return metrics;
    }

    private calculateAvgDuration(events: MetricEvent[]): number {
        const eventsWithDuration = events.filter(e => e.duration);
        if (eventsWithDuration.length === 0) return 0;
        
        const total = eventsWithDuration.reduce((sum, e) => sum + (e.duration || 0), 0);
        return total / eventsWithDuration.length;
    }

    private calculateErrorFrequency(events: MetricEvent[]): Record<string, number> {
        const errors: Record<string, number> = {};
        
        for (const event of events) {
            if (!event.success && event.error) {
                errors[event.error] = (errors[event.error] || 0) + 1;
            }
        }
        
        return errors;
    }

    clearMetrics(): void {
        this.events = [];
        this.logger.debug('Cleared metrics');
    }
}

================
File: server/rate-limiter.ts
================
/**
 * Rate limiter for request throttling
 */
export class RateLimiter {
    private requests: number[] = [];
    private readonly windowMs = 60000; // 1 minute window

    constructor(private readonly maxRequests: number) {}

    /**
     * Checks if request is within rate limit
     * @throws Error if rate limit exceeded
     */
    async checkLimit(): Promise<void> {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.windowMs);

        if (this.requests.length >= this.maxRequests) {
            throw new Error('Rate limit exceeded');
        }

        this.requests.push(now);
    }

    /**
     * Gets current rate limiter status
     */
    getStatus(): { current: number; limit: number; windowMs: number } {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.windowMs);

        return {
            current: this.requests.length,
            limit: this.maxRequests,
            windowMs: this.windowMs
        };
    }

    /**
     * Resets rate limiter
     */
    reset(): void {
        this.requests = [];
    }
}

================
File: server/request-tracer.ts
================
/**
 * Request tracing for monitoring and debugging with memory management
 */
import { Logger } from '../logging/index.js';

export interface TracerConfig {
    maxTraces?: number;           // Maximum number of traces to store
    maxEventsPerTrace?: number;   // Maximum events per trace
    traceRetentionMs?: number;    // How long to keep traces
    cleanupIntervalMs?: number;   // How often to run cleanup
}

const DEFAULT_CONFIG: TracerConfig = {
    maxTraces: 1000,
    maxEventsPerTrace: 100,
    traceRetentionMs: 24 * 60 * 60 * 1000, // 24 hours
    cleanupIntervalMs: 60 * 60 * 1000      // 1 hour
};

export interface TraceEvent {
    type: string;
    tool?: string;
    timestamp: number;
    success?: boolean;
    error?: string;
    duration?: number;
    [key: string]: unknown;
}

export class RequestTracer {
    private traces: Map<string, TraceEvent[]> = new Map();
    private startTimes: Map<string, number> = new Map();
    private logger: Logger;
    private config: TracerConfig;
    private cleanupTimer!: NodeJS.Timeout;

    constructor(config: TracerConfig = {}) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.logger = Logger.getInstance().child({ component: 'RequestTracer' });

        // Start cleanup timer
        this.cleanupTimer = setInterval(
            () => this.cleanup(),
            this.config.cleanupIntervalMs ?? DEFAULT_CONFIG.cleanupIntervalMs!
        ) as unknown as NodeJS.Timeout;

        // Bind cleanup to process events
        process.on('SIGINT', () => this.destroy());
        process.on('SIGTERM', () => this.destroy());
    }

    /**
     * Cleanup old traces and enforce size limits
     */
    private cleanup(): void {
        const now = Date.now();
        const cutoff = now - (this.config.traceRetentionMs ?? DEFAULT_CONFIG.traceRetentionMs!);
        
        // Remove old traces
        for (const [requestId, _] of this.traces.entries()) {
            const startTime = this.startTimes.get(requestId);
            if (startTime && startTime < cutoff) {
                this.traces.delete(requestId);
                this.startTimes.delete(requestId);
                this.logger.debug('Cleaned up old trace', { requestId, age: now - startTime });
            }
        }

        // Enforce maximum traces limit
        const maxTraces = this.config.maxTraces ?? DEFAULT_CONFIG.maxTraces!;
        if (this.traces.size > maxTraces) {
            const sortedTraces = Array.from(this.startTimes.entries())
                .sort(([, a], [, b]) => b - a);
            
            const tracesToRemove = sortedTraces.slice(maxTraces);
            for (const [requestId] of tracesToRemove) {
                this.traces.delete(requestId);
                this.startTimes.delete(requestId);
                this.logger.debug('Removed excess trace', { requestId });
            }
        }
    }

    startTrace(requestId: string, event: TraceEvent): void {
        // Cleanup if we're at the limit
        if (this.traces.size >= (this.config.maxTraces ?? DEFAULT_CONFIG.maxTraces!)) {
            this.cleanup();
        }

        this.traces.set(requestId, [event]);
        this.startTimes.set(requestId, event.timestamp);
        this.logger.debug('Started trace', { requestId, event });
    }

    addEvent(requestId: string, event: TraceEvent): void {
        const events = this.traces.get(requestId) || [];
        
        // Enforce maximum events per trace
        const maxEvents = this.config.maxEventsPerTrace ?? DEFAULT_CONFIG.maxEventsPerTrace!;
        if (events.length >= maxEvents) {
            this.logger.warn('Maximum events per trace reached', { 
                requestId, 
                limit: maxEvents
            });
            return;
        }

        events.push(event);
        this.traces.set(requestId, events);
        this.logger.debug('Added trace event', { requestId, event });
    }

    endTrace(requestId: string, event: TraceEvent): void {
        const events = this.traces.get(requestId) || [];
        const startTime = this.startTimes.get(requestId);
        
        if (startTime) {
            event.duration = event.timestamp - startTime;
        }
        
        events.push(event);
        this.traces.set(requestId, events);
        this.logger.debug('Ended trace', { requestId, event });
    }

    getTrace(requestId: string): TraceEvent[] {
        return this.traces.get(requestId) || [];
    }

    getStartTime(requestId: string): number | undefined {
        return this.startTimes.get(requestId);
    }

    clearTrace(requestId: string): void {
        this.traces.delete(requestId);
        this.startTimes.delete(requestId);
        this.logger.debug('Cleared trace', { requestId });
    }

    /**
     * Get memory usage statistics
     */
    getStats(): {
        traceCount: number;
        totalEvents: number;
        memoryUsage: NodeJS.MemoryUsage;
    } {
        let totalEvents = 0;
        for (const events of this.traces.values()) {
            totalEvents += events.length;
        }

        return {
            traceCount: this.traces.size,
            totalEvents,
            memoryUsage: process.memoryUsage()
        };
    }

    /**
     * Cleanup resources and stop timers
     */
    destroy(): void {
        clearInterval(this.cleanupTimer);
        this.traces.clear();
        this.startTimes.clear();
        this.logger.info('Request tracer destroyed');
    }
}

================
File: storage/core/connection/health.ts
================
/**
 * Database connection health monitoring
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';

export interface ConnectionHealth {
    isHealthy: boolean;
    lastChecked: number;
    errorCount: number;
    avgResponseTime: number;
    lastError?: string;
}

export interface HealthMetrics {
    totalConnections: number;
    activeConnections: number;
    idleConnections: number;
    errorRate: number;
    avgResponseTime: number;
    healthyConnections: number;
    unhealthyConnections: number;
}

export class HealthMonitor {
    private readonly logger: Logger;
    private readonly healthChecks: Map<string, ConnectionHealth>;
    private readonly checkInterval: number;
    private readonly errorThreshold: number;
    private readonly responseTimeThreshold: number;
    private monitorInterval: NodeJS.Timeout | null;

    constructor(options: {
        checkInterval?: number;
        errorThreshold?: number;
        responseTimeThreshold?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
        this.healthChecks = new Map();
        this.checkInterval = options.checkInterval || 30000; // 30 seconds
        this.errorThreshold = options.errorThreshold || 5;
        this.responseTimeThreshold = options.responseTimeThreshold || 1000; // 1 second
        this.monitorInterval = null;
    }

    /**
     * Start health monitoring
     */
    start(): void {
        if (!this.monitorInterval) {
            this.monitorInterval = setInterval(
                () => this.runHealthChecks(),
                this.checkInterval
            );
            this.logger.info('Health monitoring started', {
                checkInterval: this.checkInterval,
                errorThreshold: this.errorThreshold,
                responseTimeThreshold: this.responseTimeThreshold
            });
        }
    }

    /**
     * Stop health monitoring
     */
    stop(): void {
        if (this.monitorInterval) {
            clearInterval(this.monitorInterval);
            this.monitorInterval = null;
            this.logger.info('Health monitoring stopped');
        }
    }

    /**
     * Register a connection for health monitoring
     */
    registerConnection(id: string): void {
        this.healthChecks.set(id, {
            isHealthy: true,
            lastChecked: Date.now(),
            errorCount: 0,
            avgResponseTime: 0
        });
        this.logger.debug('Connection registered for health monitoring', { id });
    }

    /**
     * Unregister a connection from health monitoring
     */
    unregisterConnection(id: string): void {
        this.healthChecks.delete(id);
        this.logger.debug('Connection unregistered from health monitoring', { id });
    }

    /**
     * Check health of a specific connection
     */
    async checkConnectionHealth(id: string, db: Database): Promise<ConnectionHealth> {
        const startTime = Date.now();
        let health = this.healthChecks.get(id) || {
            isHealthy: true,
            lastChecked: startTime,
            errorCount: 0,
            avgResponseTime: 0
        };

        try {
            // Run basic query to check connection
            await db.get('SELECT 1');

            // Update response time
            const responseTime = Date.now() - startTime;
            health.avgResponseTime = (health.avgResponseTime + responseTime) / 2;

            // Check if response time is acceptable
            const isResponseTimeOk = health.avgResponseTime <= this.responseTimeThreshold;

            // Update health status
            health = {
                ...health,
                isHealthy: isResponseTimeOk && health.errorCount < this.errorThreshold,
                lastChecked: Date.now(),
                errorCount: Math.max(0, health.errorCount - 1) // Slowly reduce error count on success
            };

            if (!isResponseTimeOk) {
                this.logger.warn('Connection response time exceeds threshold', {
                    id,
                    avgResponseTime: health.avgResponseTime,
                    threshold: this.responseTimeThreshold
                });
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            health = {
                ...health,
                isHealthy: false,
                lastChecked: Date.now(),
                errorCount: health.errorCount + 1,
                lastError: errorMessage
            };

            this.logger.error('Connection health check failed', {
                id,
                error: errorMessage,
                errorCount: health.errorCount
            });
        }

        this.healthChecks.set(id, health);
        return health;
    }

    /**
     * Run health checks on all registered connections
     */
    private async runHealthChecks(): Promise<void> {
        this.logger.debug('Running health checks', {
            connections: this.healthChecks.size
        });

        const metrics = this.getMetrics();
        this.logger.info('Health check metrics', { metrics });
    }

    /**
     * Get health metrics
     */
    getMetrics(): HealthMetrics {
        let totalResponseTime = 0;
        let totalErrors = 0;
        let healthyCount = 0;
        let unhealthyCount = 0;

        for (const health of this.healthChecks.values()) {
            totalResponseTime += health.avgResponseTime;
            totalErrors += health.errorCount;
            if (health.isHealthy) {
                healthyCount++;
            } else {
                unhealthyCount++;
            }
        }

        const totalConnections = this.healthChecks.size;
        return {
            totalConnections,
            activeConnections: 0, // Updated by connection pool
            idleConnections: 0,   // Updated by connection pool
            errorRate: totalConnections > 0 ? totalErrors / totalConnections : 0,
            avgResponseTime: totalConnections > 0 ? totalResponseTime / totalConnections : 0,
            healthyConnections: healthyCount,
            unhealthyConnections: unhealthyCount
        };
    }

    /**
     * Get health status for a specific connection
     */
    getConnectionHealth(id: string): ConnectionHealth | undefined {
        return this.healthChecks.get(id);
    }

    /**
     * Record an error for a connection
     */
    recordError(id: string, error: Error | string): void {
        const health = this.healthChecks.get(id);
        if (health) {
            health.errorCount++;
            health.lastError = error instanceof Error ? error.message : error;
            health.isHealthy = health.errorCount < this.errorThreshold;
            this.healthChecks.set(id, health);

            this.logger.warn('Connection error recorded', {
                id,
                errorCount: health.errorCount,
                isHealthy: health.isHealthy,
                error: health.lastError
            });
        }
    }

    /**
     * Reset error count for a connection
     */
    resetErrors(id: string): void {
        const health = this.healthChecks.get(id);
        if (health) {
            health.errorCount = 0;
            health.isHealthy = true;
            health.lastError = undefined;
            this.healthChecks.set(id, health);
            this.logger.debug('Connection errors reset', { id });
        }
    }
}

================
File: storage/core/connection/manager.ts
================
/**
 * Enhanced database connection manager with connection pooling
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { StorageConfig } from '../../../types/storage.js';
import { ConnectionPool } from './pool.js';

export interface ConnectionOptions {
    maxRetries?: number;
    retryDelay?: number;
    busyTimeout?: number;
    minConnections?: number;
    maxConnections?: number;
    idleTimeout?: number;
}

export class ConnectionManager {
    private readonly logger: Logger;
    private readonly maxRetries: number;
    private readonly retryDelay: number;
    private readonly busyTimeout: number;
    private readonly pool: ConnectionPool;

    constructor(config: StorageConfig, options: ConnectionOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionManager' });
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.busyTimeout = options.busyTimeout || 5000;
        
        this.pool = new ConnectionPool(config, {
            minConnections: options.minConnections,
            maxConnections: options.maxConnections,
            idleTimeout: options.idleTimeout
        });
    }

    /**
     * Initialize the connection manager and pool
     */
    async initialize(): Promise<void> {
        await this.pool.initialize();
    }

    /**
     * Execute a database operation with retries and connection management
     */
    async execute<T>(
        operation: (db: Database) => Promise<T>,
        context: string
    ): Promise<T> {
        let lastError: Error | undefined;
        let retryCount = 0;
        let db: Database | null = null;

        while (retryCount < this.maxRetries) {
            try {
                // Get connection from pool
                db = await this.pool.getConnection();

                // Execute operation
                const result = await operation(db);

                // Operation succeeded
                if (retryCount > 0) {
                    this.logger.info(`Operation succeeded after ${retryCount} retries`, {
                        context
                    });
                }

                return result;
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                retryCount++;

                // Log detailed error info
                const errorDetails = lastError instanceof Error ? {
                    name: lastError.name,
                    message: lastError.message,
                    code: (lastError as any).code,
                    errno: (lastError as any).errno
                } : lastError;

                this.logger.warn(`Operation failed${retryCount < this.maxRetries ? ', retrying' : ''}`, {
                    attempt: retryCount,
                    maxRetries: this.maxRetries,
                    error: errorDetails,
                    context
                });

                // Check if error is WAL-related
                const isWalError = lastError instanceof Error && 
                    (lastError.message.includes('WAL') || 
                     lastError.message.includes('journal_mode') ||
                     lastError.message.includes('Safety level'));

                if (retryCount < this.maxRetries) {
                    // Longer delay for WAL-related errors
                    const baseDelay = isWalError ? 1000 : this.retryDelay;
                    const delay = Math.min(
                        baseDelay * Math.pow(2, retryCount - 1) * (0.5 + Math.random()),
                        isWalError ? 10000 : 5000 // Higher cap for WAL errors
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            } finally {
                // Always release connection back to pool
                if (db) {
                    this.pool.releaseConnection(db);
                }
            }
        }

        // All retries failed
        throw createError(
            ErrorCodes.STORAGE_ERROR,
            'Operation failed',
            `Failed after ${this.maxRetries} retries: ${lastError?.message}`,
            lastError?.message
        );
    }

    /**
     * Execute a database operation with busy handling
     */
    async handleBusy(
        operation: () => Promise<void>,
        context: string
    ): Promise<void> {
        const startTime = Date.now();

        while (true) {
            try {
                await operation();
                return;
            } catch (error) {
                const elapsed = Date.now() - startTime;
                if (elapsed >= this.busyTimeout) {
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Operation timed out',
                        `Timed out after ${elapsed}ms: ${error instanceof Error ? error.message : String(error)}`
                    );
                }

                this.logger.warn('Database busy, waiting...', {
                    elapsed,
                    timeout: this.busyTimeout,
                    context
                });

                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }

    /**
     * Execute a database operation with retries
     */
    async executeWithRetry<T>(
        operation: () => Promise<T>,
        context: string
    ): Promise<T> {
        return this.execute(async () => operation(), context);
    }

    /**
     * Close the connection manager and pool
     */
    async close(): Promise<void> {
        await this.pool.close();
    }
}

================
File: storage/core/connection/pool.ts
================
/**
 * Database connection pool implementation
 */
import { Database, open } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { StorageConfig } from '../../../types/storage.js';
import { MonitoringConfig } from '../../monitoring/index.js';
import { ConnectionStateManager } from './state.js';
import { WALManager } from '../wal/manager.js';
import { join } from 'path';
import crypto from 'crypto';

interface PoolConnection {
    db: Database;
    id: string;
    inUse: boolean;
    lastUsed: number;
    createdAt: number;
    errorCount: number;
}

export class ConnectionPool {
    private readonly logger: Logger;
    private readonly config: StorageConfig;
    private readonly connections: Map<string, PoolConnection>;
    private readonly minConnections: number;
    private readonly maxConnections: number;
    private readonly idleTimeout: number;
    private readonly stateManager: ConnectionStateManager;
    private cleanupInterval: NodeJS.Timeout | null;
    private readonly dbPath: string;
    private readonly connectionIds = new WeakMap<Database, string>();
    private readonly verifiedConnections = new Set<string>();
    private isInitialized = false;

    constructor(config: StorageConfig & { monitoring?: MonitoringConfig }, options: {
        minConnections?: number;
        maxConnections?: number;
        idleTimeout?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionPool' });
        this.config = config;
        this.connections = new Map();
        this.minConnections = options.minConnections || 1;  // Minimum connections
        this.maxConnections = options.maxConnections || 5;  // Reduced maximum
        this.idleTimeout = options.idleTimeout || 30000;   // 30 seconds
        this.cleanupInterval = null;
        this.dbPath = join(config.baseDir, `${config.name}.db`);
        
        // Initialize state manager with monitoring config
        this.stateManager = ConnectionStateManager.getInstance({
            errorThreshold: config.monitoring?.healthCheck?.errorThreshold,
            responseTimeThreshold: config.monitoring?.healthCheck?.responseTimeThreshold
        });
    }

    /**
     * Get the unique ID for a database connection
     */
    getConnectionId(db: Database): string {
        let id = this.connectionIds.get(db);
        if (!id) {
            id = crypto.randomUUID();
            this.connectionIds.set(db, id);
        }
        return id;
    }

    /**
     * Initialize the connection pool
     */
    async initialize(): Promise<void> {
        try {
            if (this.isInitialized) {
                // On reconnect, just verify and warm up connections
                await this.warmupConnections();
                return;
            }

            // First-time initialization
            const sqlite3 = await import('sqlite3');
            const initDb = await open({
                filename: this.dbPath,
                driver: sqlite3.default.Database,
                mode: sqlite3.default.OPEN_READWRITE | sqlite3.default.OPEN_CREATE
            });

            try {
                // Enable WAL mode before creating any connections
                const walManager = WALManager.getInstance(this.dbPath);
                await walManager.enableWAL(initDb);
            } finally {
                await initDb.close();
            }

            // Create and warm up initial connections
            await this.warmupConnections();
            this.isInitialized = true;

            // Start monitoring
            this.stateManager.startMonitoring();
            this.cleanupInterval = setInterval(
                () => this.cleanupIdleConnections(),
                this.idleTimeout
            );

            this.logger.info('Connection pool initialized', {
                minConnections: this.minConnections,
                maxConnections: this.maxConnections,
                idleTimeout: this.idleTimeout
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to initialize connection pool', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize connection pool',
                errorMessage
            );
        }
    }

    /**
     * Get a connection from the pool
     */
    async getConnection(): Promise<Database> {
        // First try to find a healthy available connection
        for (const [id, conn] of this.connections.entries()) {
            if (!conn.inUse) {
                if (this.stateManager.isHealthy(id) && !this.stateManager.hasActiveTransaction(id)) {
                    conn.inUse = true;
                    conn.lastUsed = Date.now();
                    this.stateManager.markInUse(id);
                    this.logger.debug('Reusing healthy connection', { id });
                    return conn.db;
                }
            }
        }

        // If we haven't reached max connections, create a new one
        if (this.connections.size < this.maxConnections) {
            const conn = await this.createConnection();
            conn.inUse = true;
            this.stateManager.markInUse(conn.id);
            return conn.db;
        }

        // Otherwise wait for a connection to become available
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Connection timeout',
                    'Timed out waiting for available connection'
                ));
            }, this.config.connection?.busyTimeout || 2000);

            const checkConnection = async () => {
                for (const [id] of this.connections.entries()) {
                    const conn = this.connections.get(id);
                    if (conn && !conn.inUse) {
                        if (this.stateManager.isHealthy(id) && !this.stateManager.hasActiveTransaction(id)) {
                            clearTimeout(timeout);
                            conn.inUse = true;
                            conn.lastUsed = Date.now();
                            this.stateManager.markInUse(id);
                            this.logger.debug('Connection became available', { id });
                            resolve(conn.db);
                            return;
                        }
                    }
                }
                setTimeout(checkConnection, 100);
            };

            checkConnection();
        });
    }

    /**
     * Release a connection back to the pool
     */
    releaseConnection(db: Database): void {
        const id = this.getConnectionId(db);
        const conn = Array.from(this.connections.values()).find(c => c.id === id);
        
        if (conn) {
            conn.inUse = false;
            conn.lastUsed = Date.now();
            this.stateManager.markAvailable(id);
            this.logger.debug('Connection released', { id });
        }
    }

    /**
     * Create a new connection
     */
    private async createConnection(): Promise<PoolConnection> {
        const sqlite3 = await import('sqlite3');
        const id = crypto.randomUUID();
        
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.default.Database,
                mode: sqlite3.default.OPEN_READWRITE | sqlite3.default.OPEN_CREATE
            });

            // Store connection ID
            this.connectionIds.set(db, id);

            // Skip verification if already verified
            if (!this.verifiedConnections.has(id)) {
                try {
                    await db.get('SELECT 1');
                    this.verifiedConnections.add(id);
                    this.logger.debug('Connection verified', { id });
                } catch (error) {
                    const msg = error instanceof Error ? error.message : String(error);
                    this.logger.error('Failed to verify connection', { error: msg, id });
                    await db.close().catch(() => {}); // Attempt to close on error
                    throw error;
                }
            }

            const conn: PoolConnection = {
                db,
                id,
                inUse: false,
                lastUsed: Date.now(),
                createdAt: Date.now(),
                errorCount: 0
            };
            this.connections.set(id, conn);
            this.stateManager.registerConnection(id);
            this.logger.debug('Created new connection', { id });
            return conn;
        } catch (error) {
            this.logger.error('Failed to create connection', {
                id,
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    /**
     * Warm up connections by creating and verifying them
     */
    private async warmupConnections(): Promise<void> {
        const promises: Promise<void>[] = [];
        
        // Create minimum number of connections
        while (this.connections.size < this.minConnections) {
            promises.push(this.createConnection().then(() => {}));
        }

        // Wait for all connections to be created
        await Promise.all(promises);
    }

    /**
     * Clean up idle connections but maintain minimum
     */
    private async cleanupIdleConnections(): Promise<void> {
        const now = Date.now();
        const idsToRemove: string[] = [];

        // Find connections to remove
        for (const [id, conn] of this.connections.entries()) {
            if (!conn.inUse && 
                now - conn.lastUsed > this.idleTimeout &&
                this.connections.size > this.minConnections) {
                idsToRemove.push(id);
            }
        }

        // Remove connections
        for (const id of idsToRemove) {
            const conn = this.connections.get(id);
            if (conn) {
                try {
                    await conn.db.close();
                    this.connections.delete(id);
                    this.stateManager.unregisterConnection(id);
                    this.connectionIds.delete(conn.db);
                    this.logger.debug('Removed idle connection', { id });
                } catch (error) {
                    this.logger.error('Failed to close idle connection', {
                        id,
                        error: error instanceof Error ? error.message : String(error)
                    });
                }
            }
        }
    }

    /**
     * Get current pool metrics
     */
    getMetrics() {
        const metrics = this.stateManager.getMetrics();
        return metrics;
    }

    /**
     * Close all connections
     */
    async close(): Promise<void> {
        this.stateManager.stopMonitoring();
        
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }

        for (const [id, conn] of this.connections.entries()) {
            try {
                await conn.db.close();
                this.stateManager.unregisterConnection(id);
                this.connectionIds.delete(conn.db);
                this.logger.debug('Closed connection', { id });
            } catch (error) {
                this.logger.error('Failed to close connection', {
                    id,
                    error: error instanceof Error ? error.message : String(error)
                });
            }
        }

        this.connections.clear();
        this.logger.info('Connection pool closed');
    }
}

================
File: storage/core/connection/state.ts
================
/**
 * Connection state management
 */
import { Logger } from '../../../logging/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { ConnectionStats, MonitoringMetrics } from '../../../types/storage.js';

interface ConnectionState {
    id: string;
    inUse: boolean;
    hasActiveTransaction: boolean;
    lastUsed: number;
    createdAt: number;
    errorCount: number;
    totalQueries: number;
    totalResponseTime: number;
    lastError?: Error;
}

interface StateManagerOptions {
    errorThreshold?: number;
    responseTimeThreshold?: number;
}

export class ConnectionStateManager {
    private static instance: ConnectionStateManager;
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly states: Map<string, ConnectionState>;
    private readonly errorThreshold: number;
    private readonly responseTimeThreshold: number;
    private monitoringInterval: NodeJS.Timeout | null = null;
    private readonly DEFAULT_ERROR_THRESHOLD = 5;
    private readonly DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second
    private readonly MONITORING_INTERVAL = 30000; // 30 seconds

    private constructor(options: StateManagerOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionStateManager' });
        this.eventManager = EventManager.getInstance();
        this.states = new Map();
        this.errorThreshold = options.errorThreshold || this.DEFAULT_ERROR_THRESHOLD;
        this.responseTimeThreshold = options.responseTimeThreshold || this.DEFAULT_RESPONSE_TIME_THRESHOLD;
    }

    static getInstance(options?: StateManagerOptions): ConnectionStateManager {
        if (!ConnectionStateManager.instance) {
            ConnectionStateManager.instance = new ConnectionStateManager(options);
        }
        return ConnectionStateManager.instance;
    }

    /**
     * Register a new connection
     */
    registerConnection(id: string): void {
        this.states.set(id, {
            id,
            inUse: false,
            hasActiveTransaction: false,
            lastUsed: Date.now(),
            createdAt: Date.now(),
            errorCount: 0,
            totalQueries: 0,
            totalResponseTime: 0
        });
        this.logger.debug('Connection registered', { id });
    }

    /**
     * Unregister a connection
     */
    unregisterConnection(id: string): void {
        this.states.delete(id);
        this.logger.debug('Connection unregistered', { id });
    }

    /**
     * Mark connection as in use
     */
    markInUse(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.inUse = true;
            state.lastUsed = Date.now();
        }
    }

    /**
     * Mark connection as available
     */
    markAvailable(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.inUse = false;
            state.lastUsed = Date.now();
        }
    }

    /**
     * Start transaction on connection
     */
    startTransaction(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.hasActiveTransaction = true;
        }
    }

    /**
     * End transaction on connection
     */
    endTransaction(id: string): void {
        const state = this.states.get(id);
        if (state) {
            state.hasActiveTransaction = false;
        }
    }

    /**
     * Record query execution
     */
    recordQuery(id: string, duration: number, error?: Error): void {
        const state = this.states.get(id);
        if (state) {
            state.totalQueries++;
            state.totalResponseTime += duration;
            if (error) {
                state.errorCount++;
                state.lastError = error;
            }
        }
    }

    /**
     * Check if connection is healthy
     */
    isHealthy(id: string): boolean {
        const state = this.states.get(id);
        if (!state) return false;

        const avgResponseTime = state.totalQueries > 0
            ? state.totalResponseTime / state.totalQueries
            : 0;

        return state.errorCount < this.errorThreshold &&
               avgResponseTime < this.responseTimeThreshold;
    }

    /**
     * Get connection state
     */
    getState(id: string): ConnectionState | undefined {
        return this.states.get(id);
    }

    /**
     * Check if connection has active transaction
     */
    hasActiveTransaction(id: string): boolean {
        const state = this.states.get(id);
        return state?.hasActiveTransaction || false;
    }

    /**
     * Get connection metrics
     */
    getMetrics(): MonitoringMetrics {
        let totalActive = 0;
        let totalErrors = 0;
        let totalQueries = 0;
        let totalResponseTime = 0;

        for (const state of this.states.values()) {
            if (state.inUse) totalActive++;
            totalErrors += state.errorCount;
            totalQueries += state.totalQueries;
            totalResponseTime += state.totalResponseTime;
        }

        const connectionStats: ConnectionStats = {
            total: this.states.size,
            active: totalActive,
            idle: this.states.size - totalActive,
            errors: totalErrors,
            avgResponseTime: totalQueries > 0 ? totalResponseTime / totalQueries : 0
        };

        return {
            cache: {
                hits: 0,
                misses: 0,
                hitRate: 0,
                size: 0,
                memoryUsage: process.memoryUsage().heapUsed
            },
            connections: connectionStats,
            queries: {
                total: totalQueries,
                errors: totalErrors,
                avgExecutionTime: totalQueries > 0 ? totalResponseTime / totalQueries : 0,
                slowQueries: 0 // TODO: Track slow queries
            },
            timestamp: Date.now()
        };
    }

    /**
     * Start monitoring connections
     */
    startMonitoring(): void {
        if (this.monitoringInterval) return;

        this.monitoringInterval = setInterval(() => {
            this.checkConnections();
        }, this.MONITORING_INTERVAL);

        // Don't prevent process exit
        this.monitoringInterval.unref();

        this.logger.info('Connection monitoring started', {
            interval: this.MONITORING_INTERVAL,
            errorThreshold: this.errorThreshold,
            responseTimeThreshold: this.responseTimeThreshold
        });
    }

    /**
     * Stop monitoring connections
     */
    stopMonitoring(): void {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        this.logger.info('Connection monitoring stopped');
    }

    /**
     * Check connection health
     */
    private checkConnections(): void {
        const metrics = this.getMetrics();
        const unhealthyConnections: string[] = [];

        for (const [id, state] of this.states.entries()) {
            if (!this.isHealthy(id)) {
                unhealthyConnections.push(id);
                this.logger.warn('Unhealthy connection detected', {
                    id,
                    errorCount: state.errorCount,
                    avgResponseTime: state.totalQueries > 0
                        ? state.totalResponseTime / state.totalQueries
                        : 0,
                    lastError: state.lastError
                });
            }
        }

        // Emit monitoring event
        this.eventManager.emitSystemEvent({
            type: EventTypes.STORAGE_ANALYZE,
            timestamp: Date.now(),
            metadata: {
                component: 'ConnectionStateManager',
                memoryUsage: process.memoryUsage(),
                metrics: {
                    cache: metrics.cache,
                    connections: metrics.connections,
                    queries: metrics.queries,
                    timestamp: metrics.timestamp
                },
                operation: 'health_check',
                unhealthyConnections,
                healthStatus: {
                    isHealthy: unhealthyConnections.length === 0,
                    errorCount: metrics.connections.errors,
                    avgResponseTime: metrics.connections.avgResponseTime
                }
            }
        });

        // Log monitoring summary
        this.logger.info('Connection health check completed', {
            total: metrics.connections.total,
            active: metrics.connections.active,
            idle: metrics.connections.idle,
            errors: metrics.connections.errors,
            avgResponseTime: metrics.connections.avgResponseTime,
            unhealthyCount: unhealthyConnections.length
        });
    }

    /**
     * Clean up resources
     */
    cleanup(): void {
        this.stopMonitoring();
        this.states.clear();
    }
}

================
File: storage/core/query/builder.ts
================
/**
 * Type-safe SQL query builder
 */
import { Logger } from '../../../logging/index.js';

type SqlValue = string | number | boolean | null | undefined;
type SqlValues = Record<string, SqlValue>;

interface QueryPart {
    sql: string;
    values: SqlValue[];
}

export class QueryBuilder {
    private parts: QueryPart[] = [];
    private readonly logger: Logger;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'QueryBuilder' });
    }

    /**
     * Start SELECT query
     */
    select(columns: string | string[] = '*'): this {
        const cols = Array.isArray(columns) ? columns.join(', ') : columns;
        this.parts.push({
            sql: `SELECT ${cols}`,
            values: []
        });
        return this;
    }

    /**
     * Add FROM clause
     */
    from(table: string): this {
        this.parts.push({
            sql: `FROM ${table}`,
            values: []
        });
        return this;
    }

    /**
     * Add WHERE clause with parameterized values
     */
    where(conditions: SqlValues): this {
        const entries = Object.entries(conditions).filter(([_, value]) => value !== undefined);
        if (entries.length === 0) return this;

        const clauses = entries.map(([key]) => `${key} = ?`);
        const values = entries.map(([_, value]) => value);

        this.parts.push({
            sql: `WHERE ${clauses.join(' AND ')}`,
            values
        });
        return this;
    }

    /**
     * Add raw WHERE clause
     */
    whereRaw(sql: string, values: SqlValue[] = []): this {
        this.parts.push({
            sql: `WHERE ${sql}`,
            values
        });
        return this;
    }

    /**
     * Add ORDER BY clause
     */
    orderBy(column: string, direction: 'ASC' | 'DESC' = 'ASC'): this {
        this.parts.push({
            sql: `ORDER BY ${column} ${direction}`,
            values: []
        });
        return this;
    }

    /**
     * Add LIMIT clause
     */
    limit(limit: number): this {
        this.parts.push({
            sql: 'LIMIT ?',
            values: [limit]
        });
        return this;
    }

    /**
     * Add OFFSET clause
     */
    offset(offset: number): this {
        this.parts.push({
            sql: 'OFFSET ?',
            values: [offset]
        });
        return this;
    }

    /**
     * Start INSERT query
     */
    insertInto(table: string, data: SqlValues): this {
        const columns = Object.keys(data);
        const values = Object.values(data);
        const placeholders = Array(values.length).fill('?').join(', ');

        this.parts.push({
            sql: `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${placeholders})`,
            values
        });
        return this;
    }

    /**
     * Start UPDATE query
     */
    update(table: string, data: SqlValues): this {
        const entries = Object.entries(data).filter(([_, value]) => value !== undefined);
        const setClause = entries.map(([key]) => `${key} = ?`).join(', ');
        const values = entries.map(([_, value]) => value);

        this.parts.push({
            sql: `UPDATE ${table} SET ${setClause}`,
            values
        });
        return this;
    }

    /**
     * Start DELETE query
     */
    deleteFrom(table: string): this {
        this.parts.push({
            sql: `DELETE FROM ${table}`,
            values: []
        });
        return this;
    }

    /**
     * Add JOIN clause
     */
    join(table: string, condition: string): this {
        this.parts.push({
            sql: `JOIN ${table} ON ${condition}`,
            values: []
        });
        return this;
    }

    /**
     * Add LEFT JOIN clause
     */
    leftJoin(table: string, condition: string): this {
        this.parts.push({
            sql: `LEFT JOIN ${table} ON ${condition}`,
            values: []
        });
        return this;
    }

    /**
     * Add GROUP BY clause
     */
    groupBy(columns: string | string[]): this {
        const cols = Array.isArray(columns) ? columns.join(', ') : columns;
        this.parts.push({
            sql: `GROUP BY ${cols}`,
            values: []
        });
        return this;
    }

    /**
     * Add HAVING clause
     */
    having(conditions: SqlValues): this {
        const entries = Object.entries(conditions).filter(([_, value]) => value !== undefined);
        if (entries.length === 0) return this;

        const clauses = entries.map(([key]) => `${key} = ?`);
        const values = entries.map(([_, value]) => value);

        this.parts.push({
            sql: `HAVING ${clauses.join(' AND ')}`,
            values
        });
        return this;
    }

    /**
     * Build the final query
     */
    build(): { sql: string; values: SqlValue[] } {
        const sql = this.parts.map(p => p.sql).join(' ');
        const values = this.parts.flatMap(p => p.values);

        this.logger.debug('Built query', { sql, values });

        return { sql, values };
    }

    /**
     * Reset the builder
     */
    reset(): this {
        this.parts = [];
        return this;
    }

    /**
     * Create a new builder instance
     */
    static create(): QueryBuilder {
        return new QueryBuilder();
    }
}

================
File: storage/core/query/executor.ts
================
/**
 * SQL query executor with caching and performance monitoring
 */
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { QueryBuilder } from './builder.js';
import { ConnectionPool } from '../connection/pool.js';

interface QueryMetrics {
    queryCount: number;
    totalTime: number;
    avgTime: number;
    slowQueries: number;
    errors: number;
    cacheHits: number;
    cacheMisses: number;
}

interface QueryCacheEntry {
    result: any;
    timestamp: number;
    hits: number;
}

interface QueryCacheOptions {
    ttl?: number;
    key?: string;
}

export class QueryExecutor {
    private readonly logger: Logger;
    private readonly pool: ConnectionPool;
    private readonly queryCache: Map<string, QueryCacheEntry>;
    private readonly metrics: QueryMetrics;
    private readonly slowQueryThreshold: number;
    private readonly maxCacheSize: number;
    private readonly defaultCacheTTL: number;

    constructor(pool: ConnectionPool, options: {
        slowQueryThreshold?: number;
        maxCacheSize?: number;
        defaultCacheTTL?: number;
    } = {}) {  
        this.logger = Logger.getInstance().child({ component: 'QueryExecutor' });
        this.pool = pool;
        this.queryCache = new Map();
        this.metrics = {
            queryCount: 0,
            totalTime: 0,
            avgTime: 0,
            slowQueries: 0,
            errors: 0,
            cacheHits: 0,
            cacheMisses: 0
        };
        this.slowQueryThreshold = options.slowQueryThreshold || 100; // 100ms
        this.maxCacheSize = options.maxCacheSize || 1000;
        this.defaultCacheTTL = options.defaultCacheTTL || 60000; // 1 minute
    }

    /**
     * Execute a query with optional caching
     */
    async execute<T>(
        query: QueryBuilder | { sql: string; values: any[] },
        cache?: QueryCacheOptions
    ): Promise<T> {
        const { sql, values } = query instanceof QueryBuilder ? query.build() : query;
        const startTime = Date.now();
        const cacheKey = this.getCacheKey(sql, values, cache?.key);

        try {
            // Check cache first if enabled
            if (cache) {
                const cached = this.queryCache.get(cacheKey);
                if (cached && Date.now() - cached.timestamp < (cache.ttl || this.defaultCacheTTL)) {
                    cached.hits++;
                    this.metrics.cacheHits++;
                    return cached.result;
                }
                this.metrics.cacheMisses++;
            }

            // Get connection from pool
            const db = await this.pool.getConnection();

            try {
                // Execute query
                const result = await db.all(sql, ...values);

                // Update metrics
                const duration = Date.now() - startTime;
                this.updateMetrics(duration);

                // Log slow queries
                if (duration > this.slowQueryThreshold) {
                    this.logger.warn('Slow query detected', {
                        sql,
                        values,
                        duration,
                        threshold: this.slowQueryThreshold
                    });
                }

                // Cache result if enabled
                if (cache) {
                    this.cacheResult(cacheKey, result);
                }

                // Type assertion since we know the shape matches T
                return result as unknown as T;
            } finally {
                // Always release connection back to pool
                this.pool.releaseConnection(db);
            }
        } catch (error) {
            this.metrics.errors++;
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Query execution failed', {
                sql,
                values,
                error: errorMessage,
                duration: Date.now() - startTime
            });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Query execution failed',
                errorMessage
            );
        }
    }

    /**
     * Execute a query that returns a single row
     */
    async get<T>(
        query: QueryBuilder | { sql: string; values: any[] },
        cache?: QueryCacheOptions
    ): Promise<T | null> {
        const result = await this.execute<T[]>(query, cache);
        return result[0] || null;
    }

    /**
     * Execute a write query (INSERT, UPDATE, DELETE)
     */
    async run(
        query: QueryBuilder | { sql: string; values: any[] }
    ): Promise<void> {
        const { sql, values } = query instanceof QueryBuilder ? query.build() : query;
        const startTime = Date.now();

        try {
            const db = await this.pool.getConnection();

            try {
                await db.run(sql, ...values);

                // Update metrics
                const duration = Date.now() - startTime;
                this.updateMetrics(duration);

                // Log slow queries
                if (duration > this.slowQueryThreshold) {
                    this.logger.warn('Slow write query detected', {
                        sql,
                        values,
                        duration,
                        threshold: this.slowQueryThreshold
                    });
                }
            } finally {
                this.pool.releaseConnection(db);
            }
        } catch (error) {
            this.metrics.errors++;
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Write query failed', {
                sql,
                values,
                error: errorMessage,
                duration: Date.now() - startTime
            });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Write query failed',
                errorMessage
            );
        }
    }

    /**
     * Execute multiple queries in a transaction
     */
    async transaction<T>(callback: (executor: QueryExecutor) => Promise<T>): Promise<T> {
        const db = await this.pool.getConnection();

        try {
            await db.run('BEGIN IMMEDIATE');
            const result = await callback(this);
            await db.run('COMMIT');
            return result;
        } catch (error) {
            try {
                await db.run('ROLLBACK');
            } catch (rollbackError) {
                this.logger.error('Failed to rollback transaction', {
                    error: rollbackError instanceof Error ? rollbackError.message : String(rollbackError),
                    originalError: error instanceof Error ? error.message : String(error)
                });
            }
            throw error;
        } finally {
            this.pool.releaseConnection(db);
        }
    }

    /**
     * Get query execution metrics
     */
    getMetrics(): QueryMetrics {
        return { ...this.metrics };
    }

    /**
     * Clear query cache
     */
    clearCache(): void {
        this.queryCache.clear();
        this.logger.debug('Query cache cleared');
    }

    /**
     * Reset metrics
     */
    resetMetrics(): void {
        Object.assign(this.metrics, {
            queryCount: 0,
            totalTime: 0,
            avgTime: 0,
            slowQueries: 0,
            errors: 0,
            cacheHits: 0,
            cacheMisses: 0
        });
        this.logger.debug('Query metrics reset');
    }

    private updateMetrics(duration: number): void {
        this.metrics.queryCount++;
        this.metrics.totalTime += duration;
        this.metrics.avgTime = this.metrics.totalTime / this.metrics.queryCount;
        if (duration > this.slowQueryThreshold) {
            this.metrics.slowQueries++;
        }
    }

    private getCacheKey(sql: string, values: any[], key?: string): string {
        return key || `${sql}:${JSON.stringify(values)}`;
    }

    private cacheResult(key: string, result: any): void {
        // Evict oldest entry if cache is full
        if (this.queryCache.size >= this.maxCacheSize) {
            let oldestKey = '';
            let oldestTime = Date.now();

            for (const [k, entry] of this.queryCache.entries()) {
                if (entry.timestamp < oldestTime) {
                    oldestTime = entry.timestamp;
                    oldestKey = k;
                }
            }

            if (oldestKey) {
                this.queryCache.delete(oldestKey);
            }
        }

        // Add new entry
        this.queryCache.set(key, {
            result,
            timestamp: Date.now(),
            hits: 1
        });
    }
}

================
File: storage/core/query/optimizer.ts
================
/**
 * SQL query optimizer for better performance
 */
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { Database } from 'sqlite';

interface QueryPlan {
    details: string[];
    cost: number;
    rows: number;
    indexes: string[];
}

interface OptimizationSuggestion {
    type: 'index' | 'rewrite' | 'schema';
    description: string;
    impact: 'high' | 'medium' | 'low';
    suggestion: string;
}

export class QueryOptimizer {
    private readonly logger: Logger;
    private readonly costThreshold: number;
    private readonly indexStats: Map<string, {
        usage: number;
        lastUsed: number;
    }>;

    constructor(options: {
        costThreshold?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'QueryOptimizer' });
        this.costThreshold = options.costThreshold || 1000;
        this.indexStats = new Map();
    }

    /**
     * Analyze a query and get its execution plan
     */
    async analyzeQuery(
        db: Database,
        sql: string,
        values: any[] = []
    ): Promise<QueryPlan> {
        try {
            // Get query plan
            const plan = await db.all(`EXPLAIN QUERY PLAN ${sql}`, ...values);
            
            // Parse plan details
            const details = plan.map(row => row.detail);
            const indexes = this.extractIndexes(details);
            
            // Estimate cost and rows
            const cost = this.estimateCost(details);
            const rows = this.estimateRows(details);

            // Update index usage stats
            this.updateIndexStats(indexes);

            return { details, cost, rows, indexes };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to analyze query', {
                sql,
                values,
                error: errorMessage
            });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to analyze query',
                errorMessage
            );
        }
    }

    /**
     * Get optimization suggestions for a query
     */
    async optimizeQuery(
        db: Database,
        sql: string,
        values: any[] = []
    ): Promise<OptimizationSuggestion[]> {
        const suggestions: OptimizationSuggestion[] = [];
        const plan = await this.analyzeQuery(db, sql, values);

        // Check if query cost is above threshold
        if (plan.cost > this.costThreshold) {
            // Check for missing indexes
            const missingIndexes = this.findMissingIndexes(plan.details);
            if (missingIndexes.length > 0) {
                suggestions.push({
                    type: 'index',
                    description: 'Missing indexes detected',
                    impact: 'high',
                    suggestion: `Consider adding indexes for: ${missingIndexes.join(', ')}`
                });
            }

            // Check for table scans
            if (this.hasTableScan(plan.details)) {
                suggestions.push({
                    type: 'rewrite',
                    description: 'Full table scan detected',
                    impact: 'high',
                    suggestion: 'Add WHERE clause or index to avoid table scan'
                });
            }

            // Check for suboptimal joins
            if (this.hasSuboptimalJoin(plan.details)) {
                suggestions.push({
                    type: 'rewrite',
                    description: 'Suboptimal join detected',
                    impact: 'medium',
                    suggestion: 'Consider rewriting join or adding index on join columns'
                });
            }
        }

        // Check for unused indexes
        const unusedIndexes = await this.findUnusedIndexes(db);
        if (unusedIndexes.length > 0) {
            suggestions.push({
                type: 'schema',
                description: 'Unused indexes detected',
                impact: 'low',
                suggestion: `Consider removing unused indexes: ${unusedIndexes.join(', ')}`
            });
        }

        return suggestions;
    }

    /**
     * Get index usage statistics
     */
    getIndexStats() {
        return new Map(this.indexStats);
    }

    /**
     * Reset index usage statistics
     */
    resetIndexStats(): void {
        this.indexStats.clear();
    }

    private extractIndexes(details: string[]): string[] {
        const indexes: string[] = [];
        for (const detail of details) {
            const match = detail.match(/USING (?:INDEX|COVERING INDEX) (\w+)/i);
            if (match) {
                indexes.push(match[1]);
            }
        }
        return indexes;
    }

    private estimateCost(details: string[]): number {
        let cost = 0;
        for (const detail of details) {
            // Estimate cost based on operations
            if (detail.includes('SCAN')) cost += 100;
            if (detail.includes('SEARCH')) cost += 10;
            if (detail.includes('TEMP')) cost += 50;
            if (detail.includes('SORT')) cost += 30;
        }
        return cost;
    }

    private estimateRows(details: string[]): number {
        let maxRows = 0;
        for (const detail of details) {
            const match = detail.match(/~(\d+) rows/);
            if (match) {
                maxRows = Math.max(maxRows, parseInt(match[1], 10));
            }
        }
        return maxRows;
    }

    private updateIndexStats(indexes: string[]): void {
        const now = Date.now();
        for (const index of indexes) {
            const stats = this.indexStats.get(index) || { usage: 0, lastUsed: now };
            stats.usage++;
            stats.lastUsed = now;
            this.indexStats.set(index, stats);
        }
    }

    private findMissingIndexes(details: string[]): string[] {
        const missing: string[] = [];
        for (const detail of details) {
            // Look for operations that could benefit from an index
            if (detail.includes('SCAN') && !detail.includes('COVERING INDEX')) {
                const match = detail.match(/ON (\w+)/);
                if (match) {
                    const table = match[1];
                    const cols = this.extractFilterColumns(detail);
                    if (cols.length > 0) {
                        missing.push(`${table}(${cols.join(', ')})`);
                    }
                }
            }
        }
        return missing;
    }

    private extractFilterColumns(detail: string): string[] {
        const cols: string[] = [];
        // Extract columns from WHERE/JOIN conditions
        const matches = detail.match(/(?:WHERE|ON|USING|ORDER BY) (\w+)/g);
        if (matches) {
            for (const match of matches) {
                const col = match.split(' ')[1];
                if (col && !cols.includes(col)) {
                    cols.push(col);
                }
            }
        }
        return cols;
    }

    private hasTableScan(details: string[]): boolean {
        return details.some(d => 
            d.includes('SCAN') && !d.includes('INDEX') && !d.includes('PRIMARY KEY')
        );
    }

    private hasSuboptimalJoin(details: string[]): boolean {
        return details.some(d => 
            d.includes('NESTED LOOP') || 
            (d.includes('JOIN') && !d.includes('USING INDEX'))
        );
    }

    private async findUnusedIndexes(db: Database): Promise<string[]> {
        const unused: string[] = [];
        
        // Get all indexes
        const indexes = await db.all(`
            SELECT name FROM sqlite_master 
            WHERE type = 'index' 
            AND sql IS NOT NULL
        `);

        const now = Date.now();
        const threshold = 7 * 24 * 60 * 60 * 1000; // 7 days

        for (const { name } of indexes) {
            const stats = this.indexStats.get(name);
            if (!stats || 
                stats.usage === 0 || 
                (now - stats.lastUsed > threshold && stats.usage < 10)) {
                unused.push(name);
            }
        }

        return unused;
    }
}

================
File: storage/core/schema/backup.ts
================
/**
 * Database backup and recovery system
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { promises as fs } from 'fs';
import { join, basename } from 'path';

export interface BackupMetadata {
    timestamp: number;
    version: number;
    size: number;
    checksum: string;
    comment?: string;
}

export interface BackupOptions {
    compress?: boolean;
    vacuum?: boolean;
    comment?: string;
}

export interface RestoreOptions {
    force?: boolean;
    verify?: boolean;
}

export class BackupManager {
    private readonly logger: Logger;
    private readonly backupDir: string;
    private readonly maxBackups: number;

    constructor(options: {
        backupDir: string;
        maxBackups?: number;
    }) {
        this.logger = Logger.getInstance().child({ component: 'BackupManager' });
        this.backupDir = options.backupDir;
        this.maxBackups = options.maxBackups || 10;
    }

    /**
     * Initialize backup system
     */
    async initialize(): Promise<void> {
        try {
            // Create backup directory if it doesn't exist with platform-appropriate permissions
            await fs.mkdir(this.backupDir, { 
                recursive: true,
                // Skip mode on Windows as it's ignored
                ...(process.platform !== 'win32' && { mode: 0o755 })
            });

            // Verify backup directory is writable
            await fs.access(this.backupDir, fs.constants.W_OK);

            this.logger.info('Backup system initialized', {
                backupDir: this.backupDir,
                maxBackups: this.maxBackups
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to initialize backup system', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize backup system',
                errorMessage
            );
        }
    }

    /**
     * Create a backup
     */
    async createBackup(
        db: Database,
        dbPath: string,
        options: BackupOptions = {}
    ): Promise<string> {
        const timestamp = Date.now();
        const backupName = `backup_${timestamp}.db`;
        const backupPath = join(this.backupDir, backupName);

        try {
            // Ensure database is in a consistent state
            await db.run('PRAGMA wal_checkpoint(TRUNCATE)');

            // Vacuum database if requested
            if (options.vacuum) {
                await db.run('VACUUM');
            }

            // Create backup
            await this.copyDatabase(dbPath, backupPath);

            // Calculate checksum
            const checksum = await this.calculateChecksum(backupPath);

            // Save metadata
            const metadata: BackupMetadata = {
                timestamp,
                version: await this.getCurrentVersion(db),
                size: (await fs.stat(backupPath)).size,
                checksum,
                comment: options.comment
            };
            await this.saveMetadata(backupName, metadata);

            // Compress if requested
            if (options.compress) {
                await this.compressBackup(backupPath);
            }

            // Clean up old backups
            await this.cleanupOldBackups();

            this.logger.info('Backup created successfully', {
                backup: backupName,
                size: metadata.size,
                compressed: options.compress
            });

            return backupPath;
        } catch (error) {
            // Clean up failed backup
            try {
                await fs.unlink(backupPath);
            } catch {
                // Ignore cleanup errors
            }

            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to create backup', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to create backup',
                errorMessage
            );
        }
    }

    /**
     * Restore from backup
     */
    async restoreBackup(
        db: Database,
        dbPath: string,
        backupPath: string,
        options: RestoreOptions = {}
    ): Promise<void> {
        try {
            // Verify backup exists
            await fs.access(backupPath);

            // Get backup metadata
            const backupName = basename(backupPath);
            const metadata = await this.getMetadata(backupName);

            if (!metadata) {
                throw new Error('Backup metadata not found');
            }

            // Verify backup if requested
            if (options.verify) {
                const checksum = await this.calculateChecksum(backupPath);
                if (checksum !== metadata.checksum) {
                    throw new Error('Backup checksum verification failed');
                }
            }

            // Close database connection
            await db.close();

            // Create backup of current database
            const currentBackupPath = `${dbPath}.bak`;
            await this.copyDatabase(dbPath, currentBackupPath);

            try {
                // Restore backup
                await this.copyDatabase(backupPath, dbPath);

                this.logger.info('Backup restored successfully', {
                    backup: backupName,
                    version: metadata.version
                });
            } catch (error) {
                // Restore failed, revert to original
                await this.copyDatabase(currentBackupPath, dbPath);
                throw error;
            } finally {
                // Clean up temporary backup
                try {
                    await fs.unlink(currentBackupPath);
                } catch {
                    // Ignore cleanup errors
                }
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to restore backup', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to restore backup',
                errorMessage
            );
        }
    }

    /**
     * List available backups
     */
    async listBackups(): Promise<{
        name: string;
        metadata: BackupMetadata;
    }[]> {
        try {
            const files = await fs.readdir(this.backupDir);
            const backups = [];

            for (const file of files) {
                if (file.startsWith('backup_') && file.endsWith('.db')) {
                    const metadata = await this.getMetadata(file);
                    if (metadata) {
                        backups.push({ name: file, metadata });
                    }
                }
            }

            return backups.sort((a, b) => b.metadata.timestamp - a.metadata.timestamp);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to list backups', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to list backups',
                errorMessage
            );
        }
    }

    /**
     * Delete a backup
     */
    async deleteBackup(backupName: string): Promise<void> {
        try {
            const backupPath = join(this.backupDir, backupName);
            await fs.unlink(backupPath);

            // Delete metadata
            const metadataPath = `${backupPath}.meta`;
            try {
                await fs.unlink(metadataPath);
            } catch {
                // Ignore metadata deletion errors
            }

            this.logger.info('Backup deleted', { backup: backupName });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to delete backup', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to delete backup',
                errorMessage
            );
        }
    }

    private async getCurrentVersion(db: Database): Promise<number> {
        const result = await db.get<{ version: number }>(
            'SELECT MAX(version) as version FROM migrations'
        );
        return result?.version || 0;
    }

    private async copyDatabase(source: string, destination: string): Promise<void> {
        // On Windows, ensure source file handle is closed before copying
        if (process.platform === 'win32') {
            try {
                await fs.access(destination);
                // If destination exists, ensure it's not locked
                await fs.unlink(destination).catch(() => {});
            } catch (error) {
                // Ignore if destination doesn't exist
            }
        }
        await fs.copyFile(source, destination);
    }

    private async calculateChecksum(filePath: string): Promise<string> {
        const { createHash } = await import('crypto');
        const content = await fs.readFile(filePath);
        return createHash('sha256').update(content).digest('hex');
    }

    private async saveMetadata(backupName: string, metadata: BackupMetadata): Promise<void> {
        const metadataPath = join(this.backupDir, `${backupName}.meta`);
        await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    }

    private async getMetadata(backupName: string): Promise<BackupMetadata | null> {
        try {
            const metadataPath = join(this.backupDir, `${backupName}.meta`);
            const content = await fs.readFile(metadataPath, 'utf8');
            return JSON.parse(content);
        } catch {
            return null;
        }
    }

    private async compressBackup(backupPath: string): Promise<void> {
        const { gzip } = await import('zlib');
        const { promisify } = await import('util');
        const gzipAsync = promisify(gzip);

        const content = await fs.readFile(backupPath);
        const compressed = await gzipAsync(content);
        await fs.writeFile(`${backupPath}.gz`, compressed);
        await fs.unlink(backupPath);
    }

    private async cleanupOldBackups(): Promise<void> {
        const backups = await this.listBackups();
        
        if (backups.length > this.maxBackups) {
            // Keep newest backups, delete oldest
            const toDelete = backups.slice(this.maxBackups);
            for (const backup of toDelete) {
                await this.deleteBackup(backup.name);
            }
        }
    }
}

================
File: storage/core/schema/migrations.ts
================
/**
 * Schema migration management
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';

export interface Migration {
    version: number;
    description: string;
    up: (db: Database) => Promise<void>;
    down: (db: Database) => Promise<void>;
}

export class SchemaManager {
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly migrations: Migration[] = [];

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'SchemaManager' });
        this.eventManager = EventManager.getInstance();

        // Register migrations
        this.registerMigrations();
    }

    private registerMigrations(): void {
        // Migration 1: Initial schema
        this.migrations.push({
            version: 1,
            description: 'Initial schema',
            up: async (db: Database) => {
                // Create tables one at a time with error handling
                await db.exec('BEGIN IMMEDIATE');
                
                try {
                    // Create schema_migrations table first
                    await db.exec(`
                        CREATE TABLE IF NOT EXISTS schema_migrations (
                            version INTEGER PRIMARY KEY,
                            description TEXT NOT NULL,
                            applied_at INTEGER NOT NULL
                        )
                    `);

                    // Create tasks table with proper column types
                    await db.exec(`
                        CREATE TABLE IF NOT EXISTS tasks (
                            path TEXT PRIMARY KEY,
                            name TEXT NOT NULL,
                            description TEXT,
                            type TEXT NOT NULL CHECK(type IN ('TASK', 'GROUP', 'MILESTONE')),
                            status TEXT NOT NULL CHECK(status IN ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED')),
                            parent_path TEXT REFERENCES tasks(path) ON DELETE CASCADE,
                            notes TEXT,
                            reasoning TEXT,
                            dependencies TEXT CHECK(json_valid(COALESCE(dependencies, '[]'))),
                            subtasks TEXT CHECK(json_valid(COALESCE(subtasks, '[]'))),
                            metadata TEXT CHECK(json_valid(COALESCE(metadata, '{}'))),
                            created_at INTEGER NOT NULL,
                            updated_at INTEGER NOT NULL
                        )
                    `);

                    // Create indexes with proper syntax
                    await db.exec(`CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path) WHERE parent_path IS NOT NULL`);
                    await db.exec(`CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)`);
                    await db.exec(`CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type)`);
                    
                    await db.exec('COMMIT');
                } catch (error) {
                    await db.exec('ROLLBACK');
                    throw error;
                }
            },
            down: async (db: Database) => {
                await db.exec(`
                    DROP TABLE IF EXISTS tasks;
                    DROP TABLE IF EXISTS schema_migrations;
                `);
            }
        });

        // Migration 2: Add indexes for performance
        this.migrations.push({
            version: 2,
            description: 'Add performance indexes',
            up: async (db: Database) => {
                await db.exec(`
                    CREATE INDEX IF NOT EXISTS idx_tasks_created ON tasks(created_at);
                    CREATE INDEX IF NOT EXISTS idx_tasks_updated ON tasks(updated_at);
                    CREATE INDEX IF NOT EXISTS idx_tasks_dependencies ON tasks(dependencies) WHERE json_array_length(dependencies) > 0;
                `);
            },
            down: async (db: Database) => {
                await db.exec(`
                    DROP INDEX IF EXISTS idx_tasks_created;
                    DROP INDEX IF EXISTS idx_tasks_updated;
                    DROP INDEX IF EXISTS idx_tasks_dependencies;
                `);
            }
        });
    }

    /**
     * Apply pending migrations
     */
    async applyMigrations(db: Database): Promise<void> {
        try {
            // Ensure migrations table exists
            await db.exec(`
                CREATE TABLE IF NOT EXISTS schema_migrations (
                    version INTEGER PRIMARY KEY,
                    description TEXT NOT NULL,
                    applied_at INTEGER NOT NULL
                );
            `);

            // Get current version
            const result = await db.get<{ version: number }>(
                'SELECT MAX(version) as version FROM schema_migrations'
            );
            const currentVersion = result?.version || 0;

            // Apply pending migrations
            for (const migration of this.migrations) {
                if (migration.version > currentVersion) {
                    this.logger.info('Applying migration', {
                        version: migration.version,
                        description: migration.description
                    });

                    await db.run('BEGIN IMMEDIATE');
                    try {
                        await migration.up(db);
                        await db.run(
                            'INSERT INTO schema_migrations (version, description, applied_at) VALUES (?, ?, ?)',
                            migration.version,
                            migration.description,
                            Date.now()
                        );
                        await db.run('COMMIT');

                        // Emit migration event
                        this.eventManager.emitSystemEvent({
                            type: EventTypes.SYSTEM_STARTUP,
                            timestamp: Date.now(),
                            metadata: {
                                component: 'SchemaManager',
                                operation: 'migration',
                                version: String(migration.version),
                                reason: migration.description
                            }
                        });
                    } catch (error) {
                        await db.run('ROLLBACK');
                        throw error;
                    }
                }
            }

            this.logger.info('Schema migrations complete', {
                fromVersion: currentVersion,
                toVersion: this.migrations[this.migrations.length - 1]?.version || currentVersion
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to apply migrations', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to apply migrations',
                errorMessage
            );
        }
    }

    /**
     * Rollback migrations to a specific version
     */
    async rollbackTo(db: Database, targetVersion: number): Promise<void> {
        try {
            // Get current version
            const result = await db.get<{ version: number }>(
                'SELECT MAX(version) as version FROM schema_migrations'
            );
            const currentVersion = result?.version || 0;

            if (targetVersion >= currentVersion) {
                return;
            }

            // Apply rollbacks in reverse order
            for (let i = this.migrations.length - 1; i >= 0; i--) {
                const migration = this.migrations[i];
                if (migration.version > targetVersion && migration.version <= currentVersion) {
                    this.logger.info('Rolling back migration', {
                        version: migration.version,
                        description: migration.description
                    });

                    await db.run('BEGIN IMMEDIATE');
                    try {
                        await migration.down(db);
                        await db.run(
                            'DELETE FROM schema_migrations WHERE version = ?',
                            migration.version
                        );
                        await db.run('COMMIT');

                        // Emit rollback event
                        this.eventManager.emitSystemEvent({
                            type: EventTypes.SYSTEM_STARTUP,
                            timestamp: Date.now(),
                            metadata: {
                                component: 'SchemaManager',
                                operation: 'rollback',
                                version: String(migration.version),
                                reason: migration.description
                            }
                        });
                    } catch (error) {
                        await db.run('ROLLBACK');
                        throw error;
                    }
                }
            }

            this.logger.info('Schema rollback complete', {
                fromVersion: currentVersion,
                toVersion: targetVersion
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to rollback migrations', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to rollback migrations',
                errorMessage
            );
        }
    }

    /**
     * Get current schema version
     */
    async getCurrentVersion(db: Database): Promise<number> {
        const result = await db.get<{ version: number }>(
            'SELECT MAX(version) as version FROM schema_migrations'
        );
        return result?.version || 0;
    }

    /**
     * Get migration history
     */
    async getMigrationHistory(db: Database): Promise<Array<{
        version: number;
        description: string;
        appliedAt: number;
    }>> {
        return db.all(`
            SELECT version, description, applied_at as appliedAt
            FROM schema_migrations
            ORDER BY version DESC
        `);
    }
}

================
File: storage/core/schema/validator.ts
================
/**
 * Database schema validation system
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';

export interface ColumnDefinition {
    name: string;
    type: string;
    nullable?: boolean;
    defaultValue?: any;
    primaryKey?: boolean;
    unique?: boolean;
    references?: {
        table: string;
        column: string;
    };
}

export interface TableDefinition {
    name: string;
    columns: ColumnDefinition[];
    indexes?: {
        name: string;
        columns: string[];
        unique?: boolean;
    }[];
}

export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings: string[];
}

export class SchemaValidator {
    private readonly logger: Logger;
    private readonly schema: Map<string, TableDefinition>;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'SchemaValidator' });
        this.schema = new Map();
    }

    /**
     * Register a table schema
     */
    registerTable(table: TableDefinition): void {
        if (this.schema.has(table.name)) {
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Duplicate table definition',
                `Table ${table.name} is already registered`
            );
        }

        this.schema.set(table.name, table);
        this.logger.debug('Registered table schema', { table: table.name });
    }

    /**
     * Validate database schema
     */
    async validateSchema(db: Database): Promise<ValidationResult> {
        const result: ValidationResult = {
            isValid: true,
            errors: [],
            warnings: []
        };

        try {
            // Get actual database schema
            const tables = await this.getDatabaseSchema(db);

            // Check each registered table
            for (const [tableName, definition] of this.schema.entries()) {
                const actualTable = tables.get(tableName);

                if (!actualTable) {
                    result.errors.push(`Missing table: ${tableName}`);
                    result.isValid = false;
                    continue;
                }

                // Validate columns
                for (const column of definition.columns) {
                    const actualColumn = actualTable.columns.find(c => c.name === column.name);

                    if (!actualColumn) {
                        result.errors.push(`Missing column: ${tableName}.${column.name}`);
                        result.isValid = false;
                        continue;
                    }

                    // Check column type
                    if (!this.isCompatibleType(actualColumn.type, column.type)) {
                        result.errors.push(
                            `Type mismatch for ${tableName}.${column.name}: ` +
                            `expected ${column.type}, got ${actualColumn.type}`
                        );
                        result.isValid = false;
                    }

                    // Check constraints
                    if (column.primaryKey && !actualColumn.primaryKey) {
                        result.errors.push(
                            `Missing primary key constraint on ${tableName}.${column.name}`
                        );
                        result.isValid = false;
                    }

                    if (column.unique && !actualColumn.unique) {
                        result.warnings.push(
                            `Missing unique constraint on ${tableName}.${column.name}`
                        );
                    }

                    if (column.references) {
                        const hasReference = await this.validateForeignKey(
                            db,
                            tableName,
                            column.name,
                            column.references
                        );
                        if (!hasReference) {
                            result.errors.push(
                                `Missing foreign key constraint on ${tableName}.${column.name} ` +
                                `referencing ${column.references.table}.${column.references.column}`
                            );
                            result.isValid = false;
                        }
                    }
                }

                // Validate indexes
                if (definition.indexes) {
                    for (const index of definition.indexes) {
                        const hasIndex = await this.validateIndex(
                            db,
                            tableName,
                            index
                        );
                        if (!hasIndex) {
                            result.warnings.push(
                                `Missing index ${index.name} on ${tableName}(${index.columns.join(', ')})`
                            );
                        }
                    }
                }
            }

            // Check for extra tables
            for (const tableName of tables.keys()) {
                if (!this.schema.has(tableName) && !tableName.startsWith('sqlite_')) {
                    result.warnings.push(`Extra table found: ${tableName}`);
                }
            }

            this.logger.info('Schema validation completed', {
                isValid: result.isValid,
                errorCount: result.errors.length,
                warningCount: result.warnings.length
            });

            return result;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Schema validation failed', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Schema validation failed',
                errorMessage
            );
        }
    }

    /**
     * Get actual database schema
     */
    private async getDatabaseSchema(db: Database): Promise<Map<string, {
        name: string;
        columns: {
            name: string;
            type: string;
            primaryKey: boolean;
            unique: boolean;
        }[];
    }>> {
        const schema = new Map();

        // Get tables
        const tables = await db.all(`
            SELECT name FROM sqlite_master 
            WHERE type = 'table' 
            AND name NOT LIKE 'sqlite_%'
        `);

        for (const { name } of tables) {
            // Get table info
            const columns = await db.all(`PRAGMA table_info(${name})`);
            
            schema.set(name, {
                name,
                columns: columns.map(col => ({
                    name: col.name,
                    type: col.type.toUpperCase(),
                    primaryKey: Boolean(col.pk),
                    unique: Boolean(col.pk) // SQLite primary keys are unique
                }))
            });
        }

        return schema;
    }

    /**
     * Check if two SQLite types are compatible
     */
    private isCompatibleType(actual: string, expected: string): boolean {
        // Normalize types
        actual = actual.toUpperCase();
        expected = expected.toUpperCase();

        // Direct match
        if (actual === expected) return true;

        // SQLite type affinities
        const textTypes = ['TEXT', 'CLOB', 'CHAR', 'VARCHAR'];
        const numericTypes = ['INTEGER', 'INT', 'NUMERIC', 'DECIMAL', 'BOOLEAN', 'DATE', 'DATETIME'];
        const realTypes = ['REAL', 'DOUBLE', 'FLOAT'];
        const blobTypes = ['BLOB'];

        // Check type affinity compatibility
        if (textTypes.includes(actual) && textTypes.includes(expected)) return true;
        if (numericTypes.includes(actual) && numericTypes.includes(expected)) return true;
        if (realTypes.includes(actual) && realTypes.includes(expected)) return true;
        if (blobTypes.includes(actual) && blobTypes.includes(expected)) return true;

        return false;
    }

    /**
     * Validate foreign key constraint
     */
    private async validateForeignKey(
        db: Database,
        table: string,
        column: string,
        reference: { table: string; column: string }
    ): Promise<boolean> {
        const foreignKeys = await db.all(`PRAGMA foreign_key_list(${table})`);
        return foreignKeys.some(fk => 
            fk.from === column && 
            fk.table === reference.table && 
            fk.to === reference.column
        );
    }

    /**
     * Validate index
     */
    private async validateIndex(
        db: Database,
        table: string,
        index: { name: string; columns: string[]; unique?: boolean }
    ): Promise<boolean> {
        const indexes = await db.all(`PRAGMA index_list(${table})`);
        const indexInfo = indexes.find(idx => idx.name === index.name);
        
        if (!indexInfo) return false;

        // Check if unique constraint matches
        if (index.unique && !indexInfo.unique) return false;

        // Check index columns
        const columns = await db.all(`PRAGMA index_info(${index.name})`);
        const indexColumns = columns.map(col => col.name);

        return index.columns.every(col => indexColumns.includes(col));
    }

    /**
     * Create a table definition
     */
    static createTableDefinition(
        name: string,
        columns: ColumnDefinition[],
        indexes?: {
            name: string;
            columns: string[];
            unique?: boolean;
        }[]
    ): TableDefinition {
        return { name, columns, indexes };
    }

    /**
     * Create a column definition
     */
    static createColumnDefinition(
        name: string,
        type: string,
        options: {
            nullable?: boolean;
            defaultValue?: any;
            primaryKey?: boolean;
            unique?: boolean;
            references?: {
                table: string;
                column: string;
            };
        } = {}
    ): ColumnDefinition {
        return { name, type, ...options };
    }
}

================
File: storage/core/transactions/manager.ts
================
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import crypto from 'crypto';

export interface TransactionState {
    active: boolean;
    depth: number;
    startTime: number;
    timeout?: NodeJS.Timeout;
    id: string;
}

export class TransactionManager {
    private static instance: TransactionManager;
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly activeTransactions = new Map<string, TransactionState>();
    private readonly DEFAULT_TIMEOUT = 30000; // 30 seconds

    private constructor() {
        this.logger = Logger.getInstance().child({ component: 'TransactionManager' });
        this.eventManager = EventManager.getInstance();
    }

    static getInstance(): TransactionManager {
        if (!TransactionManager.instance) {
            TransactionManager.instance = new TransactionManager();
        }
        return TransactionManager.instance;
    }

    /**
     * Begin a new transaction with proper isolation and timeout
     */
    async beginTransaction(db: Database): Promise<string> {
        const txId = crypto.randomUUID();

        try {
            // Check for existing transaction
            const existingTx = Array.from(this.activeTransactions.values())
                .find(tx => tx.active);

            if (existingTx) {
                // Handle nested transaction
                existingTx.depth++;
                this.logger.debug('Nested transaction started', { 
                    transactionId: existingTx.id,
                    depth: existingTx.depth 
                });
                return existingTx.id;
            }

            // Start new transaction
            await db.exec('BEGIN IMMEDIATE');

            // Set up transaction timeout
            const timeoutHandle = setTimeout(
                () => this.handleTransactionTimeout(db, txId),
                this.DEFAULT_TIMEOUT
            );

            // Record active transaction
            const transaction: TransactionState = {
                id: txId,
                active: true,
                depth: 1,
                startTime: Date.now(),
                timeout: timeoutHandle
            };

            this.activeTransactions.set(txId, transaction);

            // Emit transaction start event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_STARTED,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId
                }
            });

            return txId;
        } catch (error) {
            this.logger.error('Failed to begin transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to begin transaction',
                'beginTransaction',
                undefined,
                { originalError: error }
            );
        }
    }

    /**
     * Commit a transaction
     */
    async commitTransaction(db: Database, txId: string): Promise<void> {
        const transaction = this.activeTransactions.get(txId);
        if (!transaction) {
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'No active transaction to commit'
            );
        }

        try {
            if (transaction.depth > 1) {
                // Handle nested transaction
                transaction.depth--;
                this.logger.debug('Nested transaction committed', { 
                    transactionId: txId,
                    depth: transaction.depth 
                });
                return;
            }

            // Clear timeout
            if (transaction.timeout) {
                clearTimeout(transaction.timeout);
            }

            // Commit transaction
            await db.exec('COMMIT');

            const duration = Date.now() - transaction.startTime;

            // Clean up transaction state
            this.activeTransactions.delete(txId);

            // Emit transaction committed event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_COMMITTED,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId,
                    duration
                }
            });
        } catch (error) {
            this.logger.error('Failed to commit transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to commit transaction',
                'commitTransaction',
                undefined,
                { originalError: error }
            );
        }
    }

    /**
     * Rollback a transaction
     */
    async rollbackTransaction(db: Database, txId: string): Promise<void> {
        const transaction = this.activeTransactions.get(txId);
        if (!transaction) {
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'No active transaction to rollback'
            );
        }

        try {
            if (transaction.depth > 1) {
                // Handle nested transaction
                transaction.depth--;
                this.logger.debug('Nested transaction rolled back', { 
                    transactionId: txId,
                    depth: transaction.depth 
                });
                return;
            }

            // Clear timeout
            if (transaction.timeout) {
                clearTimeout(transaction.timeout);
            }

            // Rollback transaction
            await db.exec('ROLLBACK');

            const duration = Date.now() - transaction.startTime;

            // Clean up transaction state
            this.activeTransactions.delete(txId);

            // Emit transaction rollback event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_ROLLED_BACK,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId,
                    duration
                }
            });
        } catch (error) {
            this.logger.error('Failed to rollback transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to rollback transaction',
                'rollbackTransaction',
                undefined,
                { originalError: error }
            );
        }
    }

    /**
     * Handle transaction timeout
     */
    private async handleTransactionTimeout(db: Database, txId: string): Promise<void> {
        const transaction = this.activeTransactions.get(txId);
        if (!transaction) return;

        this.logger.warn('Transaction timeout', {
            transactionId: txId,
            duration: Date.now() - transaction.startTime
        });

        try {
            await this.rollbackTransaction(db, txId);

            // Emit timeout event
            this.eventManager.emitSystemEvent({
                type: EventTypes.TRANSACTION_TIMEOUT,
                timestamp: Date.now(),
                metadata: {
                    transactionId: txId,
                    duration: Date.now() - transaction.startTime
                }
            });
        } catch (error) {
            this.logger.error('Failed to handle transaction timeout', { error });
        }
    }

    /**
     * Check if a transaction is active
     */
    isTransactionActive(txId: string): boolean {
        const transaction = this.activeTransactions.get(txId);
        return transaction?.active || false;
    }

    /**
     * Get transaction depth
     */
    getTransactionDepth(txId: string): number {
        const transaction = this.activeTransactions.get(txId);
        return transaction?.depth || 0;
    }

    /**
     * Clean up all transactions
     */
    async cleanupAllTransactions(db: Database): Promise<void> {
        for (const [txId, transaction] of this.activeTransactions.entries()) {
            if (transaction.active) {
                try {
                    await this.rollbackTransaction(db, txId);
                } catch (error) {
                    this.logger.error('Failed to cleanup transaction', {
                        error,
                        transactionId: txId
                    });
                }
            }
        }
        this.activeTransactions.clear();
    }
}

================
File: storage/core/transactions/scope.ts
================
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';

export enum IsolationLevel {
    READ_UNCOMMITTED = 'READ UNCOMMITTED',
    READ_COMMITTED = 'READ COMMITTED',
    REPEATABLE_READ = 'REPEATABLE READ',
    SERIALIZABLE = 'SERIALIZABLE'
}

/**
 * Manages database transaction lifecycle and isolation levels
 * Supports nested transactions through savepoints
 */
export class TransactionScope {
    private static logger: Logger;

    private static getLogger(): Logger {
        if (!TransactionScope.logger) {
            TransactionScope.logger = Logger.getInstance().child({ component: 'TransactionScope' });
        }
        return TransactionScope.logger;
    }
    private depth: number = 0;
    private savepoints: string[] = [];
    private active: boolean = false;

    constructor(private readonly db: Database) {}

    /**
     * Begins a new transaction or creates a savepoint for nested transactions
     */
    async begin(isolationLevel: IsolationLevel = IsolationLevel.SERIALIZABLE): Promise<void> {
        try {
            if (this.depth === 0) {
                // Start new transaction
                await this.db.exec('BEGIN TRANSACTION');
                await this.setIsolationLevel(isolationLevel);
                this.active = true;
            } else {
                // Create savepoint for nested transaction
                const savepoint = `sp_${this.depth}`;
                await this.db.exec(`SAVEPOINT ${savepoint}`);
                this.savepoints.push(savepoint);
            }
            this.depth++;
            
            TransactionScope.getLogger().debug('Transaction started', {
                depth: this.depth,
                isolationLevel
            });
        } catch (error) {
            TransactionScope.getLogger().error('Failed to begin transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                
                'Failed to begin transaction',
                'begin',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Commits the current transaction or savepoint
     */
    async commit(): Promise<void> {
        if (!this.active) {
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'No active transaction'
            );
        }

        try {
            this.depth--;

            if (this.depth === 0) {
                // Commit main transaction
                await this.db.exec('COMMIT');
                this.active = false;
                this.savepoints = [];
            } else {
                // Release savepoint
                const savepoint = this.savepoints.pop();
                await this.db.exec(`RELEASE SAVEPOINT ${savepoint}`);
            }

            TransactionScope.getLogger().debug('Transaction committed', {
                remainingDepth: this.depth
            });
        } catch (error) {
            TransactionScope.getLogger().error('Failed to commit transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to commit transaction',
                'commit',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Rolls back the current transaction or savepoint
     */
    async rollback(): Promise<void> {
        if (!this.active) {
            return; // No-op if no active transaction
        }

        try {
            if (this.depth === 1) {
                // Rollback main transaction
                await this.db.exec('ROLLBACK');
                this.active = false;
                this.savepoints = [];
            } else {
                // Rollback to savepoint
                const savepoint = this.savepoints.pop();
                await this.db.exec(`ROLLBACK TO SAVEPOINT ${savepoint}`);
            }
            this.depth = Math.max(0, this.depth - 1);

            TransactionScope.getLogger().debug('Transaction rolled back', {
                remainingDepth: this.depth
            });
        } catch (error) {
            TransactionScope.getLogger().error('Failed to rollback transaction', { error });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to rollback transaction',
                'rollback',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Executes work within a transaction scope
     * Automatically handles commit/rollback
     */
    async executeInTransaction<T>(
        work: () => Promise<T>,
        isolationLevel: IsolationLevel = IsolationLevel.SERIALIZABLE
    ): Promise<T> {
        await this.begin(isolationLevel);
        try {
            const result = await work();
            await this.commit();
            return result;
        } catch (error) {
            await this.rollback();
            throw error;
        }
    }

    /**
     * Sets the isolation level for the current transaction
     */
    private async setIsolationLevel(level: IsolationLevel): Promise<void> {
        try {
            switch (level) {
                case IsolationLevel.READ_UNCOMMITTED:
                    await this.db.exec('PRAGMA read_uncommitted = 1');
                    break;
                case IsolationLevel.READ_COMMITTED:
                    await this.db.exec('PRAGMA read_uncommitted = 0');
                    break;
                case IsolationLevel.REPEATABLE_READ:
                case IsolationLevel.SERIALIZABLE:
                    // SQLite's default is SERIALIZABLE
                    break;
            }
        } catch (error) {
            TransactionScope.getLogger().error('Failed to set isolation level', {
                error,
                level
            });
            throw error;
        }
    }

    /**
     * Checks if there is an active transaction
     */
    isActive(): boolean {
        return this.active;
    }

    /**
     * Gets the current transaction depth
     */
    getDepth(): number {
        return this.depth;
    }

    /**
     * Ensures no active transaction
     * Used before operations that can't run in a transaction (like VACUUM)
     */
    async ensureNoTransaction(): Promise<void> {
        if (this.active) {
            await this.rollback();
        }
    }
}

================
File: storage/core/wal/manager.ts
================
/**
 * WAL (Write-Ahead Logging) management
 */
import { Database } from 'sqlite';
import { Logger } from '../../../logging/index.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { promises as fs } from 'fs';

export interface WALMetrics {
    isEnabled: boolean;
    walSize: number;
    lastCheckpoint: number;
    checkpointCount: number;
    autoCheckpointSize: number;
}

export class WALManager {
    private static instance: WALManager;
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private isWALEnabled = false;
    private lastCheckpoint = 0;
    private checkpointCount = 0;
    private readonly dbPath: string;
    private checkpointInterval: NodeJS.Timeout | null = null;
    private readonly CHECKPOINT_INTERVAL = 60000; // 1 minute
    private readonly MAX_WAL_SIZE = 10 * 1024 * 1024; // 10MB

    private constructor(dbPath: string) {
        this.logger = Logger.getInstance().child({ component: 'WALManager' });
        this.eventManager = EventManager.getInstance();
        this.dbPath = dbPath;
        this.resetState();
    }

    /**
     * Reset internal state
     */
    private resetState(): void {
        this.isWALEnabled = false;
        this.lastCheckpoint = 0;
        this.checkpointCount = 0;
        if (this.checkpointInterval) {
            clearInterval(this.checkpointInterval);
            this.checkpointInterval = null;
        }
    }

    static getInstance(dbPath?: string): WALManager {
        if (!WALManager.instance) {
            if (!dbPath) {
                throw new Error('dbPath required for WALManager initialization');
            }
            WALManager.instance = new WALManager(dbPath);
        }
        return WALManager.instance;
    }

    /**
     * Enable WAL mode with proper locking and verification
     */
    async enableWAL(db: Database): Promise<void> {
        if (this.isWALEnabled) {
            return;
        }

        // Clean up any existing WAL files from previous runs
        await this.cleanupWALFiles();

        try {
            // Set exclusive lock to prevent other connections
            await db.exec('PRAGMA locking_mode = EXCLUSIVE');
            
            // Check current mode
            const currentMode = await db.get<{ journal_mode: string }>('PRAGMA journal_mode');
            
            if (currentMode?.journal_mode !== 'wal') {
                // Force checkpoint existing journal
                await db.exec('PRAGMA wal_checkpoint(TRUNCATE)');
                
                // Enable WAL mode
                await db.exec('PRAGMA journal_mode = WAL');
                
                // Verify WAL mode
                const newMode = await db.get<{ journal_mode: string }>('PRAGMA journal_mode');
                if (newMode?.journal_mode !== 'wal') {
                    throw createError(
                        ErrorCodes.STORAGE_INIT,
                        'Failed to enable WAL mode',
                        `Expected 'wal', got '${newMode?.journal_mode}'`
                    );
                }

                try {
                    // Set synchronous mode first (must be outside transaction)
                    await db.exec('PRAGMA synchronous = NORMAL');
                    
                    // Verify synchronous setting
                    const syncMode = await db.get('PRAGMA synchronous');
                    if (syncMode?.synchronous !== 1) { // NORMAL = 1
                        throw new Error('Failed to set synchronous mode');
                    }

                    // Set other PRAGMAs in transaction
                    await db.exec('BEGIN IMMEDIATE');
                    await db.exec('PRAGMA wal_autocheckpoint = 1000');
                    await db.exec(`PRAGMA journal_size_limit = ${this.MAX_WAL_SIZE}`);
                    await db.exec('COMMIT');

                    // Verify transaction-safe settings
                    const checkpoint = await db.get('PRAGMA wal_autocheckpoint');
                    const journalSize = await db.get('PRAGMA journal_size_limit');

                    if (checkpoint?.wal_autocheckpoint !== 1000 ||
                        journalSize?.journal_size_limit !== this.MAX_WAL_SIZE) {
                        throw new Error('Failed to set WAL optimization settings');
                    }

                    this.isWALEnabled = true;
                    this.startCheckpointMonitoring(db);

                    this.logger.info('WAL mode enabled successfully', {
                        mode: newMode.journal_mode,
                        settings: {
                            synchronous: syncMode?.synchronous,
                            journal_mode: newMode.journal_mode,
                            wal_autocheckpoint: checkpoint?.wal_autocheckpoint,
                            journal_size_limit: journalSize?.journal_size_limit
                        }
                    });
                } catch (error) {
                    // Roll back transaction if it failed
                    await db.exec('ROLLBACK').catch(() => {});
                    throw error;
                }

                // Emit WAL enabled event
                this.eventManager.emitSystemEvent({
                    type: EventTypes.STORAGE_WAL_ENABLED,
                    timestamp: Date.now(),
                    metadata: {
                        dbPath: this.dbPath
                    }
                });
            } else {
                this.isWALEnabled = true;
                this.startCheckpointMonitoring(db);
                this.logger.info('Database already in WAL mode');
            }
        } catch (error) {
            // Ensure error is properly stringified
            const errorMessage = error instanceof Error 
                ? error.message 
                : error && typeof error === 'object'
                    ? JSON.stringify(error)
                    : String(error);
            
            this.logger.error('Failed to enable WAL mode', { 
                error: errorMessage,
                details: error instanceof Error ? error.stack : undefined
            });
            
            // Reset WAL state
            this.isWALEnabled = false;
            
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to enable WAL mode',
                errorMessage
            );
        } finally {
            // Release exclusive lock
            try {
                await db.exec('PRAGMA locking_mode = NORMAL');
            } catch (error) {
                this.logger.warn('Failed to release exclusive lock', { error });
            }
        }
    }

    /**
     * Start periodic checkpoint monitoring
     */
    private startCheckpointMonitoring(db: Database): void {
        if (this.checkpointInterval) {
            return;
        }

        // Check WAL size periodically
        this.checkpointInterval = setInterval(async () => {
            try {
                const metrics = await this.getMetrics();
                
                // If WAL file is too large, force a checkpoint
                if (metrics.walSize > this.MAX_WAL_SIZE) {
                    await this.checkpoint(db);
                }
            } catch (error) {
                this.logger.error('Checkpoint monitoring failed', { error });
            }
        }, this.CHECKPOINT_INTERVAL);

        // Ensure the interval doesn't prevent the process from exiting
        this.checkpointInterval.unref();
    }

    /**
     * Force a WAL checkpoint
     */
    async checkpoint(db: Database): Promise<void> {
        try {
            await db.exec('PRAGMA wal_checkpoint(TRUNCATE)');
            this.lastCheckpoint = Date.now();
            this.checkpointCount++;
            
            this.logger.info('WAL checkpoint completed', {
                checkpointCount: this.checkpointCount
            });

            // Emit checkpoint event
            this.eventManager.emitSystemEvent({
                type: EventTypes.STORAGE_WAL_CHECKPOINT,
                timestamp: Date.now(),
                metadata: {
                    checkpointCount: this.checkpointCount,
                    dbPath: this.dbPath
                }
            });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('WAL checkpoint failed', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'WAL checkpoint failed',
                errorMessage
            );
        }
    }

    /**
     * Get WAL metrics
     */
    async getMetrics(): Promise<WALMetrics> {
        const path = await import('path');
        const walPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-wal');
        let walSize = 0;

        try {
            const stats = await fs.stat(walPath);
            walSize = stats.size;
        } catch (error) {
            // WAL file might not exist yet
            this.logger.debug('Could not get WAL file size', { error });
        }

        return {
            isEnabled: this.isWALEnabled,
            walSize,
            lastCheckpoint: this.lastCheckpoint,
            checkpointCount: this.checkpointCount,
            autoCheckpointSize: 1000 // Pages
        };
    }

    /**
     * Verify WAL file integrity
     */
    async verifyWALIntegrity(): Promise<boolean> {
        const path = await import('path');
        const walPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-wal');
        const shmPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-shm');

        try {
            // Check if WAL and SHM files exist
            await Promise.all([
                fs.access(walPath),
                fs.access(shmPath)
            ]);

            // Get WAL file size
            const stats = await fs.stat(walPath);
            
            // Basic integrity checks
            if (stats.size === 0) {
                this.logger.warn('WAL file is empty', { walPath });
                return false;
            }

            if (stats.size % 4096 !== 0) {
                this.logger.warn('WAL file size is not page-aligned', { 
                    size: stats.size,
                    walPath 
                });
                return false;
            }

            return true;
        } catch (error) {
            this.logger.warn('WAL integrity check failed', { error });
            return false;
        }
    }

    /**
     * Clean up any existing WAL files
     */
    private lastCleanup = 0;
    private readonly CLEANUP_INTERVAL = 1000; // 1 second

    private async cleanupWALFiles(): Promise<void> {
        const now = Date.now();
        // Only cleanup every 5 seconds to reduce memory pressure
        if (now - this.lastCleanup < this.CLEANUP_INTERVAL) {
            return;
        }

        const path = await import('path');
        const walPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-wal');
        const shmPath = path.join(path.dirname(this.dbPath), path.basename(this.dbPath) + '-shm');

        try {
            // Check if files exist first to avoid unnecessary operations
            const [walExists, shmExists] = await Promise.all([
                fs.access(walPath).then(() => true).catch(() => false),
                fs.access(shmPath).then(() => true).catch(() => false)
            ]);

            // Only delete if files exist
            if (walExists || shmExists) {
                const promises = [];
                if (walExists) promises.push(fs.unlink(walPath));
                if (shmExists) promises.push(fs.unlink(shmPath));
                await Promise.all(promises);
                this.logger.debug('Cleaned up existing WAL files');
            }
        } catch (error) {
            // Ignore errors as files may not exist
            this.logger.debug('No existing WAL files to clean up');
        } finally {
            this.lastCleanup = now;
        }
    }

    /**
     * Clean up resources
     */
    async close(): Promise<void> {
        try {
            // Stop checkpoint monitoring
            if (this.checkpointInterval) {
                clearInterval(this.checkpointInterval);
                this.checkpointInterval = null;
            }

            // Clean up WAL files
            await this.cleanupWALFiles();
            
            // Reset state
            this.resetState();

            this.logger.info('WAL manager closed successfully');
        } catch (error) {
            this.logger.error('Error closing WAL manager', { error });
            throw error;
        }
    }
}

================
File: storage/core/index.ts
================
/**
 * Core storage components
 */

// Types
import { StorageConfig } from '../../types/storage.js';

// Connection management
import { ConnectionManager, type ConnectionOptions } from './connection/manager.js';
import { ConnectionPool } from './connection/pool.js';

// Query handling
import { QueryBuilder } from './query/builder.js';
import { QueryExecutor } from './query/executor.js';
import { QueryOptimizer } from './query/optimizer.js';

// Schema management
import { SchemaManager } from './schema/migrations.js';
import { SchemaValidator } from './schema/validator.js';
import { BackupManager } from './schema/backup.js';

// Re-export everything
export { ConnectionManager, type ConnectionOptions } from './connection/manager.js';
export { ConnectionPool } from './connection/pool.js';
export { HealthMonitor, type ConnectionHealth, type HealthMetrics } from './connection/health.js';

// Query handling
export { QueryBuilder } from './query/builder.js';
export { QueryExecutor } from './query/executor.js';
export { QueryOptimizer } from './query/optimizer.js';

// Schema management
export { SchemaManager } from './schema/migrations.js';
export { 
    SchemaValidator,
    type TableDefinition,
    type ColumnDefinition,
    type ValidationResult 
} from './schema/validator.js';
export { 
    BackupManager,
    type BackupMetadata,
    type BackupOptions,
    type RestoreOptions 
} from './schema/backup.js';

// Utility types
export interface StorageOptions {
    // Connection options
    connection?: ConnectionOptions;
    minConnections?: number;
    maxConnections?: number;
    idleTimeout?: number;
    healthCheckInterval?: number;
    errorThreshold?: number;
    responseTimeThreshold?: number;

    // Query options
    slowQueryThreshold?: number;
    maxQueryCacheSize?: number;
    queryCacheTTL?: number;
    costThreshold?: number;

    // Backup options
    backupDir?: string;
    maxBackups?: number;
}

// Factory function to create storage components
export function createStorageCore(config: StorageConfig, options: StorageOptions = {}) {
    // Create connection pool and manager
    const pool = new ConnectionPool({
        ...config,
        monitoring: {
            enabled: true,
            healthCheck: {
                enabled: true,
                interval: options.healthCheckInterval,
                errorThreshold: options.errorThreshold,
                responseTimeThreshold: options.responseTimeThreshold
            },
            metrics: {
                enabled: true
            }
        }
    }, {
        minConnections: options.minConnections,
        maxConnections: options.maxConnections,
        idleTimeout: options.idleTimeout
    });

    const connectionManager = new ConnectionManager(config, options.connection);

    // Create query components
    const queryBuilder = new QueryBuilder();
    const queryExecutor = new QueryExecutor(pool, {
        slowQueryThreshold: options.slowQueryThreshold,
        maxCacheSize: options.maxQueryCacheSize,
        defaultCacheTTL: options.queryCacheTTL
    });
    const queryOptimizer = new QueryOptimizer({
        costThreshold: options.costThreshold
    });

    // Create schema components
    const migrationManager = new SchemaManager();
    const schemaValidator = new SchemaValidator();
    const backupManager = options.backupDir ? new BackupManager({
        backupDir: options.backupDir,
        maxBackups: options.maxBackups
    }) : null;

    return {
        // Connection management
        pool,
        connectionManager,

        // Query handling
        queryBuilder,
        queryExecutor,
        queryOptimizer,

        // Schema management
        migrationManager,
        schemaValidator,
        backupManager,

        // Initialization
        async initialize() {
            await pool.initialize();
            if (backupManager) {
                await backupManager.initialize();
            }
        },

        // Cleanup
        async close() {
            await pool.close();
        }
    };
}

================
File: storage/monitoring/health.ts
================
/**
 * Storage health monitoring
 */
import { Logger } from '../../logging/index.js';
import { EventManager } from '../../events/event-manager.js';
import { EventTypes } from '../../types/events.js';

export interface HealthMonitorOptions {
    checkInterval?: number;
    errorThreshold?: number;
    responseTimeThreshold?: number;
}

export class HealthMonitor {
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly options: Required<HealthMonitorOptions>;
    private healthCheckInterval: NodeJS.Timeout | null = null;
    private readonly DEFAULT_CHECK_INTERVAL = 30000; // 30 seconds
    private readonly DEFAULT_ERROR_THRESHOLD = 5;
    private readonly DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second

    private errorCount = 0;
    private lastCheckTime = 0;
    private isHealthy = true;

    constructor(options: HealthMonitorOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'HealthMonitor' });
        this.eventManager = EventManager.getInstance();
        this.options = {
            checkInterval: options.checkInterval || this.DEFAULT_CHECK_INTERVAL,
            errorThreshold: options.errorThreshold || this.DEFAULT_ERROR_THRESHOLD,
            responseTimeThreshold: options.responseTimeThreshold || this.DEFAULT_RESPONSE_TIME_THRESHOLD
        };
    }

    /**
     * Start health monitoring
     */
    start(): void {
        if (this.healthCheckInterval) {
            return;
        }

        this.healthCheckInterval = setInterval(() => {
            this.checkHealth();
        }, this.options.checkInterval);

        // Ensure the interval doesn't prevent the process from exiting
        this.healthCheckInterval.unref();

        this.logger.info('Health monitoring started', {
            interval: this.options.checkInterval
        });
    }

    /**
     * Stop health monitoring
     */
    stop(): void {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
        this.logger.info('Health monitoring stopped');
    }

    /**
     * Record error occurrence
     */
    recordError(error: Error): void {
        this.errorCount++;
        this.isHealthy = this.errorCount < this.options.errorThreshold;

        if (!this.isHealthy) {
            this.logger.error('Health check failed', {
                error,
                errorCount: this.errorCount,
                threshold: this.options.errorThreshold
            });

            // Emit health event
            this.eventManager.emitSystemEvent({
                type: EventTypes.SYSTEM_ERROR,
                timestamp: Date.now(),
                metadata: {
                    component: 'HealthMonitor',
                    error,
                    memoryUsage: process.memoryUsage()
                }
            });
        }
    }

    /**
     * Record successful operation
     */
    recordSuccess(): void {
        // Reset error count on successful operations
        if (this.errorCount > 0) {
            this.errorCount = 0;
            this.isHealthy = true;
        }
    }

    /**
     * Get current health status
     */
    getHealth(): { isHealthy: boolean; errorCount: number; lastCheck: number } {
        return {
            isHealthy: this.isHealthy,
            errorCount: this.errorCount,
            lastCheck: this.lastCheckTime
        };
    }

    /**
     * Reset health status
     */
    reset(): void {
        this.errorCount = 0;
        this.isHealthy = true;
        this.lastCheckTime = Date.now();
    }

    /**
     * Perform health check
     */
    private checkHealth(): void {
        this.lastCheckTime = Date.now();

        // Check memory usage
        const memoryUsage = process.memoryUsage();
        const heapUsedPercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;

        if (heapUsedPercent > 90) {
            this.logger.warn('High memory usage detected', {
                heapUsed: memoryUsage.heapUsed,
                heapTotal: memoryUsage.heapTotal,
                usedPercent: heapUsedPercent
            });
        }

        // Emit health status event
        this.eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_STARTUP,
            timestamp: this.lastCheckTime,
            metadata: {
                component: 'HealthMonitor',
                memoryUsage,
                success: this.isHealthy,
                error: this.isHealthy ? undefined : new Error(`Error threshold exceeded: ${this.errorCount}`)
            }
        });

        // Log health status
        this.logger.info('Health check completed', {
            isHealthy: this.isHealthy,
            errorCount: this.errorCount,
            memoryUsage: {
                heapUsedPercent,
                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + 'MB',
                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + 'MB'
            }
        });
    }
}

================
File: storage/monitoring/index.ts
================
/**
 * Storage monitoring module exports
 */
export { MetricsCollector, type MetricsCollectorOptions } from './metrics.js';
export { HealthMonitor, type HealthMonitorOptions } from './health.js';

// Re-export types
export type { MonitoringMetrics } from '../../types/storage.js';

// Constants
export const DEFAULT_CHECK_INTERVAL = 30000; // 30 seconds
export const DEFAULT_ERROR_THRESHOLD = 5;
export const DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second
export const DEFAULT_METRICS_INTERVAL = 60000; // 1 minute

// Monitoring event types
export const MonitoringEventTypes = {
    HEALTH_CHECK: 'health_check',
    METRICS_COLLECTED: 'metrics_collected',
    ERROR_THRESHOLD_EXCEEDED: 'error_threshold_exceeded',
    HIGH_MEMORY_USAGE: 'high_memory_usage',
    SLOW_QUERY_DETECTED: 'slow_query_detected'
} as const;

// Health status types
export const HealthStatus = {
    HEALTHY: 'healthy',
    DEGRADED: 'degraded',
    UNHEALTHY: 'unhealthy'
} as const;

// Monitoring interfaces
export interface HealthStatus {
    status: typeof HealthStatus[keyof typeof HealthStatus];
    errorCount: number;
    lastCheck: number;
    memoryUsage: {
        heapUsed: number;
        heapTotal: number;
        heapUsedPercent: number;
        rss: number;
    };
}

export interface MonitoringConfig {
    enabled: boolean;
    healthCheck?: {
        enabled?: boolean;
        interval?: number;
        errorThreshold?: number;
        responseTimeThreshold?: number;
    };
    metrics?: {
        enabled?: boolean;
        interval?: number;
        errorThreshold?: number;
        responseTimeThreshold?: number;
    };
}

// Utility functions
export function formatMemorySize(bytes: number): string {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }

    return `${Math.round(size * 100) / 100}${units[unitIndex]}`;
}

export function calculateMemoryUsage(): {
    heapUsed: number;
    heapTotal: number;
    heapUsedPercent: number;
    rss: number;
} {
    const memoryUsage = process.memoryUsage();
    return {
        heapUsed: memoryUsage.heapUsed,
        heapTotal: memoryUsage.heapTotal,
        heapUsedPercent: (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100,
        rss: memoryUsage.rss
    };
}

export function isHealthy(status: HealthStatus): boolean {
    return status.status === HealthStatus.HEALTHY;
}

export function isDegraded(status: HealthStatus): boolean {
    return status.status === HealthStatus.DEGRADED;
}

export function isUnhealthy(status: HealthStatus): boolean {
    return status.status === HealthStatus.UNHEALTHY;
}

================
File: storage/monitoring/metrics.ts
================
/**
 * Storage metrics collection and monitoring
 */
import { Logger } from '../../logging/index.js';
import { EventManager } from '../../events/event-manager.js';
import { EventTypes } from '../../types/events.js';
import { MonitoringMetrics } from '../../types/storage.js';

export interface MetricsCollectorOptions {
    checkInterval?: number;
    errorThreshold?: number;
    responseTimeThreshold?: number;
    metricsInterval?: number;
}

export class MetricsCollector {
    private readonly logger: Logger;
    private readonly eventManager: EventManager;
    private readonly options: Required<MetricsCollectorOptions>;
    private metricsInterval: NodeJS.Timeout | null = null;
    private readonly DEFAULT_CHECK_INTERVAL = 30000; // 30 seconds
    private readonly DEFAULT_ERROR_THRESHOLD = 5;
    private readonly DEFAULT_RESPONSE_TIME_THRESHOLD = 1000; // 1 second
    private readonly DEFAULT_METRICS_INTERVAL = 60000; // 1 minute

    private totalQueries = 0;
    private errorCount = 0;
    private totalResponseTime = 0;
    private slowQueries = 0;

    constructor(options: MetricsCollectorOptions = {}) {
        this.logger = Logger.getInstance().child({ component: 'MetricsCollector' });
        this.eventManager = EventManager.getInstance();
        this.options = {
            checkInterval: options.checkInterval || this.DEFAULT_CHECK_INTERVAL,
            errorThreshold: options.errorThreshold || this.DEFAULT_ERROR_THRESHOLD,
            responseTimeThreshold: options.responseTimeThreshold || this.DEFAULT_RESPONSE_TIME_THRESHOLD,
            metricsInterval: options.metricsInterval || this.DEFAULT_METRICS_INTERVAL
        };
    }

    /**
     * Start metrics collection
     */
    start(): void {
        if (this.metricsInterval) {
            return;
        }

        this.metricsInterval = setInterval(() => {
            this.collectMetrics();
        }, this.options.metricsInterval);

        // Ensure the interval doesn't prevent the process from exiting
        this.metricsInterval.unref();

        this.logger.info('Metrics collection started', {
            interval: this.options.metricsInterval
        });
    }

    /**
     * Stop metrics collection
     */
    stop(): void {
        if (this.metricsInterval) {
            clearInterval(this.metricsInterval);
            this.metricsInterval = null;
        }
        this.logger.info('Metrics collection stopped');
    }

    /**
     * Record query execution
     */
    recordQuery(duration: number, error?: Error): void {
        this.totalQueries++;
        if (error) {
            this.errorCount++;
        }
        this.totalResponseTime += duration;
        if (duration > this.options.responseTimeThreshold) {
            this.slowQueries++;
        }
    }

    /**
     * Get current metrics
     */
    getMetrics(): MonitoringMetrics {
        const memoryUsage = process.memoryUsage();
        return {
            cache: {
                hits: 0, // Populated by storage implementation
                misses: 0,
                hitRate: 0,
                size: 0,
                memoryUsage: memoryUsage.heapUsed
            },
            connections: {
                total: 0, // Populated by connection pool
                active: 0,
                idle: 0,
                errors: this.errorCount,
                avgResponseTime: this.totalQueries > 0 
                    ? this.totalResponseTime / this.totalQueries 
                    : 0
            },
            queries: {
                total: this.totalQueries,
                errors: this.errorCount,
                avgExecutionTime: this.totalQueries > 0 
                    ? this.totalResponseTime / this.totalQueries 
                    : 0,
                slowQueries: this.slowQueries
            },
            timestamp: Date.now()
        };
    }

    /**
     * Reset metrics counters
     */
    reset(): void {
        this.totalQueries = 0;
        this.errorCount = 0;
        this.totalResponseTime = 0;
        this.slowQueries = 0;
    }

    /**
     * Collect and emit metrics
     */
    private collectMetrics(): void {
        const metrics = this.getMetrics();

        // Emit metrics event
        this.eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_STARTUP,
            timestamp: Date.now(),
            metadata: {
                component: 'MetricsCollector',
                memoryUsage: process.memoryUsage(),
                metrics
            }
        });

        // Log metrics summary
        this.logger.info('Storage metrics collected', {
            queries: metrics.queries,
            connections: metrics.connections,
            cache: metrics.cache
        });

        // Check for concerning metrics
        if (metrics.queries.errors > this.options.errorThreshold) {
            this.logger.warn('High error rate detected', {
                errors: metrics.queries.errors,
                threshold: this.options.errorThreshold
            });
        }

        if (metrics.queries.slowQueries > 0) {
            this.logger.warn('Slow queries detected', {
                count: metrics.queries.slowQueries,
                avgTime: metrics.queries.avgExecutionTime
            });
        }

        // Reset counters after collection
        this.reset();
    }
}

================
File: storage/sqlite/index.ts
================
/**
 * SQLite Storage Implementation
 * 
 * This module provides a SQLite-based implementation of the TaskStorage interface,
 * with support for:
 * - Task CRUD operations
 * - Transaction management
 * - Database maintenance
 * - Performance monitoring
 * - Data integrity verification
 */

// Core initialization and cleanup
export { 
    initializeSqliteStorage  // Initialize SQLite storage cleanup handlers
} from './init.js';

// Storage implementation and configuration
export { 
    SqliteStorage,           // Main storage class implementing TaskStorage interface
    SqliteConfig,            // Configuration interface for SQLite storage
    DEFAULT_PAGE_SIZE,       // Default SQLite page size (4KB)
    DEFAULT_CACHE_SIZE,      // Default cache size (2000 pages)
    DEFAULT_BUSY_TIMEOUT     // Default busy timeout (5000ms)
} from './storage.js';

// Re-export task types for convenience
export type {
    Task,
    TaskStatus,
    CreateTaskInput,
    UpdateTaskInput
} from '../../types/task.js';

================
File: storage/sqlite/init.ts
================
import { Logger } from '../../logging/index.js';
import { createDefaultStorage } from '../factory.js';

/**
 * Sets up cleanup handlers for SQLite storage
 */
export async function initializeSqliteStorage(): Promise<void> {
    const logger = Logger.getInstance();
    const storage = await createDefaultStorage();
    
    // Set up cleanup on process exit
    let isCleaningUp = false;
    const cleanup = async (signal: string) => {
        if (isCleaningUp) {
            return;
        }
        isCleaningUp = true;

        try {
            logger.info('Cleaning up SQLite storage...', { signal });
            await storage.close();
        } catch (error) {
            // Only log non-"already closed" errors
            if (!(error instanceof Error && error.message.includes('Database handle is closed'))) {
                logger.error('Error closing SQLite storage', {
                    error: error instanceof Error ? error.message : String(error)
                });
            }
        }

        // Exit after cleanup
        process.exit(0);
    };

    // Handle termination signals
    process.once('SIGINT', () => cleanup('SIGINT'));
    process.once('SIGTERM', () => cleanup('SIGTERM'));
    process.once('beforeExit', () => cleanup('beforeExit'));

    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
        logger.error('Uncaught exception, cleaning up...', {
            error: error instanceof Error ? error.message : String(error)
        });
        await cleanup('uncaughtException');
    });

    logger.info('SQLite cleanup handlers initialized');
}

================
File: storage/sqlite/storage.ts
================
import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';
import { TaskStorage } from '../../types/storage.js';
import { Task, TaskStatus, CreateTaskInput, UpdateTaskInput } from '../../types/task.js';
import { Logger } from '../../logging/index.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionScope, IsolationLevel } from '../core/transactions/scope.js';

// Constants
export const DEFAULT_PAGE_SIZE = 4096;
export const DEFAULT_CACHE_SIZE = 2000;
export const DEFAULT_BUSY_TIMEOUT = 5000;

// Configuration types
export interface SqliteConfig {
    baseDir: string;
    name: string;
    sqlite?: {
        journalMode?: 'DELETE' | 'TRUNCATE' | 'PERSIST' | 'MEMORY' | 'WAL' | 'OFF';
        synchronous?: 'OFF' | 'NORMAL' | 'FULL' | 'EXTRA';
        tempStore?: 'DEFAULT' | 'FILE' | 'MEMORY';
        lockingMode?: 'NORMAL' | 'EXCLUSIVE';
        autoVacuum?: 'NONE' | 'FULL' | 'INCREMENTAL';
    };
    performance?: {
        pageSize?: number;
        cacheSize?: number;
        mmapSize?: number;
    };
    connection?: {
        busyTimeout?: number;
        maxRetries?: number;
        retryDelay?: number;
    };
}

export class SqliteStorage implements TaskStorage {
    private static initializationPromise: Promise<void> | null = null;
    private db: Database | null = null;
    private readonly logger: Logger;
    private readonly dbPath: string;
    private isInitialized = false;
    private transactionScope: TransactionScope | null = null;

    constructor(private readonly config: SqliteConfig) {
        this.logger = Logger.getInstance().child({ component: 'SqliteStorage' });
        this.dbPath = `${config.baseDir}/${config.name}.db`;
    }

    async initialize(): Promise<void> {
        // Return if already initialized
        if (this.isInitialized) {
            this.logger.debug('SQLite storage already initialized');
            return;
        }

        // If initialization is in progress, wait for it
        if (SqliteStorage.initializationPromise) {
            this.logger.debug('Waiting for existing initialization to complete');
            await SqliteStorage.initializationPromise;
            return;
        }

        // Start new initialization with mutex
        SqliteStorage.initializationPromise = (async () => {
            try {
                // Initialize SQLite with WAL mode
                this.db = await open({
                    filename: this.dbPath,
                    driver: sqlite3.Database,
                    mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE
                });

                // Initialize transaction scope
                this.transactionScope = new TransactionScope(this.db);

                // Configure database with proper error handling
                const pragmas = [
                    // Enable WAL mode first for better concurrency
                    `PRAGMA journal_mode=${this.config.sqlite?.journalMode || 'WAL'}`,
                    
                    // Enable foreign keys for referential integrity
                    'PRAGMA foreign_keys=ON',
                    
                    // Configure synchronization and durability
                    `PRAGMA synchronous=${this.config.sqlite?.synchronous || 'NORMAL'}`,
                    
                    // Memory and performance settings
                    `PRAGMA temp_store=${this.config.sqlite?.tempStore || 'MEMORY'}`,
                    `PRAGMA page_size=${this.config.performance?.pageSize || DEFAULT_PAGE_SIZE}`,
                    `PRAGMA cache_size=${this.config.performance?.cacheSize || DEFAULT_CACHE_SIZE}`,
                    `PRAGMA mmap_size=${this.config.performance?.mmapSize || 30000000000}`,
                    
                    // Concurrency settings
                    `PRAGMA locking_mode=${this.config.sqlite?.lockingMode || 'NORMAL'}`,
                    `PRAGMA busy_timeout=${this.config.connection?.busyTimeout || DEFAULT_BUSY_TIMEOUT}`,
                    
                    // Maintenance settings
                    `PRAGMA auto_vacuum=${this.config.sqlite?.autoVacuum || 'NONE'}`,
                    
                    // Query optimization
                    'PRAGMA optimize'
                ];

                for (const pragma of pragmas) {
                    try {
                        await this.db.exec(pragma);
                    } catch (error) {
                        this.logger.error(`Failed to set pragma: ${pragma}`, {
                            error: error instanceof Error ? error.message : String(error)
                        });
                        throw error;
                    }
                }

                // Verify foreign keys are enabled
                const fkResult = await this.db.get('PRAGMA foreign_keys');
                if (!fkResult || !fkResult['foreign_keys']) {
                    throw new Error('Failed to enable foreign key constraints');
                }

                // Create tables and set up database schema
                await this.setupDatabase();

                this.isInitialized = true;
                this.logger.info('SQLite storage initialized', {
                    path: this.dbPath,
                    config: this.config
                });
            } catch (error) {
                this.logger.error('Failed to initialize SQLite storage', {
                    error: error instanceof Error ? error.message : String(error),
                    path: this.dbPath
                });
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    'Failed to initialize SQLite storage',
                    error instanceof Error ? error.message : String(error)
                );
            } finally {
                SqliteStorage.initializationPromise = null;
            }
        })();

        await SqliteStorage.initializationPromise;
    }

    /**
     * Sets up the database schema and tables
     */
    private async setupDatabase(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');

        try {
            // Create tables and indexes
            await this.db.exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                    path TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    parent_path TEXT,
                    notes TEXT,
                    reasoning TEXT,
                    dependencies TEXT,
                    subtasks TEXT,
                    metadata TEXT,
                    created_at INTEGER NOT NULL,
                    updated_at INTEGER NOT NULL,
                    version INTEGER NOT NULL DEFAULT 1
                );

                CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path);
                CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
                CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type);
            `);

            // Set WAL file permissions if needed
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
                const walPath = `${dbPath}-wal`;
                const shmPath = `${dbPath}-shm`;
                
                // Set permissions for WAL and SHM files if they exist
                await Promise.all([
                    fs.access(walPath).then(() => fs.chmod(walPath, 0o644)).catch(() => {}),
                    fs.access(shmPath).then(() => fs.chmod(shmPath, 0o644)).catch(() => {})
                ]);
            } catch (error) {
                this.logger.warn('Failed to set WAL file permissions', { error });
                // Don't throw - this is not critical
            }

            this.logger.info('Database schema setup completed');
        } catch (error) {
            this.logger.error('Failed to set up database schema', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    private isClosed = false;

    async close(): Promise<void> {
        if (!this.db || this.isClosed) {
            return;
        }

        try {
            // Cleanup any active transactions
            if (this.transactionScope?.isActive()) {
                await this.transactionScope.rollback();
            }

            this.isClosed = true;
            await this.db.close();
            this.db = null;
            this.logger.info('SQLite connection closed');
        } catch (error) {
            if (error instanceof Error && error.message.includes('Database handle is closed')) {
                // Ignore already closed errors
                return;
            }
            this.logger.error('Error closing SQLite connection', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    // Transaction methods
    async beginTransaction(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        await this.transactionScope.begin(IsolationLevel.SERIALIZABLE);
    }

    async commitTransaction(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        await this.transactionScope.commit();
    }

    async rollbackTransaction(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        await this.transactionScope.rollback();
    }

    /**
     * Executes work within a transaction
     */
    async executeInTransaction<T>(work: () => Promise<T>): Promise<T> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        return this.transactionScope.executeInTransaction(work);
    }

    // Task operations
    async createTask(input: CreateTaskInput): Promise<Task> {
        if (!this.db) throw new Error('Database not initialized');
        
        if (!input.path || !input.name || !input.type) {
            throw createError(
                ErrorCodes.VALIDATION_ERROR,
                'Missing required fields',
                'createTask',
                'path, name, and type are required'
            );
        }

        const now = Date.now();
        const projectPath = input.path.split('/')[0];
        
        const task: Task = {
            // System fields
            path: input.path,
            name: input.name,
            type: input.type,
            status: TaskStatus.PENDING,
            created: now,
            updated: now,
            version: 1,
            projectPath,

            // Optional fields
            description: input.description,
            parentPath: input.parentPath,
            notes: input.notes || [],
            reasoning: input.reasoning,
            dependencies: input.dependencies || [],
            subtasks: [],
            
            // User metadata
            metadata: input.metadata || {}
        };

        await this.saveTask(task);
        return task;
    }

    async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
        if (!this.db) throw new Error('Database not initialized');
        
        const existingTask = await this.getTask(path);
        if (!existingTask) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                'Task not found',
                'updateTask',
                path
            );
        }

        const now = Date.now();
        const updatedTask: Task = {
            ...existingTask,
            ...updates,
            // Update system fields
            updated: now,
            version: existingTask.version + 1,
            // Keep user metadata separate
            metadata: {
                ...existingTask.metadata,
                ...updates.metadata
            }
        };

        await this.saveTask(updatedTask);
        return updatedTask;
    }

    async getTask(path: string): Promise<Task | null> {
        if (!this.db) throw new Error('Database not initialized');
        
        const row = await this.db.get<Record<string, unknown>>(
            'SELECT * FROM tasks WHERE path = ?',
            path
        );

        if (!row) return null;
        return this.rowToTask(row);
    }

    async getTasks(paths: string[]): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        if (paths.length === 0) return [];

        const placeholders = paths.map(() => '?').join(',');
        const rows = await this.db.all<Record<string, unknown>[]>(
            `SELECT * FROM tasks WHERE path IN (${placeholders})`,
            ...paths
        );

        return rows.map(row => this.rowToTask(row));
    }

    async getTasksByPattern(pattern: string): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        const sqlPattern = pattern.replace(/\*/g, '%').replace(/\?/g, '_');
        const rows = await this.db.all<Record<string, unknown>[]>(
            'SELECT * FROM tasks WHERE path LIKE ?',
            sqlPattern
        );

        return rows.map(row => this.rowToTask(row));
    }

    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        const rows = await this.db.all<Record<string, unknown>[]>(
            'SELECT * FROM tasks WHERE status = ?',
            status
        );

        return rows.map(row => this.rowToTask(row));
    }

    async getSubtasks(parentPath: string): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        
        const rows = await this.db.all<Record<string, unknown>[]>(
            'SELECT * FROM tasks WHERE parent_path = ?',
            parentPath
        );

        return rows.map(row => this.rowToTask(row));
    }

    async deleteTask(path: string): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.deleteTasks([path]);
    }

    async deleteTasks(paths: string[]): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        if (paths.length === 0) return;

        const placeholders = paths.map(() => '?').join(',');
        await this.db.run(
            `DELETE FROM tasks WHERE path IN (${placeholders})`,
            ...paths
        );
    }

    async hasChildren(path: string): Promise<boolean> {
        if (!this.db) throw new Error('Database not initialized');
        const result = await this.db.get<{ count: number }>(
            'SELECT COUNT(*) as count FROM tasks WHERE parent_path = ?',
            path
        );
        return (result?.count || 0) > 0;
    }

    async getDependentTasks(path: string): Promise<Task[]> {
        if (!this.db) throw new Error('Database not initialized');
        const rows = await this.db.all<Record<string, unknown>[]>(
            `SELECT * FROM tasks WHERE json_array_length(dependencies) > 0 
             AND json_extract(dependencies, '$') LIKE '%${path}%'`
        );
        return rows.map(row => this.rowToTask(row));
    }

    async saveTask(task: Task): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.saveTasks([task]);
    }

    async saveTasks(tasks: Task[]): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        for (const task of tasks) {
            await this.db.run(
                `INSERT OR REPLACE INTO tasks (
                    path, name, description, type, status,
                    parent_path, notes, reasoning, dependencies,
                    subtasks, metadata, created_at, updated_at, version
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                task.path,
                task.name,
                task.description,
                task.type,
                task.status,
                task.parentPath,
                task.notes ? JSON.stringify(task.notes) : null,
                task.reasoning,
                JSON.stringify(task.dependencies),
                JSON.stringify(task.subtasks),
                JSON.stringify(task.metadata),
                task.created,
                task.updated,
                task.version
            );
        }
    }

    async clearAllTasks(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.db.run('DELETE FROM tasks');
    }

    private rowToTask(row: Record<string, unknown>): Task {
        const metadata = this.parseJSON(String(row.metadata || '{}'), {});
        const now = Date.now();
        
        return {
            // System fields
            path: String(row.path || ''),
            name: String(row.name || ''),
            type: String(row.type || '') as Task['type'],
            status: String(row.status || '') as TaskStatus,
            created: Number(row.created_at || now),
            updated: Number(row.updated_at || now),
            version: Number(row.version || 1),
            projectPath: String(row.path || '').split('/')[0],

            // Optional fields
            description: row.description ? String(row.description) : undefined,
            parentPath: row.parent_path ? String(row.parent_path) : undefined,
            notes: this.parseJSON<string[]>(String(row.notes || '[]'), []),
            reasoning: row.reasoning ? String(row.reasoning) : undefined,
            dependencies: this.parseJSON<string[]>(String(row.dependencies || '[]'), []),
            subtasks: this.parseJSON<string[]>(String(row.subtasks || '[]'), []),
            
            // User metadata
            metadata
        };
    }

    private parseJSON<T>(value: string | null | undefined, defaultValue: T): T {
        if (!value) return defaultValue;
        try {
            return JSON.parse(value) as T;
        } catch {
            return defaultValue;
        }
    }

    async vacuum(): Promise<void> {
        if (!this.db || !this.transactionScope) throw new Error('Database not initialized');
        
        // Ensure no active transaction before vacuum
        await this.transactionScope.ensureNoTransaction();
        
        try {
            await this.db.run('VACUUM');
            this.logger.info('Database vacuum completed');
        } catch (error) {
            this.logger.error('Failed to vacuum database', { error });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to vacuum database',
                'vacuum',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    async analyze(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.db.run('ANALYZE');
    }

    async checkpoint(): Promise<void> {
        if (!this.db) throw new Error('Database not initialized');
        await this.db.run('PRAGMA wal_checkpoint(TRUNCATE)');
    }

    async repairRelationships(dryRun: boolean = false): Promise<{ fixed: number, issues: string[] }> {
        if (!this.db) throw new Error('Database not initialized');
        
        const issues: string[] = [];
        let fixed = 0;

        // Find tasks with invalid parent paths
        const orphanedTasks = await this.db.all<Record<string, unknown>[]>(
            `SELECT t1.path, t1.parent_path 
             FROM tasks t1 
             LEFT JOIN tasks t2 ON t1.parent_path = t2.path 
             WHERE t1.parent_path IS NOT NULL 
             AND t2.path IS NULL`
        );

        for (const task of orphanedTasks) {
            issues.push(`Task ${task.path} has invalid parent_path: ${task.parent_path}`);
            if (!dryRun) {
                await this.db.run(
                    'UPDATE tasks SET parent_path = NULL WHERE path = ?',
                    task.path
                );
                fixed++;
            }
        }

        return { fixed, issues };
    }

    async clearCache(): Promise<void> {
        // SQLite implementation doesn't use cache
        return;
    }

    /**
     * Verifies database integrity and repairs if needed
     */
    async verifyIntegrity(): Promise<boolean> {
        if (!this.db) throw new Error('Database not initialized');
        
        try {
            await this.beginTransaction();
            
            try {
                await this.analyze();
                await this.vacuum();
                await this.checkpoint();
                
                await this.commitTransaction();
                
                this.logger.info('SQLite integrity check passed');
                return true;
            } catch (error) {
                await this.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            this.logger.error('SQLite integrity check failed', {
                error: error instanceof Error ? error.message : String(error)
            });
            return false;
        }
    }

    /**
     * Gets detailed database statistics
     */
    async getStats(): Promise<{
        size: number;
        walSize: number;
        pageCount: number;
        pageSize: number;
        journalMode: string;
    }> {
        if (!this.db) throw new Error('Database not initialized');
        
        try {
            const metrics = await this.getMetrics();
            const fs = await import('fs/promises');
            
            const stats = await fs.stat(this.dbPath);
            const walPath = `${this.dbPath}-wal`;
            const walStats = await fs.stat(walPath).catch(() => ({ size: 0 }));

            const result = {
                size: stats.size,
                walSize: walStats.size,
                pageCount: metrics.storage.pageCount,
                pageSize: metrics.storage.pageSize,
                journalMode: 'WAL'
            };

            this.logger.debug('SQLite stats retrieved', { stats: result });
            return result;
        } catch (error) {
            this.logger.error('Failed to get SQLite stats', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }

    async getMetrics(): Promise<{
        tasks: {
            total: number;
            byStatus: Record<string, number>;
            noteCount: number;
            dependencyCount: number;
        };
        storage: {
            totalSize: number;
            pageSize: number;
            pageCount: number;
            walSize: number;
            cache: {
                hitRate: number;
                memoryUsage: number;
                entryCount: number;
            };
        };
    }> {
        if (!this.db) throw new Error('Database not initialized');

        const [taskStats, statusStats, storageStats] = await Promise.all([
            this.db.get<{
                total: number;
                noteCount: number;
                dependencyCount: number;
            }>(`
                SELECT 
                    COUNT(*) as total,
                    COUNT(CASE WHEN notes IS NOT NULL THEN 1 END) as noteCount,
                    SUM(CASE 
                        WHEN dependencies IS NOT NULL 
                        AND json_valid(dependencies) 
                        AND json_array_length(dependencies) > 0 
                        THEN json_array_length(dependencies) 
                        ELSE 0 
                    END) as dependencyCount
                FROM tasks
            `),
            this.db.all<{ status: string; count: number }[]>(`
                SELECT status, COUNT(*) as count
                FROM tasks
                GROUP BY status
            `),
            this.db.get<{
                page_count: number;
                page_size: number;
            }>(`
                SELECT 
                    page_count,
                    page_size
                FROM pragma_page_count, pragma_page_size
                LIMIT 1
            `)
        ]);

        // Convert status stats array to object
        const byStatus = statusStats.reduce((acc: Record<string, number>, curr) => {
            acc[curr.status] = curr.count;
            return acc;
        }, {});

        const totalSize = (storageStats?.page_count || 0) * (storageStats?.page_size || 0);
        const memUsage = process.memoryUsage();

        return {
            tasks: {
                total: Number(taskStats?.total || 0),
                byStatus,
                noteCount: Number(taskStats?.noteCount || 0),
                dependencyCount: Number(taskStats?.dependencyCount || 0)
            },
            storage: {
                totalSize,
                pageSize: Number(storageStats?.page_size || 0),
                pageCount: Number(storageStats?.page_count || 0),
                walSize: 0, // WAL size is dynamic
                cache: {
                    hitRate: 0, // SQLite implementation doesn't use cache
                    memoryUsage: memUsage.heapUsed,
                    entryCount: 0
                }
            }
        };
    }
}

================
File: storage/connection-manager.ts
================
/**
 * Database connection manager
 */
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';

export class ConnectionManager {
    private readonly logger: Logger;
    private readonly maxRetries: number;
    private readonly retryDelay: number;
    private readonly busyTimeout: number;

    constructor(options: {
        maxRetries?: number;
        retryDelay?: number;
        busyTimeout?: number;
    } = {}) {
        this.logger = Logger.getInstance().child({ component: 'ConnectionManager' });
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.busyTimeout = options.busyTimeout || 5000;
    }

    /**
     * Executes a database operation with retries
     */
    async executeWithRetry<T>(
        operation: () => Promise<T>,
        context: string
    ): Promise<T> {
        let lastError: Error | undefined;
        let retryCount = 0;

        while (retryCount < this.maxRetries) {
            try {
                const result = await operation();
                // Operation succeeded
                if (retryCount > 0) {
                    this.logger.info(`Operation succeeded after ${retryCount} retries`, {
                        context
                    });
                }
                return result;
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                retryCount++;

                // Log detailed error info
                const errorDetails = lastError instanceof Error ? {
                    name: lastError.name,
                    message: lastError.message,
                    code: (lastError as any).code,
                    errno: (lastError as any).errno
                } : lastError;

                this.logger.warn(`Operation failed${retryCount < this.maxRetries ? ', retrying' : ''}`, {
                    attempt: retryCount,
                    maxRetries: this.maxRetries,
                    error: errorDetails,
                    context
                });

                // Check if error is WAL-related
                const isWalError = lastError instanceof Error && 
                    (lastError.message.includes('WAL') || 
                     lastError.message.includes('journal_mode') ||
                     lastError.message.includes('Safety level'));

                if (retryCount < this.maxRetries) {
                    // Longer delay for WAL-related errors
                    const baseDelay = isWalError ? 1000 : this.retryDelay;
                    const delay = Math.min(
                        baseDelay * Math.pow(2, retryCount - 1) * (0.5 + Math.random()),
                        isWalError ? 10000 : 5000 // Higher cap for WAL errors
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // All retries failed
        throw createError(
            ErrorCodes.STORAGE_ERROR,
            'Operation failed',
            `Failed after ${this.maxRetries} retries: ${lastError?.message}`,
            lastError?.message
        );
    }

    /**
     * Handles database busy state
     */
    async handleBusy(
        operation: () => Promise<void>,
        context: string
    ): Promise<void> {
        const startTime = Date.now();

        while (true) {
            try {
                await operation();
                return;
            } catch (error) {
                const elapsed = Date.now() - startTime;
                if (elapsed >= this.busyTimeout) {
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Operation timed out',
                        `Timed out after ${elapsed}ms: ${error instanceof Error ? error.message : String(error)}`
                    );
                }

                this.logger.warn('Database busy, waiting...', {
                    elapsed,
                    timeout: this.busyTimeout,
                    context
                });

                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
}

================
File: storage/factory.ts
================
/**
 * Storage factory for creating task storage instances
 */
import { TaskStorage } from '../types/storage.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { 
    SqliteStorage,
    SqliteConfig,
    DEFAULT_PAGE_SIZE,
    DEFAULT_CACHE_SIZE,
    DEFAULT_BUSY_TIMEOUT
} from './sqlite/index.js';
import { ConfigManager } from '../config/index.js';
import { promises as fs } from 'fs';
import { Logger } from '../logging/index.js';

/**
 * Storage factory class for managing singleton storage instance
 */
class StorageFactory {
    private static instance: StorageFactory | null = null;
    private static initializationPromise: Promise<StorageFactory> | null = null;
    private storageInstance: TaskStorage | null = null;
    private static logger: Logger;

    private static initLogger(): void {
        if (!StorageFactory.logger) {
            StorageFactory.logger = Logger.getInstance().child({ component: 'StorageFactory' });
        }
    }

    private constructor() {
        StorageFactory.initLogger();
    }

    /**
     * Gets the StorageFactory instance
     */
    static async getInstance(): Promise<StorageFactory> {
        // Return existing instance if available
        if (StorageFactory.instance) {
            return StorageFactory.instance;
        }

        // If initialization is in progress, wait for it
        if (StorageFactory.initializationPromise) {
            return StorageFactory.initializationPromise;
        }

        // Start new initialization with mutex
        StorageFactory.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (StorageFactory.instance) {
                    return StorageFactory.instance;
                }

                StorageFactory.instance = new StorageFactory();
                return StorageFactory.instance;
            } catch (error) {
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    `Failed to initialize StorageFactory: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                StorageFactory.initializationPromise = null;
            }
        })();

        return StorageFactory.initializationPromise;
    }

    /**
     * Creates or returns the singleton storage instance
     */
    async createStorage(config: SqliteConfig): Promise<TaskStorage> {
        try {
            // Return existing instance if available
            if (this.storageInstance) {
                StorageFactory.logger.debug('Returning existing storage instance');
                return this.storageInstance;
            }

            StorageFactory.logger.info('Creating new storage instance', {
                baseDir: config.baseDir,
                name: config.name
            });

            // Ensure base directory exists with platform-appropriate permissions
            await fs.mkdir(config.baseDir, { 
                recursive: true, 
                mode: process.platform === 'win32' ? undefined : 0o755 
            });

            // Apply SQLite-specific defaults
            const sqliteConfig: SqliteConfig = {
                ...config,
                sqlite: {
                    journalMode: 'WAL',
                    synchronous: 'NORMAL',
                    tempStore: 'MEMORY',
                    lockingMode: 'NORMAL',
                    autoVacuum: 'NONE',
                    ...config.sqlite
                },
                performance: {
                    pageSize: DEFAULT_PAGE_SIZE,
                    cacheSize: DEFAULT_CACHE_SIZE,
                    ...config.performance
                },
                connection: {
                    busyTimeout: DEFAULT_BUSY_TIMEOUT,
                    ...config.connection
                }
            };

            // Create and initialize storage
            const storage = new SqliteStorage(sqliteConfig);
            await storage.initialize();
            
            // Only set singleton after successful initialization
            this.storageInstance = storage;
            StorageFactory.logger.info('Storage instance created successfully');
            return storage;
        } catch (error) {
            // Clear storage instance on error
            this.storageInstance = null;
            StorageFactory.logger.error('Failed to create storage instance', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to create storage',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Creates or returns the storage instance with default configuration
     */
    async createDefaultStorage(): Promise<TaskStorage> {
        try {
            // Return existing instance if available
            if (this.storageInstance) {
                StorageFactory.logger.debug('Returning existing default storage instance');
                return this.storageInstance;
            }

            const configManager = ConfigManager.getInstance();
            const config = configManager.getConfig();
            
            if (!config.storage) {
                throw new Error('Storage configuration not found in ConfigManager');
            }

            StorageFactory.logger.info('Creating default storage instance');
            return this.createStorage(config.storage as SqliteConfig);
        } catch (error) {
            StorageFactory.logger.error('Failed to create default storage', {
                error: error instanceof Error ? error.message : String(error)
            });
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to create default storage',
                error instanceof Error ? error.message : String(error)
            );
        }
    }
}

// Export factory instance creation functions
export async function createStorage(config: SqliteConfig): Promise<TaskStorage> {
    const factory = await StorageFactory.getInstance();
    return factory.createStorage(config);
}

export async function createDefaultStorage(): Promise<TaskStorage> {
    const factory = await StorageFactory.getInstance();
    return factory.createDefaultStorage();
}

================
File: storage/index.ts
================
/**
 * Storage module exports
 */
export { createStorage, createDefaultStorage } from './factory.js';
export { SqliteStorage } from './sqlite/index.js';

================
File: storage/sqlite-storage.ts
================
/**
 * SQLite storage implementation
 */
import { Database, open } from 'sqlite';
import { Task, TaskStatus, TaskType, CreateTaskInput, UpdateTaskInput } from '../types/task.js';
import { 
    StorageConfig, 
    TaskStorage, 
    StorageMetrics, 
    CacheStats
} from '../types/storage.js';
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { ConnectionManager } from './connection-manager.js';
import { globToSqlPattern } from '../utils/pattern-matcher.js';

interface TaskCacheEntry {
    task: Task;
    timestamp: number;
    hits: number;
}

export class SqliteStorage implements TaskStorage {
    private db: Database | null = null;
    private readonly logger: Logger;
    private readonly config: StorageConfig;
    private readonly connectionManager: ConnectionManager;
    private readonly cache: Map<string, TaskCacheEntry> = new Map();
    private readonly MAX_CACHE_SIZE = 1000;
    private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
    private cacheHits = 0;
    private cacheMisses = 0;

    constructor(config: StorageConfig) {
        this.config = config;
        this.logger = Logger.getInstance().child({ component: 'SqliteStorage' });
        this.connectionManager = new ConnectionManager(config.connection);
    }

    async initialize(): Promise<void> {
        const path = await import('path');
const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
        this.logger.info('Opening SQLite database', { 
            dbPath,
            baseDir: this.config.baseDir,
            name: this.config.name,
            fullPath: (await import('path')).resolve(dbPath)
        });

        try {
            // Import required modules
            const fs = await import('fs/promises');
            const path = await import('path');
            
            // Ensure storage directory exists and is writable
            const dirPath = path.dirname(dbPath);
            try {
                // Create directory with proper permissions
                await fs.mkdir(dirPath, { 
                    recursive: true, 
                    // Skip mode on Windows as it's ignored
                    ...(process.platform !== 'win32' && { mode: 0o755 })
                });

                // Verify directory is writable
                await fs.access(dirPath, fs.constants.W_OK);
                
                // Log directory contents
                const dirContents = await fs.readdir(dirPath);
                this.logger.info('Storage directory ready:', { 
                    path: dirPath,
                    contents: dirContents,
                    writable: true
                });
            } catch (err) {
                const error = err as NodeJS.ErrnoException;
                this.logger.error('Storage directory error', {
                    path: dirPath,
                    code: error.code,
                    errno: error.errno,
                    syscall: error.syscall
                });
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    'Storage directory not writable',
                    `Failed to access ${dirPath}: ${error.message}`
                );
            }

            // Import sqlite3 with verbose mode for better error messages
            const sqlite3 = await import('sqlite3');
            this.logger.info('SQLite3 module imported', {
                sqlite3: typeof sqlite3.default,
                modes: Object.keys(sqlite3.default)
            });

            // Initialize database with retry support
            await this.connectionManager.executeWithRetry(async () => {
                try {
                    // Open database with retry for locked files
                    await this.connectionManager.handleBusy(async () => {
                        this.db = await open({
                            filename: dbPath,
                            driver: sqlite3.default.Database,
                            mode: sqlite3.default.OPEN_READWRITE | sqlite3.default.OPEN_CREATE
                        });
                        this.logger.debug('Database opened successfully');
                    }, 'open_database');

                    return this.withDb(async (db) => {
                        // Set basic PRAGMAs first
                        await db.exec(`
                            PRAGMA busy_timeout=${this.config.connection?.busyTimeout || 5000};
                            PRAGMA temp_store=MEMORY;
                            PRAGMA foreign_keys=ON;
                            PRAGMA locking_mode=EXCLUSIVE;
                        `);

                        // Check and enable WAL mode with exclusive lock
                        await this.connectionManager.handleBusy(async () => {
                            const currentMode = await db.get<{value: string}>('PRAGMA journal_mode');
                            this.logger.info('Current journal mode:', { mode: currentMode?.value });

                            if (currentMode?.value !== 'wal') {
                                await db.exec(`
                                    PRAGMA locking_mode=EXCLUSIVE;
                                    PRAGMA journal_mode=WAL;
                                `);
                                const walMode = await db.get<{value: string}>('PRAGMA journal_mode');
                                if (walMode?.value !== 'wal') {
                                    this.logger.error('Failed to set WAL mode', {
                                        requested: 'wal',
                                        actual: walMode?.value,
                                        currentMode: currentMode?.value
                                    });
                                    throw new Error(`Failed to enable WAL mode: got ${walMode?.value}`);
                                }
                                this.logger.info('WAL mode enabled successfully');
                            } else {
                                this.logger.info('Database already in WAL mode');
                            }
                        }, 'enable_wal');

                        // Set other PRAGMAs after WAL mode is confirmed
                        await db.exec(`
                            PRAGMA synchronous=NORMAL;
                            PRAGMA wal_autocheckpoint=1000;
                            PRAGMA cache_size=${this.config.performance?.cacheSize || 2000};
                            PRAGMA mmap_size=${this.config.performance?.mmapSize || 30000000000};
                            PRAGMA page_size=${this.config.performance?.pageSize || 4096};
                        `);

                        // Create schema and set up database
                        await this.setupDatabase();

                        // Force a write to create WAL files
                        await db.exec(`
                            BEGIN IMMEDIATE;
                            CREATE TABLE IF NOT EXISTS _wal_test (id INTEGER PRIMARY KEY);
                            INSERT OR REPLACE INTO _wal_test (id) VALUES (1);
                            COMMIT;
                        `);

                        // Ensure WAL mode persisted after write
                        const journalMode = await db.get<{value: string}>('PRAGMA journal_mode');
                        this.logger.info('Journal mode confirmed:', { mode: journalMode?.value });

                        if (journalMode?.value !== 'wal') {
                            throw new Error('WAL mode not persisted after write');
                        }

                        // Log WAL status
                        const fs = await import('fs/promises');
                        const walPath = `${dbPath}-wal`;
                        const shmPath = `${dbPath}-shm`;
                        
                        try {
                            await Promise.all([
                                fs.access(walPath),
                                fs.access(shmPath)
                            ]);
                            this.logger.info('WAL files present', {
                                wal: walPath,
                                shm: shmPath
                            });
                        } catch (err) {
                            this.logger.warn('WAL files not immediately visible', {
                                error: err,
                                note: 'This may be normal if files are being created'
                            });
                        }

                        this.logger.info('SQLite storage initialized', { 
                            path: this.config.baseDir,
                            journalMode: journalMode?.value
                        });
                    });
                } catch (err) {
                    this.logger.error('Failed to initialize database', {
                        error: err instanceof Error ? {
                            name: err.name,
                            message: err.message,
                            stack: err.stack,
                            code: (err as any).code,
                            errno: (err as any).errno
                        } : err
                    });
                    throw err;
                }
            }, 'initialize');
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            const errorDetails = {
                error: error instanceof Error ? {
                    stack: error.stack,
                    ...error,
                    // Ensure custom properties don't get overwritten
                    customProps: Object.getOwnPropertyNames(error).reduce((acc, key) => {
                        if (key !== 'name' && key !== 'message' && key !== 'stack') {
                            acc[key] = (error as any)[key];
                        }
                        return acc;
                    }, {} as Record<string, unknown>)
                } : error,
                config: {
                    baseDir: this.config.baseDir,
                    name: this.config.name,
                    dbPath: `${this.config.baseDir}/${this.config.name}.db`
                }
            };
            
            this.logger.error('Failed to initialize SQLite storage', errorDetails);
            
            // Try to get more details about the SQLite error
            if (error instanceof Error && 'code' in error) {
                this.logger.error('SQLite error details', {
                    code: (error as any).code,
                    errno: (error as any).errno,
                    syscall: (error as any).syscall
                });
            }
            
            throw createError(
                ErrorCodes.STORAGE_INIT,
                'Failed to initialize SQLite storage',
                `${errorMessage} - Details: ${JSON.stringify(errorDetails, null, 2)}`
            );
        }
    }

    private async setupDatabase(): Promise<void> {
        return this.withDb(async (db) => {
            // Create tables and indexes
            await db.exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                    path TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    parent_path TEXT,
                    notes TEXT,
                    reasoning TEXT,
                    dependencies TEXT,
                    subtasks TEXT,
                    metadata TEXT,
                    created_at INTEGER NOT NULL,
                    updated_at INTEGER NOT NULL,
                    version INTEGER NOT NULL DEFAULT 1
                );

                CREATE INDEX IF NOT EXISTS idx_tasks_parent ON tasks(parent_path);
                CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
                CREATE INDEX IF NOT EXISTS idx_tasks_type ON tasks(type);
            `);

            // Set WAL file permissions if needed
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                const dbPath = path.join(this.config.baseDir, `${this.config.name}.db`);
                const walPath = `${dbPath}-wal`;
                const shmPath = `${dbPath}-shm`;
                
                // Set permissions for WAL and SHM files if they exist and not on Windows
                if (process.platform !== 'win32') {
                    await Promise.all([
                        fs.access(walPath).then(() => fs.chmod(walPath, 0o644)).catch(() => {}),
                        fs.access(shmPath).then(() => fs.chmod(shmPath, 0o644)).catch(() => {})
                    ]);
                }
            } catch (error) {
                this.logger.warn('Failed to set WAL file permissions', { error });
                // Don't throw - this is not critical
            }
        });
    }

    async createTask(input: CreateTaskInput): Promise<Task> {
        if (!input.name) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Task name is required',
                'createTask'
            );
        }

        // Generate path first
        const taskPath = input.path || input.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
        
        // Then create task with the generated path
        const now = Date.now();
        const projectPath = input.path?.split('/')[0] || taskPath.split('/')[0];
        
        const task: Task = {
            // System fields
            path: taskPath,
            name: input.name,
            type: input.type || TaskType.TASK,
            status: TaskStatus.PENDING,
            created: now,
            updated: now,
            version: 1,
            projectPath,

            // Optional fields
            description: input.description || undefined,
            parentPath: input.parentPath || undefined,
            notes: input.notes || [],
            reasoning: input.reasoning || undefined,
            dependencies: input.dependencies || [],
            subtasks: [],
            
            // User metadata
            metadata: input.metadata || {}
        };

        await this.saveTask(task);
        return task;
    }

    async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
        const existingTask = await this.getTask(path);
        if (!existingTask) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                'Task not found',
                'updateTask',
                path
            );
        }

        const now = Date.now();
        const updatedTask: Task = {
            ...existingTask,
            ...updates,
            // Update system fields
            updated: now,
            version: existingTask.version + 1,
            // Keep user metadata separate
            metadata: {
                ...existingTask.metadata,
                ...updates.metadata
            }
        };

        await this.saveTask(updatedTask);
        return updatedTask;
    }

    async hasChildren(path: string): Promise<boolean> {
        return this.withDb(async (db) => {
            const result = await db.get<{ count: number }>(
                'SELECT COUNT(*) as count FROM tasks WHERE parent_path = ?',
                path
            );
            return (result?.count || 0) > 0;
        });
    }

    async getDependentTasks(path: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            const rows = await db.all<Record<string, unknown>[]>(
                `SELECT * FROM tasks WHERE json_array_length(dependencies) > 0 
                 AND json_extract(dependencies, '$') LIKE '%${path}%'`
            );
            return rows.map(row => this.rowToTask(row));
        });
    }

    async saveTask(task: Task): Promise<void> {
        await this.saveTasks([task]);
    }

    private async withDb<T>(operation: (db: Database) => Promise<T>): Promise<T> {
        if (!this.db) {
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Database not initialized'
            );
        }
        return operation(this.db);
    }

    private transactionDepth = 0;

    private async inTransaction<T>(operation: () => Promise<T>): Promise<T> {
        return this.withDb(async (db) => {
            // If we're already in a transaction, just execute the operation
            if (this.transactionDepth > 0) {
                this.transactionDepth++;
                try {
                    return await operation();
                } finally {
                    this.transactionDepth--;
                }
            }

            // Start a new transaction
            this.transactionDepth = 1;
            try {
                await db.run('BEGIN IMMEDIATE');
                this.logger.debug('Started new transaction');
                
                const result = await operation();
                
                // Only commit if we haven't already committed
                if (this.transactionDepth === 1) {
                    await db.run('COMMIT');
                    this.logger.debug('Committed transaction');
                }
                
                return result;
            } catch (error) {
                // Only rollback if we haven't already rolled back
                if (this.transactionDepth === 1) {
                    try {
                        await db.run('ROLLBACK');
                        this.logger.debug('Rolled back transaction');
                    } catch (rollbackError) {
                        this.logger.error('Failed to rollback transaction', {
                            error: rollbackError,
                            originalError: error
                        });
                    }
                }
                throw error;
            } finally {
                this.transactionDepth = 0;
            }
        });
    }

    async saveTasks(tasks: Task[]): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {

                // First pass: collect all parent paths to load existing parents
                const parentPaths = new Set<string>();
                for (const task of tasks) {
                    if (task.parentPath) {
                        parentPaths.add(task.parentPath);
                    }
                }

                // Load existing parents
                const existingParents = new Map<string, Task>();
                if (parentPaths.size > 0) {
                    const placeholders = Array(parentPaths.size).fill('?').join(',');
                    const rows = await db.all<Record<string, unknown>[]>(
                        `SELECT * FROM tasks WHERE path IN (${placeholders})`,
                        Array.from(parentPaths)
                    );
                    for (const row of rows) {
                        const parent = this.rowToTask(row);
                        existingParents.set(parent.path, parent);
                    }
                }

                // Second pass: update parent-child relationships
                for (const task of tasks) {
                    if (task.parentPath) {
                        let parent = existingParents.get(task.parentPath);
                        if (parent) {
                            // Update parent's subtasks array if needed
                            if (!parent.subtasks.includes(task.path)) {
                                parent.subtasks = [...parent.subtasks, task.path];
                                existingParents.set(parent.path, parent);
                                tasks.push(parent); // Add parent to tasks to be saved
                            }
                        }
                    }
                }

                // Save all tasks with updated relationships
                for (const task of tasks) {
                    this.logger.info('Saving task:', { task });
                    await db.run(
                        `INSERT OR REPLACE INTO tasks (
                            path, name, description, type, status,
                            parent_path, notes, reasoning, dependencies,
                            subtasks, metadata, created_at, updated_at,
                            version
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                        task.path,
                        task.name,
                        task.description,
                        task.type,
                        task.status,
                        task.parentPath,
                        task.notes ? JSON.stringify(task.notes) : null,
                        task.reasoning,
                        JSON.stringify(task.dependencies),
                        JSON.stringify(task.subtasks),
                        JSON.stringify(task.metadata),
                        task.created,
                        task.updated,
                        task.version
                    );
                }
            });
        });
    }

    /**
     * Implements CacheManager.clearCache
     */
    async clearCache(): Promise<void> {
        this.cache.clear();
        this.cacheHits = 0;
        this.cacheMisses = 0;
        this.logger.debug('Cache cleared');
    }

    /**
     * Implements CacheManager.getCacheStats
     */
    async getCacheStats(): Promise<CacheStats> {
        const totalRequests = this.cacheHits + this.cacheMisses;
        return {
            size: this.cache.size,
            hits: this.cacheHits,
            misses: this.cacheMisses,
            hitRate: totalRequests > 0 ? this.cacheHits / totalRequests : 0,
            memoryUsage: process.memoryUsage().heapUsed
        };
    }

    /**
     * Gets a task from cache or database
     */
    async getTask(path: string): Promise<Task | null> {
        // Check cache first
        const cached = this.cache.get(path);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            cached.hits++;
            this.cacheHits++;
            return cached.task;
        }
        this.cacheMisses++;

        return this.withDb(async (db) => {
            try {
                const row = await db.get<Record<string, unknown>>(
                    'SELECT * FROM tasks WHERE path = ?',
                    path
                );

                if (!row) {
                    return null;
                }

                const task = this.rowToTask(row);
                
                // Add to cache with LRU eviction
                if (this.cache.size >= this.MAX_CACHE_SIZE) {
                    // Find least recently used entry
                    let oldestTime = Date.now();
                    let oldestKey = '';
                    for (const [key, entry] of this.cache.entries()) {
                        if (entry.timestamp < oldestTime) {
                            oldestTime = entry.timestamp;
                            oldestKey = key;
                        }
                    }
                    this.cache.delete(oldestKey);
                }
                
                this.cache.set(path, {
                    task,
                    timestamp: Date.now(),
                    hits: 1
                });

                return task;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get task', { error: errorMessage, path });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get task',
                    errorMessage
                );
            }
        });
    }

    async getTasks(paths: string[]): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                const placeholders = paths.map(() => '?').join(',');
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE path IN (${placeholders})`,
                    ...paths
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks', { error: errorMessage, paths });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks',
                    errorMessage
                );
            }
        });
    }

    async getTasksByPattern(pattern: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                // Convert glob pattern to SQL pattern
                const sqlPattern = globToSqlPattern(pattern);

                this.logger.debug('Converting glob pattern to SQL', {
                    original: pattern,
                    sql: sqlPattern
                });

                // Use both GLOB and LIKE for better pattern matching
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE 
                     path GLOB ? OR 
                     path LIKE ? OR
                     path LIKE ?`,
                    sqlPattern,
                    sqlPattern,
                    // Add recursive matching for **
                    pattern.includes('**') ? `${sqlPattern}/%` : sqlPattern
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks by pattern', { error: errorMessage, pattern });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks by pattern',
                    errorMessage
                );
            }
        });
    }

    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                const rows = await db.all<Record<string, unknown>[]>(
                    'SELECT * FROM tasks WHERE status = ?',
                    status
                );

                return rows.map(row => this.rowToTask(row));
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get tasks by status', { error: errorMessage, status });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get tasks by status',
                    errorMessage
                );
            }
        });
    }

    async getSubtasks(parentPath: string): Promise<Task[]> {
        return this.withDb(async (db) => {
            try {
                // Get the parent task first
                const parent = await this.getTask(parentPath);
                if (!parent) {
                    return [];
                }

                // Get all tasks that have this parent path
                const rows = await db.all<Record<string, unknown>[]>(
                    `SELECT * FROM tasks WHERE parent_path = ?`,
                    parentPath
                );

                // Convert rows to tasks
                const tasks = rows.map(row => this.rowToTask(row));

                // Ensure consistency - update any tasks that have this parent
                // but aren't in the parent's subtasks array
                const needsUpdate = tasks.some(task => 
                    task.parentPath === parentPath && !parent.subtasks.includes(task.path)
                );

                if (needsUpdate) {
                    parent.subtasks = Array.from(new Set([
                        ...parent.subtasks,
                        ...tasks.filter(t => t.parentPath === parentPath).map(t => t.path)
                    ]));
                    await this.saveTask(parent);
                }

                return tasks;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get subtasks', { error: errorMessage, parentPath });
                throw createError(
                    ErrorCodes.STORAGE_READ,
                    'Failed to get subtasks',
                    errorMessage
                );
            }
        });
    }

    async deleteTask(path: string): Promise<void> {
        await this.deleteTasks([path]);
    }

    async deleteTasks(paths: string[]): Promise<void> {
        await this.inTransaction(async () => {
            return this.withDb(async (db) => {
                // Get all tasks that need to be deleted using recursive CTE
                const placeholders = paths.map(() => '?').join(',');
                const rows = await db.all<Record<string, unknown>[]>(
                    `WITH RECURSIVE task_tree AS (
                        -- Base case: tasks with paths in the input list
                        SELECT path, parent_path, json_extract(subtasks, '$') as subtasks
                        FROM tasks 
                        WHERE path IN (${placeholders})
                        
                        UNION ALL
                        
                        -- Recursive case 1: tasks with parent_path matching any task in tree
                        SELECT t.path, t.parent_path, json_extract(t.subtasks, '$')
                        FROM tasks t
                        JOIN task_tree tt ON t.parent_path = tt.path
                        
                        UNION ALL
                        
                        -- Recursive case 2: tasks listed in subtasks array of any task in tree
                        SELECT t.path, t.parent_path, json_extract(t.subtasks, '$')
                        FROM tasks t
                        JOIN task_tree tt ON json_each.value = t.path
                        JOIN json_each(tt.subtasks)
                    )
                    SELECT DISTINCT path FROM task_tree`,
                    ...paths
                );

                const allPaths = rows.map(row => String(row.path));
                this.logger.debug('Found tasks to delete', { 
                    inputPaths: paths,
                    foundPaths: allPaths 
                });

                // Get all tasks before deletion for proper cleanup
                const tasksToDelete = await Promise.all(
                    allPaths.map(path => this.getTask(path))
                );
                const validTasksToDelete = tasksToDelete.filter((t): t is Task => t !== null);

                // Find all parent paths that need updating
                const parentsToUpdate = new Set(
                    validTasksToDelete
                        .filter(t => t.parentPath)
                        .map(t => t.parentPath as string)
                );

                // Update parent tasks' subtasks arrays
                for (const parentPath of parentsToUpdate) {
                    const parent = await this.getTask(parentPath);
                    if (parent && !allPaths.includes(parent.path)) {
                        parent.subtasks = parent.subtasks.filter(p => !allPaths.includes(p));
                        await this.saveTask(parent);
                    }
                }

                // Delete all tasks and their descendants
                if (allPaths.length > 0) {
                    const deletePlaceholders = allPaths.map(() => '?').join(',');
                    await db.run(
                        `DELETE FROM tasks WHERE path IN (${deletePlaceholders})`,
                        ...allPaths
                    );
                }

                this.logger.debug('Tasks deleted with descendants', {
                    inputPaths: paths,
                    deletedPaths: allPaths
                });
            });
        });
    }

    async vacuum(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('VACUUM');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to vacuum database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to vacuum database',
                    errorMessage
                );
            }
        });
    }

    async analyze(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('ANALYZE');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to analyze database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to analyze database',
                    errorMessage
                );
            }
        });
    }

    async checkpoint(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                await db.run('PRAGMA wal_checkpoint(TRUNCATE)');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to checkpoint database', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to checkpoint database',
                    errorMessage
                );
            }
        });
    }

    async getMetrics(): Promise<StorageMetrics & {
        cache?: CacheStats;
        memory?: {
            heapUsed: number;
            heapTotal: number;
            rss: number;
        };
    }> {
        return this.withDb(async (db) => {
            try {
                interface TaskStats {
                    total: number;
                    noteCount: number;
                    dependencyCount: number;
                }

                const [taskStats, statusStats, storageStats] = await Promise.all([
                    db.get<TaskStats>(`
                        SELECT 
                            COUNT(*) as total,
                            COUNT(CASE WHEN notes IS NOT NULL THEN 1 END) as noteCount,
                            SUM(CASE 
                                WHEN dependencies IS NOT NULL 
                                AND json_valid(dependencies) 
                                AND json_array_length(dependencies) > 0 
                                THEN json_array_length(dependencies) 
                                ELSE 0 
                            END) as dependencyCount
                        FROM tasks
                    `),
                    db.all(`
                        SELECT status, COUNT(*) as count
                        FROM tasks
                        GROUP BY status
                    `),
                    db.get<Record<string, unknown>>(`
                        SELECT 
                            page_count * page_size as totalSize,
                            page_size,
                            page_count,
                            0 as wal_size
                        FROM pragma_page_count, pragma_page_size LIMIT 1
                    `)
                ]);

                const memUsage = process.memoryUsage();
                const cacheStats = await this.getCacheStats();

                // Convert status stats array to object
                const byStatus = (statusStats as { status: string; count: number }[]).reduce((acc: Record<string, number>, curr) => {
                    acc[curr.status] = curr.count;
                    return acc;
                }, {});

                return {
                    tasks: {
                        total: Number(taskStats?.total || 0),
                        byStatus,
                        noteCount: Number(taskStats?.noteCount || 0),
                        dependencyCount: Number(taskStats?.dependencyCount || 0)
                    },
                    storage: {
                        totalSize: Number(storageStats?.totalSize || 0),
                        pageSize: Number(storageStats?.page_size || 0),
                        pageCount: Number(storageStats?.page_count || 0),
                        walSize: Number(storageStats?.wal_size || 0),
                        cache: {
                            hitRate: cacheStats.hitRate,
                            memoryUsage: cacheStats.memoryUsage,
                            entryCount: this.cache.size
                        }
                    },
                    cache: cacheStats,
                    memory: {
                        heapUsed: memUsage.heapUsed,
                        heapTotal: memUsage.heapTotal,
                        rss: memUsage.rss
                    }
                };
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to get storage metrics', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to get storage metrics',
                    errorMessage
                );
            }
        });
    }

    private parseJSON<T>(value: string | null | undefined, defaultValue: T): T {
        if (!value) return defaultValue;
        try {
            return JSON.parse(value) as T;
        } catch {
            return defaultValue;
        }
    }

    private rowToTask(row: Record<string, unknown>): Task {
        const metadata = this.parseJSON(String(row.metadata || '{}'), {});
        const now = Date.now();
        
        return {
            // System fields
            path: String(row.path || ''),
            name: String(row.name || ''),
            type: String(row.type || '') as Task['type'],
            status: String(row.status || '') as Task['status'],
            created: Number(row.created_at || now),
            updated: Number(row.updated_at || now),
            version: Number(row.version || 1),
            projectPath: String(row.path || '').split('/')[0],

            // Optional fields
            description: row.description ? String(row.description) : undefined,
            parentPath: row.parent_path ? String(row.parent_path) : undefined,
            notes: this.parseJSON<string[]>(String(row.notes || '[]'), []),
            reasoning: row.reasoning ? String(row.reasoning) : undefined,
            dependencies: this.parseJSON<string[]>(String(row.dependencies || '[]'), []),
            subtasks: this.parseJSON<string[]>(String(row.subtasks || '[]'), []),
            
            // User metadata
            metadata
        };
    }

    /**
     * Clears all tasks from the database and recreates tables
     */
    async clearAllTasks(): Promise<void> {
        return this.withDb(async (db) => {
            try {
                // Drop existing tables
                await db.run('DROP TABLE IF EXISTS tasks');
                
                // Clear cache and indexes
                await this.clearCache();
                
                // Recreate tables
                await this.setupDatabase();
                
                // Vacuum database outside of transaction
                await db.run('VACUUM');
                
                // Analyze the new empty tables
                await db.run('ANALYZE');
                
                // Checkpoint WAL
                await db.run('PRAGMA wal_checkpoint(TRUNCATE)');
                
                this.logger.info('Database reset: tables dropped, recreated, and optimized');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to clear tasks', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to clear tasks',
                    errorMessage
                );
            }
        });
    }

    /**
     * Repairs parent-child relationships
     */
    async repairRelationships(dryRun: boolean = false): Promise<{ fixed: number, issues: string[] }> {
        return this.inTransaction(async () => {
            return this.withDb(async (db) => {
                const issues: string[] = [];
                let fixCount = 0;

                try {
                    // Find tasks with invalid parent paths
                    const orphanedTasks = await db.all<Record<string, unknown>[]>(
                        `SELECT t1.path, t1.parent_path 
                         FROM tasks t1 
                         LEFT JOIN tasks t2 ON t1.parent_path = t2.path 
                         WHERE t1.parent_path IS NOT NULL 
                         AND t2.path IS NULL`
                    );

                    for (const task of orphanedTasks) {
                        issues.push(`Task ${task.path} has invalid parent_path: ${task.parent_path}`);
                        if (!dryRun) {
                            await db.run(
                                'UPDATE tasks SET parent_path = NULL WHERE path = ?',
                                task.path
                            );
                            fixCount++;
                        }
                    }

                    // Find inconsistencies between parent_path and subtasks
                    const rows = await db.all<Record<string, unknown>[]>(
                        'SELECT * FROM tasks WHERE parent_path IS NOT NULL OR subtasks IS NOT NULL'
                    );

                    for (const row of rows) {
                        const task = this.rowToTask(row);
                        const subtaskRefs = new Set(task.subtasks);
                        
                        // Check if all subtasks exist and reference this task as parent
                        if (subtaskRefs.size > 0) {
                            const subtasks = await db.all<Record<string, unknown>[]>(
                                `SELECT * FROM tasks WHERE path IN (${Array(subtaskRefs.size).fill('?').join(',')})`,
                                ...Array.from(subtaskRefs)
                            );

                            for (const subtask of subtasks.map(r => this.rowToTask(r))) {
                                if (subtask.parentPath !== task.path) {
                                    issues.push(`Task ${task.path} lists ${subtask.path} as subtask but parent_path mismatch`);
                                    if (!dryRun) {
                                        subtask.parentPath = task.path;
                                        await this.saveTask(subtask);
                                        fixCount++;
                                    }
                                }
                            }
                        }
                    }

                    return { fixed: fixCount, issues };
                } catch (error) {
                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                    this.logger.error('Failed to repair relationships', { error: errorMessage });
                    throw createError(
                        ErrorCodes.STORAGE_ERROR,
                        'Failed to repair relationships',
                        errorMessage
                    );
                }
            });
        });
    }

    /**
     * Begins a new transaction
     */
    async beginTransaction(): Promise<void> {
        if (this.transactionDepth > 0) {
            this.transactionDepth++;
            this.logger.debug('Nested transaction started', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('BEGIN IMMEDIATE');
                this.transactionDepth = 1;
                this.logger.debug('Transaction started');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to begin transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to begin transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Commits the current transaction
     */
    async commitTransaction(): Promise<void> {
        if (this.transactionDepth > 1) {
            this.transactionDepth--;
            this.logger.debug('Nested transaction committed', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('COMMIT');
                this.transactionDepth = 0;
                this.logger.debug('Transaction committed');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to commit transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to commit transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Rolls back the current transaction
     */
    async rollbackTransaction(): Promise<void> {
        if (this.transactionDepth > 1) {
            this.transactionDepth--;
            this.logger.debug('Nested transaction rolled back', { depth: this.transactionDepth });
            return;
        }

        return this.withDb(async (db) => {
            try {
                await db.run('ROLLBACK');
                this.transactionDepth = 0;
                this.logger.debug('Transaction rolled back');
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error('Failed to rollback transaction', { error: errorMessage });
                throw createError(
                    ErrorCodes.STORAGE_ERROR,
                    'Failed to rollback transaction',
                    errorMessage
                );
            }
        });
    }

    /**
     * Closes the database connection and cleans up resources
     */
    async close(): Promise<void> {
        try {
            await this.clearCache();
            if (this.db) {
                await this.db.close();
                this.db = null;
                this.logger.info('Database connection closed');
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error('Failed to close database', { error: errorMessage });
            throw createError(
                ErrorCodes.STORAGE_ERROR,
                'Failed to close database',
                errorMessage
            );
        }
    }
}

================
File: task/core/batch/common/batch-utils.ts
================
import { Task } from '../../../../types/task.js';

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export interface BatchData<T = unknown> {
  id: string;
  data: T;
  [key: string]: unknown;
}

export interface TaskBatchData extends BatchData<Task> {
  data: Task;
}

export interface BatchResult<T> {
  results: T[];
  errors: Error[];
  metadata?: {
    processingTime: number;
    successCount: number;
    errorCount: number;
  };
}

export class BatchUtils {
  static validateBatch(batch: BatchData[]): ValidationResult {
    const errors: string[] = [];
    
    if (!Array.isArray(batch)) {
      errors.push('Batch must be an array');
      return { valid: false, errors };
    }

    if (batch.length === 0) {
      errors.push('Batch cannot be empty');
      return { valid: false, errors };
    }

    // Validate each item in the batch
    batch.forEach((item, index) => {
      if (!item.id) {
        errors.push(`Item at index ${index} is missing required 'id' field`);
      }
      if (!item.data) {
        errors.push(`Item at index ${index} is missing required 'data' field`);
      }
    });

    return {
      valid: errors.length === 0,
      errors
    };
  }

  static async processBatch<T>(
    batch: BatchData[],
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();
    
    for (const item of batch) {
      try {
        const result = await processor(item);
        results.push(result);
      } catch (error) {
        errors.push(error as Error);
      }
    }

    const endTime = Date.now();
    
    return {
      results,
      errors,
      metadata: {
        processingTime: endTime - startTime,
        successCount: results.length,
        errorCount: errors.length
      }
    };
  }

  static async retryFailedItems<T>(
    failedItems: BatchData[],
    processor: (item: BatchData) => Promise<T>,
    maxRetries: number = 3,
    delayMs: number = 1000
  ): Promise<BatchResult<T>> {
    let currentRetry = 0;
    let itemsToRetry = [...failedItems];
    const results: T[] = [];
    const errors: Error[] = [];

    while (currentRetry < maxRetries && itemsToRetry.length > 0) {
      // Wait before retry
      if (currentRetry > 0) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }

      const retryResult = await this.processBatch(itemsToRetry, processor);
      
      // Add successful results
      results.push(...retryResult.results);
      
      // Update items to retry
      itemsToRetry = itemsToRetry.filter((_, index) => 
        retryResult.errors[index] !== undefined
      );

      if (currentRetry === maxRetries - 1) {
        // On last attempt, add remaining errors
        errors.push(...retryResult.errors);
      }

      currentRetry++;
    }

    return {
      results,
      errors,
      metadata: {
        processingTime: 0, // Not tracking total time for retries
        successCount: results.length,
        errorCount: errors.length
      }
    };
  }

  static splitBatchBySize<T extends BatchData>(
    batch: T[],
    maxBatchSize: number
  ): T[][] {
    if (maxBatchSize <= 0) {
      throw new Error('maxBatchSize must be greater than 0');
    }

    const batches: T[][] = [];
    for (let i = 0; i < batch.length; i += maxBatchSize) {
      batches.push(batch.slice(i, i + maxBatchSize));
    }

    return batches;
  }
}

================
File: task/core/batch/base-batch-processor.ts
================
import { Logger } from '../../../logging/index.js';
import { BatchData, BatchResult, ValidationResult } from './common/batch-utils.js';

export interface BatchDependencies {
  validator: any;
  logger: Logger;
  storage: any;
}

export interface BatchOptions {
  maxBatchSize?: number;
  maxRetries?: number;
  retryDelay?: number;
  timeout?: number;
  validateBeforeProcess?: boolean;
  concurrentBatches?: number;
}

export abstract class BaseBatchProcessor<T = unknown> {
  protected readonly logger: Logger;
  protected readonly defaultOptions: Required<BatchOptions> = {
    maxBatchSize: 100,
    maxRetries: 3,
    retryDelay: 1000,
    timeout: 30000,
    validateBeforeProcess: true,
    concurrentBatches: 1
  };

  private activeTimeouts: Set<NodeJS.Timeout> = new Set();
  private activeBatches: Map<string, { 
    startTime: number;
    results: WeakRef<any[]>;
  }> = new Map();
  private isShuttingDown = false;
  private cleanupInterval?: NodeJS.Timeout;
  private readonly CLEANUP_INTERVAL = 300000; // 5 minutes
  private readonly BATCH_RESULT_TTL = 600000; // 10 minutes
  private readonly MEMORY_CHECK_INTERVAL = 60000; // 1 minute
  private readonly HEAP_THRESHOLD = 0.9; // 90% heap usage threshold
  private memoryCheckInterval?: NodeJS.Timeout;

  constructor(
    protected readonly dependencies: BatchDependencies,
    protected readonly options: BatchOptions = {}
  ) {
    this.logger = Logger.getInstance().child({ 
      component: this.constructor.name 
    });
    this.options = { ...this.defaultOptions, ...options };

    // Start monitoring and cleanup
    this.startMemoryMonitoring();
    this.startPeriodicCleanup();
    
    // Log initial memory state
    this.logMemoryUsage('Initialization');
  }

  /**
   * Main execution method that orchestrates the batch processing flow
   */
  async execute(batch: BatchData[]): Promise<BatchResult<T>> {
    if (this.isShuttingDown) {
      throw new Error('Batch processor is shutting down');
    }

    const batchId = `batch-${Date.now()}-${Math.random()}`;
    this.activeBatches.set(batchId, {
      startTime: Date.now(),
      results: new WeakRef([])
    });

    try {
      // Validate batch if enabled
      if (this.options.validateBeforeProcess) {
        const validation = await this.validate(batch);
        if (!validation.valid) {
          throw new Error(`Batch validation failed: ${validation.errors.join(', ')}`);
        }
      }

      // Set up timeout if specified
      let timeoutId: NodeJS.Timeout | undefined;
      const timeoutPromise = new Promise<never>((_, reject) => {
        if (this.options.timeout) {
          timeoutId = setTimeout(() => {
            reject(new Error(`Batch processing timed out after ${this.options.timeout}ms`));
          }, this.options.timeout);
          this.activeTimeouts.add(timeoutId);
        }
      });

      // Process the batch with timeout
      const processResult = await Promise.race([
        this.process(batch),
        timeoutPromise
      ]);

      // Clear timeout if it was set
      if (timeoutId) {
        clearTimeout(timeoutId);
        this.activeTimeouts.delete(timeoutId);
      }

      // Store results with WeakRef for memory management
      const batchInfo = this.activeBatches.get(batchId);
      if (batchInfo) {
        batchInfo.results = new WeakRef(processResult.results);
      }

      // Log metrics
      this.logMetrics(processResult);

      return processResult;
    } catch (error) {
      this.logger.error('Batch processing failed', { error });
      throw error;
    } finally {
      this.activeBatches.delete(batchId);
    }
  }

  /**
   * Process items in batches with configurable concurrency
   */
  public async processInBatches(
    items: BatchData[],
    batchSize: number,
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    const batches = this.createBatches(items, batchSize);
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    try {
      const concurrentBatches = this.options.concurrentBatches || 1;
      for (let i = 0; i < batches.length; i += concurrentBatches) {
        const batchPromises = batches
          .slice(i, i + concurrentBatches)
          .map(batch => this.processBatch(batch, processor));

        const batchResults = await Promise.all(batchPromises);
        
        for (const result of batchResults) {
          results.push(...result.results);
          errors.push(...result.errors);
        }
      }

      const endTime = Date.now();
      return {
        results,
        errors,
        metadata: {
          processingTime: endTime - startTime,
          successCount: results.length,
          errorCount: errors.length
        }
      };
    } catch (error) {
      this.logger.error('Batch processing failed', { error });
      throw error;
    }
  }

  /**
   * Abstract method for batch validation
   * Must be implemented by concrete classes
   */
  protected abstract validate(batch: BatchData[]): Promise<ValidationResult>;

  /**
   * Abstract method for batch processing
   * Must be implemented by concrete classes
   */
  protected abstract process(batch: BatchData[]): Promise<BatchResult<T>>;

  /**
   * Helper method to split items into batches
   */
  protected createBatches(items: BatchData[], batchSize: number): BatchData[][] {
    const batches: BatchData[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * Helper method to process a single batch
   */
  protected async processBatch(
    batch: BatchData[],
    processor: (item: BatchData) => Promise<T>
  ): Promise<BatchResult<T>> {
    if (this.isShuttingDown) {
      throw new Error('Batch processor is shutting down');
    }

    const batchId = `sub-batch-${Date.now()}-${Math.random()}`;
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    // Track this sub-batch
    this.activeBatches.set(batchId, {
      startTime,
      results: new WeakRef([])
    });

    try {
      for (const item of batch) {
        try {
          const result = await this.withRetry(
            () => processor(item),
            `Processing item ${item.id}`
          );
          results.push(result);
        } catch (error) {
          errors.push(error as Error);
          this.logger.error('Failed to process batch item', {
            error,
            itemId: item.id
          });
        }
      }

      const endTime = Date.now();
      const batchResult = {
        results,
        errors,
        metadata: {
          processingTime: endTime - startTime,
          successCount: results.length,
          errorCount: errors.length,
          batchId
        }
      };

      // Update batch results reference
      const batchInfo = this.activeBatches.get(batchId);
      if (batchInfo) {
        batchInfo.results = new WeakRef(results);
      }

      return batchResult;
    } finally {
      // Clean up batch tracking after processing
      this.activeBatches.delete(batchId);
    }
  }

  /**
   * Helper method to handle retries
   */
  protected async withRetry<R>(
    operation: () => Promise<R>,
    context: string
  ): Promise<R> {
    const maxRetries = this.options.maxRetries || this.defaultOptions.maxRetries;
    const delay = this.options.retryDelay || this.defaultOptions.retryDelay;
    let lastError: Error | undefined;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        this.logger.warn(`${context} failed, attempt ${attempt}/${maxRetries}`, { 
          error,
          attempt,
          maxRetries 
        });

        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  /**
   * Helper method to log batch processing metrics
   */
  protected logMetrics(result: BatchResult<T>): void {
    this.logger.info('Batch processing completed', {
      processingTime: result.metadata?.processingTime,
      successCount: result.metadata?.successCount,
      errorCount: result.metadata?.errorCount,
      totalItems: result.results.length + result.errors.length
    });
  }

  /**
   * Cleanup resources and prepare for shutdown
   */
  private startMemoryMonitoring(): void {
    // Monitor memory usage periodically
    this.memoryCheckInterval = setInterval(() => {
      const memoryUsage = process.memoryUsage();
      const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;

      this.logger.debug('Memory usage', {
        heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
        heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
        rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
        external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
        arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`
      });

      if (heapUsed > this.HEAP_THRESHOLD) {
        this.logger.warn('High memory usage detected', {
          heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
          activeTimeouts: this.activeTimeouts.size,
          activeBatches: this.activeBatches.size
        });
        
        // Force cleanup when memory pressure is high
        this.cleanupExpiredBatches(true);
        
        // Force GC if available
        if (global.gc) {
          this.logger.info('Forcing garbage collection');
          global.gc();
        }
      }
    }, this.MEMORY_CHECK_INTERVAL);

    // Ensure cleanup on process exit
    process.once('beforeExit', () => {
      if (this.memoryCheckInterval) {
        clearInterval(this.memoryCheckInterval);
        this.memoryCheckInterval = undefined;
      }
    });
  }

  private startPeriodicCleanup(): void {
    // More frequent cleanup interval
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredBatches();
    }, this.CLEANUP_INTERVAL);

    // Ensure cleanup interval is cleared on process exit
    process.once('beforeExit', () => {
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = undefined;
      }
    });
  }

  private cleanupExpiredBatches(force: boolean = false): void {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [batchId, batchInfo] of this.activeBatches.entries()) {
      // Clean up batches that have expired or force cleanup
      if (force || now - batchInfo.startTime > this.BATCH_RESULT_TTL) {
        this.activeBatches.delete(batchId);
        cleanedCount++;
        continue;
      }

      // Clean up batches whose results have been garbage collected
      const results = batchInfo.results.deref();
      if (!results) {
        this.activeBatches.delete(batchId);
        cleanedCount++;
      }
    }

    // Always log cleanup metrics
    this.logger.debug('Batch cleanup completed', {
      cleanedCount,
      remainingBatches: this.activeBatches.size,
      forced: force,
      memoryUsage: this.getMemoryMetrics()
    });
  }

  private getMemoryMetrics(): Record<string, string> {
    const memoryUsage = process.memoryUsage();
    return {
      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
      external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
      arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
      heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
    };
  }

  private logMemoryUsage(context: string): void {
    this.logger.info(`Memory usage - ${context}`, this.getMemoryMetrics());
  }

  async cleanup(): Promise<void> {
    this.isShuttingDown = true;
    this.logMemoryUsage('Cleanup start');

    // Stop all monitoring and cleanup intervals
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = undefined;
    }

    if (this.memoryCheckInterval) {
      clearInterval(this.memoryCheckInterval);
      this.memoryCheckInterval = undefined;
    }

    // Clear all timeouts
    for (const timeout of this.activeTimeouts) {
      clearTimeout(timeout);
    }
    this.activeTimeouts.clear();

    // Wait for active batches to complete with timeout
    if (this.activeBatches.size > 0) {
      this.logger.info('Waiting for active batches to complete', {
        count: this.activeBatches.size
      });

      const timeout = 5000;
      const startTime = Date.now();
      
      while (this.activeBatches.size > 0 && Date.now() - startTime < timeout) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      if (this.activeBatches.size > 0) {
        this.logger.warn('Some batches did not complete before timeout', {
          remainingBatches: this.activeBatches.size
        });
      }
    }

    // Force final cleanup
    this.cleanupExpiredBatches(true);
    this.activeBatches.clear();
    
    // Force garbage collection
    if (global.gc) {
      this.logger.info('Forcing final garbage collection');
      global.gc();
    }

    this.logMemoryUsage('Cleanup end');
    this.logger.info('Batch processor cleanup completed', {
      finalMetrics: {
        activeTimeouts: this.activeTimeouts.size,
        activeBatches: this.activeBatches.size,
        ...this.getMemoryMetrics()
      }
    });
  }
}

================
File: task/core/batch/dependency-aware-batch-processor.ts
================
import { Task, TaskStatus } from '../../../types/task.js';
import { BatchData, BatchResult, ValidationResult } from './common/batch-utils.js';
import { BaseBatchProcessor, BatchDependencies, BatchOptions } from './base-batch-processor.js';
import { detectDependencyCycle } from '../../validation/index.js';

interface TaskBatchData extends BatchData {
  task: Task;
  dependencies: string[];
}

export class DependencyAwareBatchProcessor extends BaseBatchProcessor {
  private dependencyGraph: Record<string, Set<string>> = {};

  constructor(
    dependencies: BatchDependencies,
    options: BatchOptions = {}
  ) {
    super(dependencies, {
      ...options,
      validateBeforeProcess: true // Always validate dependencies
    });
  }

  protected async validate(batch: BatchData[]): Promise<ValidationResult> {
    const errors: string[] = [];
    const tasks = batch as TaskBatchData[];

    try {
      // Clear any stale cache entries before validation
      if ('clearCache' in this.dependencies.storage) {
        await (this.dependencies.storage as any).clearCache();
      }

      // Build dependency graph
      this.buildDependencyGraph(tasks);

      // First pass: validate task existence and basic structure
      for (const task of tasks) {
        const existingTask = await this.dependencies.storage.getTask(task.task.path);
        if (!existingTask) {
          errors.push(`Task ${task.task.path} not found`);
          continue;
        }

        // Validate task matches stored version
        if (existingTask.metadata.version !== task.task.metadata.version) {
          errors.push(`Task ${task.task.path} has been modified by another process`);
          continue;
        }
      }

      // Check for circular dependencies using shared validation
      for (const taskData of tasks) {
        try {
          const hasCycle = await detectDependencyCycle(
            taskData.task,
            taskData.dependencies,
            this.dependencies.storage.getTask.bind(this.dependencies.storage)
          );
          if (hasCycle) {
            errors.push(`Circular dependency detected for task ${taskData.task.path}`);
          }
        } catch (error) {
          if (error instanceof Error) {
            errors.push(error.message);
          } else {
            errors.push('Unknown error checking dependencies');
          }
        }
      }

      // Validate each task's dependencies exist
      for (const task of tasks) {
        const missingDeps = await this.findMissingDependencies(task);
        if (missingDeps.length > 0) {
          errors.push(`Task ${task.id} has missing dependencies: ${missingDeps.join(', ')}`);
        }
      }

      // Validate dependency status
      for (const task of tasks) {
        const blockedDeps = await this.findBlockedDependencies(task);
        if (blockedDeps.length > 0) {
          errors.push(
            `Task ${task.id} has blocked dependencies: ${blockedDeps.join(', ')}`
          );
        }
      }

      return {
        valid: errors.length === 0,
        errors
      };
    } catch (error) {
      this.logger.error('Dependency validation failed', { error });
      errors.push(`Validation error: ${(error as Error).message}`);
      return { valid: false, errors };
    }
  }

  protected async process<T>(batch: BatchData[]): Promise<BatchResult<T>> {
    const tasks = batch as TaskBatchData[];
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    try {
      // Process tasks in dependency order
      const processingOrder = this.getProcessingOrder();
      
      for (const taskId of processingOrder) {
        const task = tasks.find(t => t.id === taskId);
        if (!task) continue;

        try {
          // Process the task
          const result = await this.withRetry(
            async () => this.processTask(task),
            `Processing task ${task.id}`
          );
          
          results.push(result as T);
          
          this.logger.debug('Task processed successfully', {
            taskId: task.id,
            dependencies: task.dependencies
          });
        } catch (error) {
          this.logger.error('Failed to process task', {
            error,
            taskId: task.id
          });
          errors.push(error as Error);
        }
      }

      const endTime = Date.now();
      const result: BatchResult<T> = {
        results,
        errors,
        metadata: {
          processingTime: endTime - startTime,
          successCount: results.length,
          errorCount: errors.length
        }
      };

      this.logMetrics(result);
      return result;
    } catch (error) {
      this.logger.error('Batch processing failed', { error });
      throw error;
    } finally {
      // Clear dependency graph
      this.dependencyGraph = {};
    }
  }

  private buildDependencyGraph(tasks: TaskBatchData[]): void {
    this.dependencyGraph = {};
    
    for (const task of tasks) {
      if (!this.dependencyGraph[task.id]) {
        this.dependencyGraph[task.id] = new Set();
      }
      
      for (const dep of task.dependencies) {
        this.dependencyGraph[task.id].add(dep);
      }
    }
  }

  private async findMissingDependencies(task: TaskBatchData): Promise<string[]> {
    const missing: string[] = [];
    
    for (const depId of task.dependencies) {
      const depTask = await this.dependencies.storage.getTask(depId);
      if (!depTask) {
        missing.push(depId);
      }
    }
    
    return missing;
  }

  private async findBlockedDependencies(task: TaskBatchData): Promise<string[]> {
    const blocked: string[] = [];
    
    for (const depId of task.dependencies) {
      const depTask = await this.dependencies.storage.getTask(depId);
      if (depTask && depTask.status === TaskStatus.BLOCKED) {
        blocked.push(depId);
      }
    }
    
    return blocked;
  }

  private getProcessingOrder(): string[] {
    const visited = new Set<string>();
    const order: string[] = [];

    const visit = (taskId: string) => {
      if (visited.has(taskId)) return;
      visited.add(taskId);

      const dependencies = this.dependencyGraph[taskId] || new Set();
      for (const depId of dependencies) {
        visit(depId);
      }

      order.push(taskId);
    };

    for (const taskId of Object.keys(this.dependencyGraph)) {
      visit(taskId);
    }

    return order;
  }

  private async processTask(task: TaskBatchData): Promise<Task> {
    try {
      // Re-fetch task to ensure we have latest state
      const currentTask = await this.dependencies.storage.getTask(task.task.path);
      if (!currentTask) {
        throw new Error(`Task ${task.task.path} not found during processing`);
      }

      // Check dependencies are complete
      const incompleteDeps: string[] = [];
      const failedDeps: string[] = [];
      
      for (const depId of task.dependencies) {
        const depTask = await this.dependencies.storage.getTask(depId);
        if (!depTask) {
          incompleteDeps.push(depId);
        } else if (depTask.status === TaskStatus.FAILED) {
          failedDeps.push(depId);
        } else if (depTask.status !== TaskStatus.COMPLETED) {
          incompleteDeps.push(depId);
        }
      }

      // Handle dependency issues
      if (failedDeps.length > 0) {
        // If any dependencies failed, mark this task as failed
        return await this.dependencies.storage.updateTask(
          task.task.path,
          {
            status: TaskStatus.FAILED,
            metadata: {
              ...currentTask.metadata,
              failureReason: `Dependencies failed: ${failedDeps.join(', ')}`,
              updated: Date.now(),
              version: currentTask.metadata.version + 1
            }
          }
        );
      }

      if (incompleteDeps.length > 0) {
        // If dependencies are incomplete, mark as blocked
        return await this.dependencies.storage.updateTask(
          task.task.path,
          {
            status: TaskStatus.BLOCKED,
            metadata: {
              ...currentTask.metadata,
              blockedBy: incompleteDeps,
              updated: Date.now(),
              version: currentTask.metadata.version + 1
            }
          }
        );
      }

      // All dependencies complete, process the task
      const processedTask = await this.dependencies.storage.updateTask(
        task.task.path,
        {
          status: TaskStatus.COMPLETED,
          metadata: {
            ...currentTask.metadata,
            completedAt: Date.now(),
            updated: Date.now(),
            version: currentTask.metadata.version + 1
          }
        }
      );

      return processedTask;
    } catch (error) {
      this.logger.error('Failed to process task', {
        error,
        taskPath: task.task.path,
        dependencies: task.dependencies
      });
      throw error;
    }
  }
}

================
File: task/core/batch/generic-batch-processor.ts
================
import { BatchData, BatchResult, ValidationResult } from './common/batch-utils.js';
import { BaseBatchProcessor, BatchDependencies, BatchOptions } from './base-batch-processor.js';

export interface GenericBatchConfig extends BatchOptions {
  validateItems?: boolean;
  stopOnError?: boolean;
  itemTimeout?: number;
}

export class GenericBatchProcessor<T> extends BaseBatchProcessor<T> {
  private readonly config: Required<GenericBatchConfig>;
  private readonly defaultConfig: Required<GenericBatchConfig> = {
    ...this.defaultOptions,
    validateItems: true,
    stopOnError: false,
    itemTimeout: 5000
  };

  constructor(
    dependencies: BatchDependencies,
    config: GenericBatchConfig = {}
  ) {
    super(dependencies, config);
    this.config = { ...this.defaultConfig, ...config };
  }

  protected async validate(batch: BatchData[]): Promise<ValidationResult> {
    const errors: string[] = [];

    if (!Array.isArray(batch)) {
      errors.push('Batch must be an array');
      return { valid: false, errors };
    }

    if (batch.length === 0) {
      errors.push('Batch cannot be empty');
      return { valid: false, errors };
    }

    if (this.config.validateItems) {
      for (const [index, item] of batch.entries()) {
        if (!item.id) {
          errors.push(`Item at index ${index} is missing required 'id' field`);
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  protected async process(batch: BatchData[]): Promise<BatchResult<T>> {
    const results: T[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    for (const item of batch) {
      try {
        const result = await this.processWithTimeout(
          item,
          this.config.itemTimeout
        );
        results.push(result);

        this.logger.debug('Processed batch item', {
          itemId: item.id,
          duration: Date.now() - startTime
        });
      } catch (error) {
        this.logger.error('Failed to process batch item', {
          error,
          itemId: item.id
        });
        errors.push(error as Error);

        if (this.config.stopOnError) {
          this.logger.warn('Stopping batch processing due to error', {
            itemId: item.id,
            remainingItems: batch.length - results.length - 1
          });
          break;
        }
      }
    }

    const endTime = Date.now();
    const result: BatchResult<T> = {
      results,
      errors,
      metadata: {
        processingTime: endTime - startTime,
        successCount: results.length,
        errorCount: errors.length
      }
    };

    this.logMetrics(result);
    return result;
  }

  private async processWithTimeout(
    item: BatchData,
    timeout: number
  ): Promise<T> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Processing timed out for item ${item.id}`));
      }, timeout);

      this.processItem(item)
        .then(result => {
          clearTimeout(timeoutId);
          resolve(result);
        })
        .catch(error => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  }

  private async processItem(item: BatchData): Promise<T> {
    // This is where you would implement the actual processing logic
    // For now, we'll just return the item as is
    return item as unknown as T;
  }

  /**
   * Helper method to categorize errors for better error handling
   */
}

================
File: task/core/batch/index.ts
================
export * from './base-batch-processor.js';
export * from './dependency-aware-batch-processor.js';
export * from './generic-batch-processor.js';
export * from './task-status-batch-processor.js';

================
File: task/core/batch/status-update-batch.ts
================
import { TaskStatus, UpdateTaskInput } from '../../../types/task.js';
import { Logger } from '../../../logging/index.js';
import { TransactionManager } from '../transactions/transaction-manager.js';
import { TaskStorage } from '../../../types/storage.js';
import { ErrorCodes, createError } from '../../../errors/index.js';

export class StatusUpdateBatch {
    private readonly logger: Logger;
    private readonly transactionManager: TransactionManager;
    private readonly updates: Map<string, UpdateTaskInput> = new Map();
    private readonly processedTasks: Set<string> = new Set();

    constructor(
        private readonly storage: TaskStorage
    ) {
        this.logger = Logger.getInstance().child({ component: 'StatusUpdateBatch' });
        this.transactionManager = TransactionManager.getInstance(storage);
    }

    /**
     * Add a task status update to the batch
     */
    addUpdate(path: string, status: TaskStatus, metadata?: Record<string, any>): void {
        if (this.processedTasks.has(path)) {
            return; // Prevent circular updates
        }

        this.updates.set(path, {
            status,
            metadata: {
                ...metadata,
                statusUpdatedAt: Date.now()
            }
        });
        this.processedTasks.add(path);
    }

    /**
     * Execute all batched updates in a single transaction
     */
    async execute(): Promise<void> {
        if (this.updates.size === 0) {
            return;
        }

        const transaction = await this.transactionManager.begin({
            timeout: 30000, // 30 second timeout for batch operations
            requireLock: true
        });

        try {
            // Process updates in dependency order
            const orderedUpdates = await this.orderUpdatesByDependencies();

            for (const [path, update] of orderedUpdates) {
                const task = await this.storage.getTask(path);
                if (!task) {
                    this.logger.warn('Task not found during batch update', { path });
                    continue;
                }

                await this.storage.updateTask(path, update);
            }

            await this.transactionManager.commit(transaction);
            
            this.logger.info('Status update batch completed', {
                updateCount: this.updates.size,
                paths: Array.from(this.updates.keys())
            });
        } catch (error) {
            this.logger.error('Failed to execute status update batch', { error });
            await this.transactionManager.rollback(transaction);
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to execute status update batch',
                String(error)
            );
        } finally {
            this.updates.clear();
            this.processedTasks.clear();
        }
    }

    /**
     * Order updates based on task dependencies to prevent conflicts
     */
    private async orderUpdatesByDependencies(): Promise<Map<string, UpdateTaskInput>> {
        const ordered = new Map<string, UpdateTaskInput>();
        const visited = new Set<string>();
        const visiting = new Set<string>();

        const visit = async (path: string) => {
            if (visited.has(path)) return;
            if (visiting.has(path)) {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Circular dependency detected: ${path}`
                );
            }

            visiting.add(path);

            const task = await this.storage.getTask(path);
            if (task) {
                // Visit dependencies first
                for (const depPath of task.dependencies) {
                    if (this.updates.has(depPath)) {
                        await visit(depPath);
                    }
                }

                // Then add this task's update
                const update = this.updates.get(path);
                if (update) {
                    ordered.set(path, update);
                }
            }

            visiting.delete(path);
            visited.add(path);
        };

        // Visit all tasks in the update set
        for (const path of this.updates.keys()) {
            await visit(path);
        }

        return ordered;
    }

    /**
     * Get number of pending updates
     */
    get size(): number {
        return this.updates.size;
    }
}

================
File: task/core/batch/task-status-batch-processor.ts
================
import { Task, TaskStatus } from '../../../types/task.js';
import { BatchData, BatchResult, ValidationResult, TaskBatchData } from './common/batch-utils.js';
import { BaseBatchProcessor, BatchDependencies, BatchOptions } from './base-batch-processor.js';
import { validateTaskStatusTransition } from '../../validation/index.js';

export interface TaskStatusBatchConfig extends BatchOptions {
  updateDependents?: boolean;
}

export class TaskStatusBatchProcessor extends BaseBatchProcessor<Task> {
  private readonly config: Required<TaskStatusBatchConfig> & Required<BatchOptions>;

  constructor(
    dependencies: BatchDependencies,
    config: TaskStatusBatchConfig = {}
  ) {
    super(dependencies, config);
    this.config = Object.assign(
      {},
      this.defaultOptions,
      {
        updateDependents: true
      },
      config
    ) as Required<TaskStatusBatchConfig> & Required<BatchOptions>;
  }

  protected async validate(batch: BatchData[]): Promise<ValidationResult> {
    const errors: string[] = [];
    const tasks = batch.map(item => (item as TaskBatchData).data);

    if (!Array.isArray(batch)) {
      errors.push('Batch must be an array');
      return { valid: false, errors };
    }

    if (batch.length === 0) {
      errors.push('Batch cannot be empty');
      return { valid: false, errors };
    }

    // Clear any stale cache entries before validation
    if ('clearCache' in this.dependencies.storage) {
      await (this.dependencies.storage as any).clearCache();
    }

    // First pass: validate all status transitions
    for (const task of tasks) {
      const newStatus = task.metadata?.newStatus as TaskStatus;

      if (!newStatus) {
        errors.push(`Task ${task.path} is missing new status in metadata`);
        continue;
      }

      try {
        // Use shared validation utility for status transitions
        await validateTaskStatusTransition(task, newStatus, this.dependencies.storage.getTask.bind(this.dependencies.storage));
      } catch (error) {
        if (error instanceof Error) {
          errors.push(error.message);
        } else {
          errors.push('Unknown validation error occurred');
        }
      }
    }

    // Second pass: validate parent-child status consistency
    for (const task of tasks) {
      const newStatus = task.metadata?.newStatus as TaskStatus;
      if (!newStatus || !task.parentPath) continue;

      const parent = await this.dependencies.storage.getTask(task.parentPath);
      if (!parent) continue;

      const siblings = await this.dependencies.storage.getSubtasks(parent.path);
      const siblingStatuses = new Set(siblings.map((t: Task) => t.status));

      // Check for invalid status combinations
      if (newStatus === TaskStatus.COMPLETED && 
          siblingStatuses.has(TaskStatus.BLOCKED)) {
        errors.push(`Cannot complete task ${task.path} while sibling tasks are blocked`);
      }

      if (newStatus === TaskStatus.IN_PROGRESS && 
          siblingStatuses.has(TaskStatus.FAILED)) {
        errors.push(`Cannot start task ${task.path} while sibling tasks have failed`);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  protected async process(batch: BatchData[]): Promise<BatchResult<Task>> {
    const tasks = batch.map(item => (item as TaskBatchData).data);
    const results: Task[] = [];
    const errors: Error[] = [];
    const startTime = Date.now();

    for (const task of tasks) {
      try {
        const newStatus = task.metadata?.newStatus as TaskStatus;
        const updatedTask = await this.updateTaskStatus(task, newStatus);
        results.push(updatedTask);

        if (this.config.updateDependents) {
          await this.updateDependentTasks(updatedTask);
        }
      } catch (error) {
        errors.push(error as Error);
        this.logger.error('Failed to update task status', {
          error,
          taskPath: task.path,
          newStatus: task.metadata?.newStatus
        });
      }
    }

    const endTime = Date.now();
    const result: BatchResult<Task> = {
      results,
      errors,
      metadata: {
        processingTime: endTime - startTime,
        successCount: results.length,
        errorCount: errors.length
      }
    };

    this.logMetrics(result);
    return result;
  }

  private async updateTaskStatus(task: Task, newStatus: TaskStatus): Promise<Task> {
    return await this.dependencies.storage.updateTask(task.path, {
      status: newStatus,
      metadata: {
        ...task.metadata,
        statusUpdatedAt: Date.now(),
        previousStatus: task.status
      }
    });
  }

  private async updateDependentTasks(task: Task): Promise<void> {
    const dependentTasks = await this.dependencies.storage.getDependentTasks(task.path);

    for (const depTask of dependentTasks) {
      if (task.status === TaskStatus.BLOCKED || task.status === TaskStatus.FAILED) {
        await this.updateTaskStatus(depTask, TaskStatus.BLOCKED);
      } else if (task.status === TaskStatus.COMPLETED) {
        const allDepsCompleted = await this.areAllDependenciesCompleted(depTask);
        if (allDepsCompleted && depTask.status === TaskStatus.BLOCKED) {
          await this.updateTaskStatus(depTask, TaskStatus.PENDING);
        }
      }
    }
  }

  private async areAllDependenciesCompleted(task: Task): Promise<boolean> {
    for (const depPath of task.dependencies) {
      const depTask = await this.dependencies.storage.getTask(depPath);
      if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
        return false;
      }
    }
    return true;
  }
}

================
File: task/core/cache/cache-coordinator.ts
================
import { Logger } from '../../../logging/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { CacheManager } from './cache-manager.js';
import { CacheMetrics } from './cache-metrics.js';
import { CacheCoordinatorOptions } from '../../../types/cache.js';

export class CacheCoordinator {
  private readonly logger: Logger;
  private readonly metrics: CacheMetrics;
  private readonly eventManager: EventManager;
  private monitorInterval?: NodeJS.Timeout;
  private readonly options: Required<CacheCoordinatorOptions>;

  constructor(
    private readonly cacheManager: CacheManager,
    options: CacheCoordinatorOptions = {}
  ) {
    this.logger = Logger.getInstance().child({ component: 'CacheCoordinator' });
    this.metrics = new CacheMetrics();
    this.eventManager = EventManager.getInstance();

    // Set default options
    this.options = {
      maxMemory: options.maxMemory || 512 * 1024 * 1024, // 512MB
      checkInterval: options.checkInterval || 60000, // 1 minute
      pressureThreshold: options.pressureThreshold || 0.8, // 80%
      debugMode: options.debugMode || process.env.NODE_ENV === 'development'
    };

    this.setupEventListeners();
    this.startMemoryMonitoring();
  }

  private setupEventListeners(): void {
    // Listen for task updates to invalidate cache
    this.eventManager.on(EventTypes.TASK_UPDATED, () => {
      this.invalidateTaskCache();
    });

    // Listen for memory pressure to reduce cache size
    this.eventManager.on(EventTypes.MEMORY_PRESSURE, () => {
      this.reduceCacheSize();
    });

    // Listen for cache-related events to update metrics
    this.eventManager.on(EventTypes.CACHE_INVALIDATED, () => {
      this.metrics.recordInvalidation();
    });

    this.eventManager.on(EventTypes.CACHE_CLEARED, () => {
      this.metrics.recordClear();
    });
  }

  private startMemoryMonitoring(): void {
    this.monitorInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, this.options.checkInterval);
  }

  private async checkMemoryUsage(): Promise<void> {
    const memUsage = process.memoryUsage();
    const heapUsed = memUsage.heapUsed;
    const usage = heapUsed / this.options.maxMemory;

    this.metrics.updateMemoryUsage(heapUsed);

    if (usage >= this.options.pressureThreshold) {
      this.logger.warn('Memory pressure detected', {
        heapUsed: `${Math.round(heapUsed / 1024 / 1024)}MB`,
        maxMemory: `${Math.round(this.options.maxMemory / 1024 / 1024)}MB`,
        usage: `${Math.round(usage * 100)}%`,
        threshold: `${Math.round(this.options.pressureThreshold * 100)}%`
      });

      // Emit memory pressure event
      this.eventManager.emit({
        type: EventTypes.MEMORY_PRESSURE,
        timestamp: Date.now(),
        metadata: {
          memoryUsage: {
            heapUsed,
            heapTotal: memUsage.heapTotal,
            rss: memUsage.rss
          },
          threshold: this.options.pressureThreshold
        }
      });

      await this.reduceCacheSize();
    }

    if (this.options.debugMode) {
      this.logger.debug('Memory usage stats', {
        heapUsed: `${Math.round(heapUsed / 1024 / 1024)}MB`,
        usage: `${Math.round(usage * 100)}%`,
        cacheSize: this.metrics.getCacheSize(),
        hitRatio: this.metrics.getHitRatio()
      });
    }
  }

  private async invalidateTaskCache(): Promise<void> {
    try {
      const before = this.metrics.getCacheSize();
      await this.cacheManager.invalidate();
      const after = this.metrics.getCacheSize();

      this.eventManager.emit({
        type: EventTypes.CACHE_INVALIDATED,
        timestamp: Date.now(),
        metadata: {
          reason: 'task_update',
          sizeBefore: before,
          sizeAfter: after,
          reduction: before - after
        }
      });

      if (this.options.debugMode) {
        this.logger.debug('Cache invalidated', {
          sizeBefore: before,
          sizeAfter: after,
          reduction: before - after
        });
      }
    } catch (error) {
      this.logger.error('Failed to invalidate cache', { error });
      throw error;
    }
  }

  private async reduceCacheSize(): Promise<void> {
    try {
      const before = this.metrics.getCacheSize();
      await this.cacheManager.reduce();
      const after = this.metrics.getCacheSize();

      this.eventManager.emit({
        type: EventTypes.CACHE_CLEARED,
        timestamp: Date.now(),
        metadata: {
          reason: 'memory_pressure',
          sizeBefore: before,
          sizeAfter: after,
          reduction: before - after
        }
      });

      this.logger.info('Cache size reduced', {
        before,
        after,
        reduction: before - after
      });
    } catch (error) {
      this.logger.error('Failed to reduce cache size', { error });
      throw error;
    }
  }

  async clearCache(): Promise<void> {
    try {
      const before = this.metrics.getCacheSize();
      await this.cacheManager.clear();
      
      this.eventManager.emit({
        type: EventTypes.CACHE_CLEARED,
        timestamp: Date.now(),
        metadata: {
          reason: 'manual_clear',
          sizeBefore: before,
          sizeAfter: 0,
          reduction: before
        }
      });

      this.logger.info('Cache cleared');
    } catch (error) {
      this.logger.error('Failed to clear cache', { error });
      throw error;
    }
  }

  getMetrics(): Record<string, unknown> {
    return {
      ...this.metrics.getMetrics(),
      maxMemory: this.options.maxMemory,
      pressureThreshold: this.options.pressureThreshold,
      checkInterval: this.options.checkInterval
    };
  }

  stop(): void {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = undefined;
    }
  }
}

================
File: task/core/cache/cache-manager.ts
================
import { Logger } from '../../../logging/index.js';
import { EventManager } from '../../../events/event-manager.js';
import { EventTypes } from '../../../types/events.js';
import { CacheMetrics } from './cache-metrics.js';
import { CacheOptions, CacheEntry } from '../../../types/cache.js';

export class CacheManager {
  private readonly cache: Map<string, CacheEntry<any>>;
  private readonly logger: Logger;
  private readonly metrics: CacheMetrics;
  private readonly eventManager: EventManager;
  private cleanupInterval?: NodeJS.Timeout;
  private readonly options: Required<CacheOptions>;

  constructor(options: CacheOptions = {}) {
    this.cache = new Map();
    this.logger = Logger.getInstance().child({ component: 'CacheManager' });
    this.metrics = new CacheMetrics();
    this.eventManager = EventManager.getInstance();

    // Set default options
    this.options = {
      maxSize: options.maxSize || 1000,
      ttl: options.ttl || 5 * 60 * 1000, // 5 minutes
      cleanupInterval: options.cleanupInterval || 60 * 1000, // 1 minute
      baseTTL: options.baseTTL || 60 * 1000, // 1 minute
      maxTTL: options.maxTTL || 5 * 60 * 1000 // 5 minutes
    };

    this.startCleanupInterval();
  }

  async get<T>(key: string): Promise<T | undefined> {
    const entry = this.cache.get(key);

    if (!entry) {
      this.metrics.recordMiss();
      return undefined;
    }

    // Check if entry has expired
    if (Date.now() > entry.expires) {
      this.cache.delete(key);
      this.metrics.recordMiss();
      this.updateMetrics();
      return undefined;
    }

    // Update last accessed time
    entry.lastAccessed = Date.now();
    this.metrics.recordHit();
    return entry.value;
  }

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    // Check cache size limit
    if (this.cache.size >= this.options.maxSize) {
      await this.evictLeastRecentlyUsed();
    }

    const expires = Date.now() + (ttl || this.options.ttl);
    
    this.cache.set(key, {
      value,
      expires,
      lastAccessed: Date.now()
    });

    this.updateMetrics();
  }

  async invalidate(pattern?: string): Promise<void> {
    if (pattern) {
      const regex = new RegExp(pattern);
      for (const key of this.cache.keys()) {
        if (regex.test(key)) {
          this.cache.delete(key);
        }
      }
    } else {
      this.cache.clear();
    }

    this.metrics.recordInvalidation();
    this.updateMetrics();

    this.eventManager.emit({
      type: EventTypes.CACHE_INVALIDATED,
      timestamp: Date.now(),
      batchId: `cache_invalidate_${Date.now()}`,
      metadata: {
        pattern,
        entriesRemaining: this.cache.size
      }
    });
  }

  async reduce(percentage: number = 0.5): Promise<void> {
    const targetSize = Math.floor(this.cache.size * (1 - percentage));
    await this.evictEntries(this.cache.size - targetSize);
    this.updateMetrics();
  }

  async delete(key: string): Promise<void> {
    this.cache.delete(key);
    this.updateMetrics();
  }

  async clear(): Promise<void> {
    this.cache.clear();
    this.metrics.recordClear();
    this.updateMetrics();

    this.eventManager.emit({
      type: EventTypes.CACHE_CLEARED,
      timestamp: Date.now(),
      batchId: `cache_clear_${Date.now()}`,
      metadata: {
        reason: 'manual_clear'
      }
    });
  }

  getMetrics(): Record<string, unknown> {
    return this.metrics.getMetrics();
  }

  private startCleanupInterval(): void {
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, this.options.cleanupInterval);
  }

  private async cleanup(): Promise<void> {
    const now = Date.now();
    let removed = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expires) {
        this.cache.delete(key);
        removed++;
      }
    }

    if (removed > 0) {
      this.updateMetrics();
      this.logger.debug('Cache cleanup completed', {
        entriesRemoved: removed,
        remainingEntries: this.cache.size
      });
    }
  }

  private async evictLeastRecentlyUsed(): Promise<void> {
    let oldest: { key: string; lastAccessed: number } | null = null;

    for (const [key, entry] of this.cache.entries()) {
      if (!oldest || entry.lastAccessed < oldest.lastAccessed) {
        oldest = { key, lastAccessed: entry.lastAccessed };
      }
    }

    if (oldest) {
      this.cache.delete(oldest.key);
      this.updateMetrics();
    }
  }

  private async evictEntries(count: number): Promise<void> {
    // Sort entries by last accessed time
    const entries = Array.from(this.cache.entries())
      .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);

    // Remove oldest entries
    for (let i = 0; i < Math.min(count, entries.length); i++) {
      this.cache.delete(entries[i][0]);
    }
  }

  private updateMetrics(): void {
    this.metrics.updateSize(this.cache.size);
  }

  stop(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = undefined;
    }
  }
}

================
File: task/core/cache/cache-metrics.ts
================
import { Logger } from '../../../logging/index.js';
import { CacheMetricsData } from '../../../types/cache.js';

export class CacheMetrics {
  private readonly logger: Logger;
  private hits = 0;
  private misses = 0;
  private size = 0;
  private lastCleanup: number = Date.now();
  private invalidations = 0;
  private clears = 0;
  private memoryUsage = 0;

  constructor() {
    this.logger = Logger.getInstance().child({ component: 'CacheMetrics' });
  }

  recordHit(): void {
    this.hits++;
  }

  recordMiss(): void {
    this.misses++;
  }

  updateSize(newSize: number): void {
    this.size = newSize;
    this.logger.debug('Cache size updated', { size: newSize });
  }

  recordInvalidation(): void {
    this.invalidations++;
    this.lastCleanup = Date.now();
    this.logger.debug('Cache invalidation recorded', {
      invalidations: this.invalidations
    });
  }

  recordClear(): void {
    this.clears++;
    this.lastCleanup = Date.now();
    this.logger.debug('Cache clear recorded', {
      clears: this.clears
    });
  }

  updateMemoryUsage(bytes: number): void {
    this.memoryUsage = bytes;
    this.logger.debug('Memory usage updated', {
      memoryUsage: `${Math.round(bytes / 1024 / 1024)}MB`
    });
  }

  getCacheSize(): number {
    return this.size;
  }

  getHitRatio(): number {
    const total = this.hits + this.misses;
    return total === 0 ? 0 : this.hits / total;
  }

  getMetrics(): CacheMetricsData {
    const metrics = {
      hits: this.hits,
      misses: this.misses,
      hitRatio: this.getHitRatio(),
      size: this.size,
      lastCleanup: this.lastCleanup,
      invalidations: this.invalidations,
      clears: this.clears,
      memoryUsage: this.memoryUsage
    };

    this.logger.debug('Cache metrics retrieved', metrics);
    return metrics;
  }

  reset(): void {
    this.hits = 0;
    this.misses = 0;
    this.size = 0;
    this.lastCleanup = Date.now();
    this.invalidations = 0;
    this.clears = 0;
    this.memoryUsage = 0;
    this.logger.debug('Cache metrics reset');
  }
}

================
File: task/core/cache/index.ts
================
export * from './cache-manager.js';
export * from './cache-coordinator.js';
export * from './cache-metrics.js';

================
File: task/core/indexing/index-manager.ts
================
/**
 * Task index manager
 * Maintains in-memory indexes for efficient task lookups
 */
import { ErrorCodes, createError } from '../../../errors/index.js';
import { Task, TaskStatus } from '../../../types/task.js';
import { TaskIndex, IndexStats } from '../../../types/indexing.js';
import { Logger } from '../../../logging/index.js';
import { globToRegex, generatePathPatterns, matchesPattern } from '../../../utils/pattern-matcher.js';

export class TaskIndexManager {
    private readonly logger: Logger;
    private readonly taskIndexes: Map<string, WeakRef<TaskIndex>>;
    private readonly pathIndex: Map<string, Set<string>>;
    private readonly patternIndex: Map<string, Set<string>>;
    private readonly statusIndex: Map<TaskStatus, Set<string>>;
    private readonly parentIndex: Map<string, Set<string>>;
    private readonly dependencyIndex: Map<string, Set<string>>;
    
    // Keep track of pattern count to prevent unbounded growth
    private readonly MAX_PATTERNS = 1000;
    private patternCount = 0;

    // Cleanup interval
    private readonly CLEANUP_INTERVAL = 60000; // 1 minute
    private cleanupTimer?: NodeJS.Timeout;

    constructor() {
        this.logger = Logger.getInstance().child({ component: 'TaskIndexManager' });
        this.taskIndexes = new Map();
        this.pathIndex = new Map();
        this.patternIndex = new Map();
        this.statusIndex = new Map();
        this.parentIndex = new Map();
        this.dependencyIndex = new Map();

        // Start cleanup timer
        this.startCleanupTimer();
    }

    private startCleanupTimer(): void {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
        
        this.cleanupTimer = setInterval(() => {
            this.cleanupIndexes();
            this.cleanupPatterns();
            
            // Force GC if available
            if (global.gc) {
                global.gc();
            }
        }, this.CLEANUP_INTERVAL);

        // Ensure cleanup timer is cleared on process exit
        process.once('beforeExit', () => {
            if (this.cleanupTimer) {
                clearInterval(this.cleanupTimer);
                this.cleanupTimer = undefined;
            }
        });
    }

    /**
     * Indexes path patterns for efficient pattern matching
     */
    private indexPathPatterns(path: string): void {
        const patterns = generatePathPatterns(path);
        
        for (const pattern of patterns) {
            let paths = this.patternIndex.get(pattern);
            if (!paths) {
                paths = new Set();
                this.patternIndex.set(pattern, paths);
                this.patternCount++;
            }
            paths.add(path);
        }
    }

    /**
     * Gets a task from its weak reference
     */
    private getTaskFromWeakRef(path: string): TaskIndex | undefined {
        const ref = this.taskIndexes.get(path);
        if (!ref) return undefined;
        
        const task = ref.deref();
        if (!task) {
            // Clean up if task was garbage collected
            this.taskIndexes.delete(path);
            return undefined;
        }
        
        return task;
    }

    /**
     * Indexes a task
     */
    async indexTask(task: Task): Promise<void> {
        try {
            // Create task index
            const taskIndex: TaskIndex = {
                ...task,
                path: task.path,
                status: task.status,
                parentPath: task.parentPath,
                dependencies: task.dependencies || [],
                subtasks: task.subtasks || []
            };

            // Store weak reference to allow GC
            this.taskIndexes.set(task.path, new WeakRef(taskIndex));

            // Clean up old patterns if we're at the limit
            if (this.patternCount >= this.MAX_PATTERNS) {
                this.cleanupPatterns();
            }

            // Update path index and patterns
            const pathSegments = task.path.split('/');
            for (let i = 1; i <= pathSegments.length; i++) {
                const prefix = pathSegments.slice(0, i).join('/');
                let paths = this.pathIndex.get(prefix);
                if (!paths) {
                    paths = new Set();
                    this.pathIndex.set(prefix, paths);
                }
                paths.add(task.path);
            }
            this.indexPathPatterns(task.path);

            // Update status index
            let statusPaths = this.statusIndex.get(task.status);
            if (!statusPaths) {
                statusPaths = new Set();
                this.statusIndex.set(task.status, statusPaths);
            }
            statusPaths.add(task.path);

            // Update parent index
            if (task.parentPath) {
                let children = this.parentIndex.get(task.parentPath);
                if (!children) {
                    children = new Set();
                    this.parentIndex.set(task.parentPath, children);
                }
                children.add(task.path);
            }

            // Update dependency index
            for (const depPath of task.dependencies) {
                let dependents = this.dependencyIndex.get(depPath);
                if (!dependents) {
                    dependents = new Set();
                    this.dependencyIndex.set(depPath, dependents);
                }
                dependents.add(task.path);
            }

            this.logger.debug('Indexed task', { path: task.path });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to index task', { error: errorMessage, task });
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to index task',
                errorMessage
            );
        }
    }

    /**
     * Gets tasks by path pattern
     */
    async getTasksByPattern(pattern: string): Promise<TaskIndex[]> {
        // First try exact pattern match from pattern index
        const exactMatches = this.patternIndex.get(pattern);
        if (exactMatches) {
            const tasks = Array.from(exactMatches)
                .map(path => this.getTaskFromWeakRef(path))
                .filter((task): task is TaskIndex => task !== undefined);
            
            // If we got matches, return them
            if (tasks.length > 0) {
                return tasks;
            }
            // Otherwise clean up the empty pattern
            this.patternIndex.delete(pattern);
            this.patternCount--;
        }

        // Try prefix match from path index
        const prefixMatches = this.pathIndex.get(pattern);
        if (prefixMatches) {
            const tasks = Array.from(prefixMatches)
                .map(path => this.getTaskFromWeakRef(path))
                .filter((task): task is TaskIndex => task !== undefined);
            
            // Clean up empty sets
            if (tasks.length === 0) {
                this.pathIndex.delete(pattern);
            }
            
            return tasks;
        }

        // Fall back to regex matching
        const regex = globToRegex(pattern);
        const matchingPaths = Array.from(this.taskIndexes.keys())
            .filter(path => regex.test(path));

        return matchingPaths
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets tasks by status with optional pattern filtering
     */
    async getTasksByStatus(status: TaskStatus, pattern?: string): Promise<TaskIndex[]> {
        const statusPaths = this.statusIndex.get(status) || new Set<string>();
        
        if (!pattern) {
            return Array.from(statusPaths)
                .map(path => this.getTaskFromWeakRef(path))
                .filter((task): task is TaskIndex => task !== undefined);
        }

        // Filter by pattern if provided
        const matchingPaths = Array.from(statusPaths)
            .filter(path => matchesPattern(path, pattern));

        return matchingPaths
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets project tasks by pattern
     */
    async getProjectTasks(pattern: string): Promise<TaskIndex[]> {
        return this.getTasksByPattern(pattern);
    }

    /**
     * Gets tasks by parent path
     */
    async getTasksByParent(parentPath: string): Promise<TaskIndex[]> {
        const children = this.parentIndex.get(parentPath) || new Set<string>();
        return Array.from(children)
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets tasks that depend on a task
     */
    async getDependentTasks(path: string): Promise<TaskIndex[]> {
        const dependents = this.dependencyIndex.get(path) || new Set<string>();
        return Array.from(dependents)
            .map(path => this.getTaskFromWeakRef(path))
            .filter((task): task is TaskIndex => task !== undefined);
    }

    /**
     * Gets a task by path
     */
    async getTaskByPath(path: string): Promise<TaskIndex | null> {
        return this.getTaskFromWeakRef(path) || null;
    }

    /**
     * Unindexes a task
     */
    async unindexTask(task: Task): Promise<void> {
        try {
            // Remove from task indexes
            this.taskIndexes.delete(task.path);

            // Remove from path index and patterns
            const pathSegments = task.path.split('/');
            for (let i = 1; i <= pathSegments.length; i++) {
                const prefix = pathSegments.slice(0, i).join('/');
                const paths = this.pathIndex.get(prefix);
                if (paths) {
                    paths.delete(task.path);
                    if (paths.size === 0) {
                        this.pathIndex.delete(prefix);
                    }
                }
            }

            // Remove from pattern index
            const patterns = generatePathPatterns(task.path);
            for (const pattern of patterns) {
                const paths = this.patternIndex.get(pattern);
                if (paths) {
                    paths.delete(task.path);
                    if (paths.size === 0) {
                        this.patternIndex.delete(pattern);
                        this.patternCount--;
                    }
                }
            }

            // Remove from status index
            const statusPaths = this.statusIndex.get(task.status);
            if (statusPaths) {
                statusPaths.delete(task.path);
                if (statusPaths.size === 0) {
                    this.statusIndex.delete(task.status);
                }
            }

            // Remove from parent index
            if (task.parentPath) {
                const children = this.parentIndex.get(task.parentPath);
                if (children) {
                    children.delete(task.path);
                    if (children.size === 0) {
                        this.parentIndex.delete(task.parentPath);
                    }
                }
            }

            // Remove from dependency index
            for (const depPath of task.dependencies) {
                const dependents = this.dependencyIndex.get(depPath);
                if (dependents) {
                    dependents.delete(task.path);
                    if (dependents.size === 0) {
                        this.dependencyIndex.delete(depPath);
                    }
                }
            }

            this.logger.debug('Unindexed task', { path: task.path });
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('Failed to unindex task', { error: errorMessage, task });
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Failed to unindex task',
                errorMessage
            );
        }
    }

    /**
     * Gets index statistics
     */
    getStats(): IndexStats {
        const byStatus = {} as Record<TaskStatus, number>;
        const byDepth = {} as Record<number, number>;
        let totalDepth = 0;
        let validTaskCount = 0;

        // Only count tasks that haven't been garbage collected
        for (const [path, weakRef] of this.taskIndexes.entries()) {
            const task = weakRef.deref();
            if (task) {
                validTaskCount++;
                
                // Count by status
                byStatus[task.status] = (byStatus[task.status] || 0) + 1;

                // Count by depth
                const depth = path.split('/').length - 1;
                byDepth[depth] = (byDepth[depth] || 0) + 1;
                totalDepth += depth;
            }
        }

        return {
            totalTasks: validTaskCount,
            byStatus,
            byDepth,
            averageDepth: validTaskCount > 0 ? totalDepth / validTaskCount : 0
        };
    }

    /**
     * Cleans up old patterns to prevent unbounded growth
     */
    private cleanupPatterns(): void {
        // Remove patterns with no valid tasks
        for (const [pattern, paths] of this.patternIndex.entries()) {
            const validPaths = Array.from(paths)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.patternIndex.delete(pattern);
                this.patternCount--;
            } else if (validPaths.length !== paths.size) {
                // Update set with only valid paths
                this.patternIndex.set(pattern, new Set(validPaths));
            }
        }
    }

    /**
     * Cleans up invalid references and empty sets
     */
    private cleanupIndexes(): void {
        // Clean up task indexes
        for (const [path, weakRef] of this.taskIndexes.entries()) {
            if (weakRef.deref() === undefined) {
                this.taskIndexes.delete(path);
            }
        }

        // Clean up empty sets in all indexes
        for (const [prefix, paths] of this.pathIndex.entries()) {
            const validPaths = Array.from(paths)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.pathIndex.delete(prefix);
            } else if (validPaths.length !== paths.size) {
                this.pathIndex.set(prefix, new Set(validPaths));
            }
        }

        for (const [status, paths] of this.statusIndex.entries()) {
            const validPaths = Array.from(paths)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.statusIndex.delete(status);
            } else if (validPaths.length !== paths.size) {
                this.statusIndex.set(status, new Set(validPaths));
            }
        }

        for (const [parent, children] of this.parentIndex.entries()) {
            const validPaths = Array.from(children)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.parentIndex.delete(parent);
            } else if (validPaths.length !== children.size) {
                this.parentIndex.set(parent, new Set(validPaths));
            }
        }

        for (const [dep, dependents] of this.dependencyIndex.entries()) {
            const validPaths = Array.from(dependents)
                .filter(path => this.getTaskFromWeakRef(path) !== undefined);
            
            if (validPaths.length === 0) {
                this.dependencyIndex.delete(dep);
            } else if (validPaths.length !== dependents.size) {
                this.dependencyIndex.set(dep, new Set(validPaths));
            }
        }
    }

    /**
     * Clears all indexes
     */
    clear(): void {
        // Stop cleanup timer
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = undefined;
        }

        this.taskIndexes.clear();
        this.pathIndex.clear();
        this.patternIndex.clear();
        this.statusIndex.clear();
        this.parentIndex.clear();
        this.dependencyIndex.clear();
        this.patternCount = 0;

        // Restart cleanup timer
        this.startCleanupTimer();
        
        this.logger.debug('Cleared all indexes');
    }
}

================
File: task/core/indexing/index.ts
================
export * from './index-manager.js';

================
File: task/core/transactions/index.ts
================
export * from './transaction-manager.js';

================
File: task/core/transactions/transaction-manager.ts
================
/**
 * Manages atomic transactions for task operations
 */

import { Logger } from '../../../logging/index.js';
import { TaskStorage } from '../../../types/storage.js';
import { ErrorCodes, createError } from '../../../errors/index.js';
import { 
    Transaction,
    Operation,
    TransactionResult,
    TransactionOptions,
    DEFAULT_TRANSACTION_OPTIONS
} from '../../../types/transaction.js';
import { TransactionManager as StorageTransactionManager } from '../../../storage/core/transactions/manager.js';

export class TransactionManager {
    private readonly logger: Logger;
    private activeTransactions: Map<string, Transaction>;
    private transactionCounter: number;
    private readonly storageTransactionManager: StorageTransactionManager;
    private transactionTimeouts: Map<string, NodeJS.Timeout>;
    private static instance: TransactionManager | null = null;

    private constructor(private readonly storage?: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TaskTransactionManager' });
        this.activeTransactions = new Map();
        this.transactionTimeouts = new Map();
        this.transactionCounter = 0;
        this.storageTransactionManager = StorageTransactionManager.getInstance();
    }

    static getInstance(storage?: TaskStorage): TransactionManager {
        if (!TransactionManager.instance) {
            TransactionManager.instance = new TransactionManager(storage);
        }
        return TransactionManager.instance;
    }

    /**
     * Begins a new transaction
     */
    async begin(options: TransactionOptions = {}): Promise<Transaction> {
        const mergedOptions = { ...DEFAULT_TRANSACTION_OPTIONS, ...options };
        const id = this.generateTransactionId();
        const transaction: Transaction = {
            id,
            operations: [],
            timestamp: Date.now(),
            status: 'pending',
            timeout: mergedOptions.timeout,
            metadata: {
                retryCount: 0
            }
        };

        // Set up transaction timeout
        if (mergedOptions.timeout) {
            const timeoutHandle = setTimeout(() => {
                this.handleTransactionTimeout(id).catch(error => {
                    this.logger.error('Failed to handle transaction timeout', {
                        error,
                        transactionId: id
                    });
                });
            }, mergedOptions.timeout);
            
            this.transactionTimeouts.set(id, timeoutHandle);
        }

        try {
            // Acquire lock if required
            if (mergedOptions.requireLock) {
                await this.acquireLock(id);
            }

            // Start storage-level transaction
            if (this.storage && 'db' in this.storage) {
                await this.storageTransactionManager.beginTransaction((this.storage as any).db);
            }

            this.activeTransactions.set(id, transaction);
            
            this.logger.debug('Transaction started', { 
                transactionId: id,
                timestamp: transaction.timestamp,
                options: mergedOptions
            });

            return transaction;
        } catch (error) {
            this.logger.error('Failed to begin transaction', {
                error,
                transactionId: id
            });
            throw createError(
                ErrorCodes.TRANSACTION_ERROR,
                'Failed to begin transaction',
                String(error)
            );
        }
    }

    /**
     * Commits a transaction
     */
    async commit(transaction: Transaction, retryOnError: boolean = true): Promise<TransactionResult> {
        try {
            const startTime = Date.now();

            // Validate transaction state
            this.validateTransactionState(transaction);

            // Clear timeout if exists
            this.clearTransactionTimeout(transaction.id);

            try {
                // Persist and commit transaction
                if (this.storage && 'db' in this.storage) {
                    await this.persistTransaction(transaction);
                    await this.storageTransactionManager.commitTransaction(
                        (this.storage as any).db,
                        transaction.id
                    );
                }

                transaction.status = 'committed';
                this.activeTransactions.delete(transaction.id);

                const duration = Date.now() - startTime;
                this.logger.debug('Transaction committed', { 
                    transactionId: transaction.id,
                    operationCount: transaction.operations.length,
                    duration
                });

                return {
                    success: true,
                    transactionId: transaction.id,
                    metadata: {
                        duration,
                        retryCount: transaction.metadata?.retryCount
                    }
                };
            } catch (error) {
                // Retry logic for transient errors
                if (retryOnError && 
                    transaction.metadata?.retryCount! < DEFAULT_TRANSACTION_OPTIONS.retryLimit! &&
                    this.isRetryableError(error)) {
                    
                    transaction.metadata!.retryCount!++;
                    await new Promise(resolve => 
                        setTimeout(resolve, DEFAULT_TRANSACTION_OPTIONS.retryDelay));
                    
                    return this.commit(transaction, true);
                }

                throw error;
            }
        } catch (error) {
            this.logger.error('Failed to commit transaction', { 
                error,
                transactionId: transaction.id 
            });

            await this.rollback(transaction);

            return {
                success: false,
                transactionId: transaction.id,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }

    /**
     * Rolls back a transaction
     */
    async rollback(transaction: Transaction): Promise<TransactionResult> {
        try {
            if (!this.activeTransactions.has(transaction.id)) {
                throw createError(
                    ErrorCodes.INVALID_STATE,
                    `Transaction ${transaction.id} not found`
                );
            }

            // Rollback storage-level transaction first
            if (this.storage && 'db' in this.storage) {
                await this.storageTransactionManager.rollbackTransaction(
                    (this.storage as any).db,
                    transaction.id
                );
            }

            // Then reverse operations in reverse order
            for (const operation of [...transaction.operations].reverse()) {
                await this.rollbackOperation(operation);
            }

            transaction.status = 'rolled_back';
            this.activeTransactions.delete(transaction.id);

            this.logger.debug('Transaction rolled back', { 
                transactionId: transaction.id,
                operationCount: transaction.operations.length 
            });

            return {
                success: true,
                transactionId: transaction.id
            };
        } catch (error) {
            this.logger.error('Failed to rollback transaction', { 
                error,
                transactionId: transaction.id 
            });

            // Even if application-level rollback fails, ensure storage transaction is rolled back
            if (this.storage && 'db' in this.storage) {
                try {
                    await this.storageTransactionManager.rollbackTransaction(
                        (this.storage as any).db,
                        transaction.id
                    );
                } catch (rollbackError) {
                    this.logger.error('Failed to rollback storage transaction', {
                        error: rollbackError,
                        transactionId: transaction.id
                    });
                }
            }

            return {
                success: false,
                transactionId: transaction.id,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }

    /**
     * Gets active transaction by ID
     */
    getTransaction(id: string): Transaction | undefined {
        return this.activeTransactions.get(id);
    }

    /**
     * Generates a unique transaction ID
     */
    private generateTransactionId(): string {
        this.transactionCounter++;
        return `txn_${Date.now()}_${this.transactionCounter}_${Math.random().toString(36).substr(2, 9)}`;
    }

    private async handleTransactionTimeout(transactionId: string): Promise<void> {
        const transaction = this.activeTransactions.get(transactionId);
        if (!transaction) return;

        this.logger.warn('Transaction timeout', {
            transactionId,
            duration: Date.now() - transaction.timestamp
        });

        try {
            await this.rollback(transaction);
        } finally {
            this.clearTransactionTimeout(transactionId);
        }
    }

    private clearTransactionTimeout(transactionId: string): void {
        const timeout = this.transactionTimeouts.get(transactionId);
        if (timeout) {
            clearTimeout(timeout);
            this.transactionTimeouts.delete(transactionId);
        }
    }

    private validateTransactionState(transaction: Transaction): void {
        if (!this.activeTransactions.has(transaction.id)) {
            throw createError(
                ErrorCodes.INVALID_STATE,
                `Transaction ${transaction.id} not found`
            );
        }

        if (transaction.status !== 'pending') {
            throw createError(
                ErrorCodes.INVALID_STATE,
                `Transaction ${transaction.id} is already ${transaction.status}`
            );
        }
    }

    private async acquireLock(transactionId: string): Promise<void> {
        // Implement distributed locking mechanism here
        // Could use Redis, ZooKeeper, or other lock service
        this.logger.debug('Lock acquired', { transactionId });
    }

    private isRetryableError(error: any): boolean {
        // Add logic to determine if error is transient
        return error.code === 'SQLITE_BUSY' || 
               error.code === 'SQLITE_LOCKED' ||
               error.message.includes('deadlock');
    }

    /**
     * Persists a transaction to storage
     */
    private async persistTransaction(transaction: Transaction): Promise<void> {
        if (!this.storage) return;

        try {
            // Implementation depends on storage interface
            // Could store in a transactions table or log
            this.logger.debug('Transaction persisted', { 
                transactionId: transaction.id 
            });
        } catch (error) {
            this.logger.error('Failed to persist transaction', { 
                error,
                transactionId: transaction.id 
            });
            throw error;
        }
    }

    /**
     * Rolls back a single operation
     */
    private async rollbackOperation(operation: Operation): Promise<void> {
        if (!this.storage) return;

        try {
            switch (operation.type) {
                case 'delete':
                    // Restore deleted tasks
                    if (operation.tasks && operation.tasks.length > 0) {
                        await this.storage.saveTasks(operation.tasks);
                    }
                    break;

                case 'update':
                    // Revert task to previous state
                    if (operation.previousState && operation.path) {
                        await this.storage.updateTask(operation.path, operation.previousState);
                    }
                    break;

                case 'create':
                    // Delete created task
                    if (operation.task) {
                        await this.storage.deleteTasks([operation.task.path]);
                    }
                    break;
            }
        } catch (error) {
            this.logger.error('Failed to rollback operation', { 
                error,
                operationType: operation.type 
            });
            throw error;
        }
    }
}

================
File: task/core/index.ts
================
/**
 * Task Core Module
 * 
 * Provides core task management functionality:
 * - Task storage and persistence
 * - Dependency validation
 * - Status management
 */

export * from './task-store.js';

================
File: task/core/task-store.ts
================
/**
 * Path-based task storage with caching, indexing, and transaction support
 */
import { Task, TaskStatus, getParentPath } from '../../types/task.js';
import { isValidTaskHierarchy } from '../validation/index.js';
import { PathValidator } from '../../validation/index.js';
import { TaskStorage } from '../../types/storage.js';
import { Logger } from '../../logging/index.js';
import { TaskIndexManager } from './indexing/index-manager.js';
import { CacheManager } from './cache/cache-manager.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionManager } from './transactions/transaction-manager.js';

const BATCH_SIZE = 50; // Maximum number of tasks to process in parallel

export class TaskStore {
    private readonly logger: Logger;
    private readonly indexManager: TaskIndexManager;
    private readonly cacheManager: CacheManager;
    private readonly pathValidator: PathValidator;
    private nodes: Map<string, {
        path: string;
        dependencies: Set<string>;
        dependents: Set<string>;
        visited: boolean;
        inPath: boolean;
        ref: WeakRef<object>;
    }>;
    private readonly transactionManager: TransactionManager;
    private readonly HIGH_MEMORY_THRESHOLD = 0.7; // 70% memory pressure threshold
    private readonly MEMORY_CHECK_INTERVAL = 10000; // 10 seconds
    private memoryCheckInterval?: NodeJS.Timeout;

    constructor(private readonly storage: TaskStorage) {
        this.logger = Logger.getInstance().child({ component: 'TaskStore' });
        this.indexManager = new TaskIndexManager();
        this.pathValidator = new PathValidator();
        this.cacheManager = new CacheManager({
            maxSize: 500, // Reduced from 1000
            ttl: 30000, // Reduced from 60000
            maxTTL: 60000, // Reduced from 300000
            cleanupInterval: 15000 // Reduced from 30000
        });
        this.nodes = new Map();
        this.transactionManager = TransactionManager.getInstance(storage);

        // Start memory monitoring
        this.startMemoryMonitoring();
    }

    private startMemoryMonitoring(): void {
        this.memoryCheckInterval = setInterval(() => {
            const memoryUsage = process.memoryUsage();
            const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;

            this.logger.debug('Memory usage', {
                heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
                heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
                external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
                arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
                nodeCount: this.nodes.size,
                activeNodes: Array.from(this.nodes.keys()).length
            });

            if (heapUsed > this.HIGH_MEMORY_THRESHOLD) {
                this.logger.warn('High memory usage detected in TaskStore', {
                    heapUsed: `${(heapUsed * 100).toFixed(1)}%`
                });
                
                // Force cleanup
                this.cleanupResources(true);
                
                // Force GC if available
                if (global.gc) {
                    global.gc();
                }
            }
        }, this.MEMORY_CHECK_INTERVAL);

        // Ensure cleanup on process exit
        process.once('beforeExit', () => {
            if (this.memoryCheckInterval) {
                clearInterval(this.memoryCheckInterval);
                this.memoryCheckInterval = undefined;
            }
        });
    }

    private async cleanupResources(force: boolean = false): Promise<void> {
        try {
            const startTime = Date.now();
            let cleanedCount = 0;

            // Clean up nodes whose refs have been collected
            for (const [path, node] of this.nodes.entries()) {
                if (!node.ref.deref() || force) {
                    this.nodes.delete(path);
                    cleanedCount++;
                }
            }

            // Force garbage collection if needed
            if (global.gc && (force || cleanedCount > 0)) {
                global.gc();
            }

            const endTime = Date.now();
            this.logger.info('Resource cleanup completed', {
                duration: endTime - startTime,
                cleanedCount,
                remainingNodes: this.nodes.size,
                memoryUsage: this.getMemoryMetrics()
            });
        } catch (error) {
            this.logger.error('Error during resource cleanup', { error });
        }
    }

    private getMemoryMetrics(): Record<string, string> {
        const memoryUsage = process.memoryUsage();
        return {
            heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
            heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
            rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
            external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
            arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
            heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
        };
    }

    /**
     * Processes tasks in batches with memory-efficient processing
     */
    private async processBatch<T>(
        items: T[],
        processor: (item: T) => Promise<void>
    ): Promise<void> {
        // Process in smaller chunks to avoid memory spikes
        const chunkSize = Math.min(BATCH_SIZE, 10);
        for (let i = 0; i < items.length; i += chunkSize) {
            const chunk = items.slice(i, i + chunkSize);
            
            // Process items sequentially in chunk to reduce memory pressure
            for (const item of chunk) {
                await processor(item);
            }

            // Allow GC between chunks
            if (i > 0 && i % (chunkSize * 5) === 0) {
                if (global.gc) {
                    global.gc();
                }
            }
        }
    }

    /**
     * Gets a task by path, checking cache first
     */
    private async getTaskByPath(path: string): Promise<Task | null> {
        const pathResult = this.pathValidator.validatePath(path);
        if (!pathResult.isValid) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                pathResult.error || `Invalid task path: ${path}`
            );
        }

        // Check cache first
        const cachedTask = await this.cacheManager.get<Task>(path);
        if (cachedTask) {
            return cachedTask;
        }

        // Check index
        const indexedTask = await this.indexManager.getTaskByPath(path);
        if (indexedTask) {
            await this.cacheManager.set(path, indexedTask);
            return indexedTask;
        }

        // Load from storage
        const task = await this.storage.getTask(path);
        if (task) {
            await this.cacheManager.set(path, task);
            await this.indexManager.indexTask(task);
        }

        return task;
    }

    /**
     * Updates dependent task statuses
     */
    private async updateDependentStatuses(task: Task): Promise<void> {
        const dependentTasks = await this.indexManager.getDependentTasks(task.path);
        
        for (const depTask of dependentTasks) {
            const taskPath = depTask.path;
            const updatedTask = await this.getTaskByPath(taskPath);
            if (!updatedTask) continue;

            // If a dependency fails or is blocked, block the dependent task
            if (task.status === TaskStatus.FAILED || task.status === TaskStatus.BLOCKED) {
                updatedTask.status = TaskStatus.BLOCKED;
                await this.saveTasks([updatedTask]);
            }
            // If all dependencies are complete, unblock the dependent task
            else if (task.status === TaskStatus.COMPLETED) {
                const allDepsCompleted = await this.checkAllDependenciesCompleted(updatedTask);
                if (allDepsCompleted) {
                    updatedTask.status = TaskStatus.PENDING;
                    await this.saveTasks([updatedTask]);
                }
            }
        }
    }

    /**
     * Checks if all dependencies are completed
     */
    private async checkAllDependenciesCompleted(task: Task): Promise<boolean> {
        for (const depPath of task.dependencies) {
            const depTask = await this.getTaskByPath(depPath);
            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
                return false;
            }
        }
        return true;
    }

    /**
     * Saves tasks with validation, indexing, and transaction support
     */
    async saveTasks(tasks: Task[]): Promise<void> {
        // Validate paths and collect parent updates
        for (const task of tasks) {
            const pathResult = this.pathValidator.validatePath(task.path);
            if (!pathResult.isValid) {
                throw createError(
                    ErrorCodes.TASK_INVALID_PATH,
                    pathResult.error || `Invalid task path: ${task.path}`
                );
            }
        }

        const transaction = await this.transactionManager.begin();

        try {
            // First pass: validate all tasks and collect parent paths
            const parentPaths = new Set<string>();
            const tasksToSave = new Map<string, Task>();

            for (const task of tasks) {
                // Ensure task has required arrays
                if (!task.subtasks) task.subtasks = [];
                if (!task.dependencies) task.dependencies = [];

                // Get and validate parent path
                const parentPath = task.parentPath || getParentPath(task.path);
                if (parentPath) {
                    task.parentPath = parentPath;
                    parentPaths.add(parentPath);
                }

                tasksToSave.set(task.path, task);
            }

            // Second pass: load and validate all parents
            const parentUpdates = new Map<string, Task>();
            for (const parentPath of parentPaths) {
                const parent = await this.getTaskByPath(parentPath);
                if (!parent) {
                    throw createError(
                        ErrorCodes.TASK_PARENT_NOT_FOUND,
                        `Parent task not found: ${parentPath}. Parent tasks must be created before their children.`
                    );
                }
                parentUpdates.set(parentPath, parent);
            }

            // Third pass: validate relationships and update parent subtasks
            for (const task of tasksToSave.values()) {
                // Get the original task to check if parentPath has changed
                const originalTask = await this.getTaskByPath(task.path);
                
                // If task exists and parentPath has changed, remove from old parent
                if (originalTask && originalTask.parentPath && originalTask.parentPath !== task.parentPath) {
                    const oldParent = await this.getTaskByPath(originalTask.parentPath);
                    if (oldParent) {
                        oldParent.subtasks = oldParent.subtasks.filter(p => p !== task.path);
                        parentUpdates.set(oldParent.path, oldParent);
                        
                        // Update old parent's index
                        await this.indexManager.unindexTask(oldParent);
                        await this.indexManager.indexTask(oldParent);
                    }
                }

                // Handle new parent relationship
                if (task.parentPath) {
                    const parent = parentUpdates.get(task.parentPath) || await this.getTaskByPath(task.parentPath);
                    if (!parent) {
                        throw createError(
                            ErrorCodes.TASK_PARENT_NOT_FOUND,
                            `Parent task not found: ${task.parentPath}. Parent tasks must be created before their children.`
                        );
                    }

                    // Validate task type hierarchy
                    if (!isValidTaskHierarchy(parent.type, task.type)) {
                        throw createError(
                            ErrorCodes.TASK_PARENT_TYPE,
                            `Invalid parent-child relationship: ${parent.type} cannot contain ${task.type}`
                        );
                    }

                    // Update and index parent's subtasks if needed
                    if (!parent.subtasks.includes(task.path)) {
                        parent.subtasks = [...parent.subtasks, task.path];
                        parentUpdates.set(parent.path, parent);
                        
                        // Ensure parent-child relationship is indexed
                        await this.indexManager.unindexTask(parent);
                        await this.indexManager.indexTask(parent);
                    }
                }
            }

            // Prepare final task list with updated relationships
            const allTasks = [...parentUpdates.values(), ...tasksToSave.values()];
            await this.storage.saveTasks(allTasks);

            // Clear cache for all affected tasks
            await Promise.all(allTasks.map(task => this.cacheManager.delete(task.path)));

            // Reindex all tasks to ensure relationships are properly established
            for (const task of allTasks) {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
            }

            // Validate dependencies for original tasks
            for (const task of tasks) {
                await this.validateDependencies(task.path, task.dependencies);
            }

            // Propagate status changes
            await this.processBatch(tasks, async task => {
                await this.updateDependentStatuses(task);
            });

            await this.transactionManager.commit(transaction);

            this.logger.debug('Tasks saved successfully', {
                count: tasks.length,
                paths: tasks.map(t => t.path)
            });
        } catch (error) {
            // Rollback transaction
            await this.transactionManager.rollback(transaction);

            // Rollback cache and indexes
            await this.processBatch(tasks, async task => {
                await this.indexManager.unindexTask(task);
                await this.cacheManager.delete(task.path);
            });

            this.logger.error('Failed to save tasks', { error, tasks });
            throw error;
        }
    }

    /**
     * Gets tasks by path pattern with efficient caching
     */
    async getTasksByPattern(pattern: string): Promise<Task[]> {
        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getProjectTasks(pattern);
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get<Task>(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getTasksByPattern(pattern);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get tasks by pattern', { error, pattern });
            throw error;
        }
    }

    /**
     * Gets tasks by status with efficient caching
     */
    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getTasksByStatus(status, '');
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get<Task>(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getTasksByStatus(status);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get tasks by status', { error, status });
            throw error;
        }
    }

    /**
     * Gets subtasks of a task with efficient caching
     */
    async getSubtasks(parentPath: string): Promise<Task[]> {
        const pathResult = this.pathValidator.validatePath(parentPath);
        if (!pathResult.isValid) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                pathResult.error || `Invalid parent path: ${parentPath}`
            );
        }

        try {
            // Get indexed tasks first
            const indexedTasks = await this.indexManager.getTasksByParent(parentPath);
            
            // Batch process cache checks
            const tasks: Task[] = [];
            const missingPaths: string[] = [];

            await this.processBatch(indexedTasks, async indexedTask => {
                const cachedTask = await this.cacheManager.get<Task>(indexedTask.path);
                if (cachedTask) {
                    tasks.push(cachedTask);
                } else {
                    missingPaths.push(indexedTask.path);
                }
            });

            // If all tasks were cached, return them
            if (missingPaths.length === 0) {
                return tasks;
            }

            // Load missing tasks from storage
            const storageTasks = await this.storage.getSubtasks(parentPath);

            // Update cache and indexes for missing tasks
            await this.processBatch(storageTasks, async task => {
                await this.indexManager.indexTask(task);
                await this.cacheManager.set(task.path, task);
                tasks.push(task);
            });

            return tasks;
        } catch (error) {
            this.logger.error('Failed to get subtasks', { error, parentPath });
            throw error;
        }
    }

    /**
     * Deletes a task and its subtasks with transaction support
     */
    async deleteTask(path: string): Promise<void> {
        const pathResult = this.pathValidator.validatePath(path);
        if (!pathResult.isValid) {
            throw createError(
                ErrorCodes.TASK_INVALID_PATH,
                pathResult.error || `Invalid task path: ${path}`
            );
        }

        const transaction = await this.transactionManager.begin();

        try {
            // Get task and subtasks
            const task = await this.storage.getTask(path);
            if (!task) {
                throw createError(
                    ErrorCodes.TASK_NOT_FOUND,
                    `Task not found: ${path}`
                );
            }

            const subtasks = await this.storage.getSubtasks(path);
            const allTasks = [task, ...subtasks];
            const allPaths = allTasks.map(t => t.path);

            // Add delete operation to transaction
            for (const taskPath of allPaths) {
                transaction.operations.push({
                    id: `delete-${Date.now()}-${Math.random()}`,
                    type: 'delete',
                    timestamp: Date.now(),
                    path: taskPath,
                    tasks: allTasks
                });
            }

            // Delete from storage
            await this.storage.deleteTasks(allPaths);

            // Update cache and indexes
            await this.processBatch(allTasks, async task => {
                await this.indexManager.unindexTask(task);
                await this.cacheManager.delete(task.path);
            });

            // Update dependent tasks
            await this.processBatch(allTasks, async task => {
                await this.updateDependentStatuses(task);
            });

            await this.transactionManager.commit(transaction);

            this.logger.debug('Task and subtasks deleted', {
                path,
                subtaskCount: subtasks.length
            });
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to delete task', { error, path });
            throw error;
        }
    }

    /**
     * Clears all tasks and resets indexes
     */
    async clearAllTasks(confirm: boolean): Promise<void> {
        if (!confirm) {
            throw createError(
                ErrorCodes.OPERATION_FAILED,
                'Must explicitly confirm task deletion'
            );
        }

        const transaction = await this.transactionManager.begin();

        try {
            // Clear all tasks from storage
            await this.storage.clearAllTasks();
            
            // Clear cache and indexes
            await Promise.all([
                this.indexManager.clear(),
                this.cacheManager.clear()
            ]);

            await this.transactionManager.commit(transaction);
            this.logger.info('All tasks and indexes cleared');
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to clear tasks', { error });
            throw error;
        }
    }

    /**
     * Optimizes database storage and performance
     */
    async vacuumDatabase(analyze: boolean = true): Promise<void> {
        try {
            await this.storage.vacuum();
            if (analyze) {
                await this.storage.analyze();
            }
            await this.storage.checkpoint();
            this.logger.info('Database optimized', { analyzed: analyze });
        } catch (error) {
            this.logger.error('Failed to optimize database', { error });
            throw error;
        }
    }

    /**
     * Repairs parent-child relationships and fixes inconsistencies
     */
    async repairRelationships(dryRun: boolean = false, pathPattern?: string): Promise<{ fixed: number, issues: string[] }> {
        const transaction = await this.transactionManager.begin();

        try {
            // Get tasks to repair
            const tasks = pathPattern ? 
                await this.getTasksByPattern(pathPattern) :
                await this.storage.getTasks([]);

            // Clear cache for affected tasks
            await Promise.all(tasks.map(task => this.cacheManager.delete(task.path)));

            // Repair relationships
            const result = await this.storage.repairRelationships(dryRun);

            if (!dryRun) {
                // Reindex all tasks after repair
                await Promise.all(tasks.map(task => this.indexManager.indexTask(task)));
            }

            await this.transactionManager.commit(transaction);
            return result;
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to repair relationships', { error });
            throw error;
        }
    }

    /**
     * Clears cache and indexes
     */
    async clearCache(): Promise<void> {
        const transaction = await this.transactionManager.begin();

        try {
            await Promise.all([
                this.indexManager.clear(),
                this.cacheManager.clear()
            ]);

            await this.transactionManager.commit(transaction);
            this.logger.debug('Cache cleared');
        } catch (error) {
            await this.transactionManager.rollback(transaction);
            this.logger.error('Failed to clear cache', { error });
            throw error;
        }
    }

    /**
     * Validates task dependencies
     */
    private async validateDependencies(taskPath: string, dependencies: string[]): Promise<void> {
        try {
            // Pre-validate dependencies exist
            await this.preValidateDependencies(dependencies);

            // Reset validation state
            this.nodes.clear();

            // Build dependency graph
            await this.buildDependencyGraph(taskPath, dependencies);

            // Check for cycles
            this.detectCycles(taskPath);

            // Validate dependency statuses
            await this.validateDependencyStatuses();

            this.logger.debug('Dependencies validated successfully', {
                taskPath,
                dependencies,
                validationSteps: [
                    'pre-validation',
                    'graph-building',
                    'cycle-detection',
                    'status-validation'
                ]
            });
        } catch (error) {
            this.logger.error('Dependency validation failed', {
                taskPath,
                dependencies,
                error
            });
            throw error;
        }
    }

    /**
     * Pre-validates all dependencies exist before building the graph
     */
    private async preValidateDependencies(dependencies: string[]): Promise<void> {
        const missingDeps: string[] = [];
        
        for (const depPath of dependencies) {
            const depTask = await this.getTaskByPath(depPath);
            if (!depTask) {
                missingDeps.push(depPath);
            }
        }

        if (missingDeps.length > 0) {
            throw createError(
                ErrorCodes.TASK_NOT_FOUND,
                'One or more dependency tasks not found',
                'preValidateDependencies',
                'Ensure all dependency tasks exist before creating relationships',
                {
                    missingDependencies: missingDeps,
                    totalDependencies: dependencies.length
                }
            );
        }
    }

    /**
     * Builds the dependency graph
     */
    private async buildDependencyGraph(taskPath: string, dependencies: string[]): Promise<void> {
        try {
            // Create node for current task
            const node = this.getOrCreateNode(taskPath);

            // Process each dependency
            for (const depPath of dependencies) {
                const depTask = await this.getTaskByPath(depPath);
                if (!depTask) {
                    // This shouldn't happen due to pre-validation, but handle just in case
                    throw createError(
                        ErrorCodes.TASK_NOT_FOUND,
                        'Dependency task not found during graph building',
                        'buildDependencyGraph',
                        undefined,
                        {
                            taskPath,
                            dependencyPath: depPath,
                            graphState: this.getGraphState()
                        }
                    );
                }

                // Add dependency relationship
                node.dependencies.add(depPath);
                const depNode = this.getOrCreateNode(depPath);
                depNode.dependents.add(taskPath);

                // Process transitive dependencies
                await this.buildDependencyGraph(depPath, depTask.dependencies);
            }
        } catch (error) {
            this.logger.error('Error building dependency graph', {
                taskPath,
                dependencies,
                error,
                graphState: this.getGraphState()
            });
            throw error;
        }
    }

    /**
     * Detects cycles in the dependency graph
     */
    private detectCycles(startPath: string): void {
        const node = this.nodes.get(startPath);
        if (!node) {
            return;
        }

        node.visited = true;
        node.inPath = true;

        for (const depPath of node.dependencies) {
            const depNode = this.nodes.get(depPath);
            if (!depNode) {
                continue;
            }

            if (!depNode.visited) {
                this.detectCycles(depPath);
            } else if (depNode.inPath) {
                const cyclePath = this.getCyclePath(depPath);
                throw createError(
                    ErrorCodes.TASK_CYCLE,
                    'Circular dependency detected in task graph',
                    'detectCycles',
                    'Remove one of the dependencies to break the cycle',
                    {
                        cyclePath,
                        startPath,
                        affectedTasks: Array.from(this.nodes.keys()),
                        graphState: this.getGraphState()
                    }
                );
            }
        }

        node.inPath = false;
    }

    /**
     * Gets the path of a dependency cycle
     */
    private getCyclePath(startPath: string): string {
        const cycle: string[] = [startPath];
        let current = startPath;

        while (true) {
            const node = this.nodes.get(current);
            if (!node) {
                break;
            }

            for (const depPath of node.dependencies) {
                const depNode = this.nodes.get(depPath);
                if (depNode?.inPath) {
                    cycle.push(depPath);
                    if (depPath === startPath) {
                        return cycle.join(' -> ');
                    }
                    current = depPath;
                    break;
                }
            }
        }

        return cycle.join(' -> ');
    }

    /**
     * Validates dependency task statuses
     */
    private async validateDependencyStatuses(): Promise<void> {
        const statusIssues: Array<{ path: string; status: TaskStatus; issue: string }> = [];

        for (const [path] of this.nodes) {
            const task = await this.getTaskByPath(path);
            if (!task) {
                continue;
            }

            if (task.status === TaskStatus.FAILED) {
                statusIssues.push({
                    path,
                    status: task.status,
                    issue: 'Task has failed'
                });
            }

            if (task.status === TaskStatus.BLOCKED) {
                statusIssues.push({
                    path,
                    status: task.status,
                    issue: 'Task is blocked'
                });
            }
        }

        if (statusIssues.length > 0) {
            throw createError(
                ErrorCodes.TASK_DEPENDENCY,
                'Dependency status validation failed',
                'validateDependencyStatuses',
                'Ensure all dependencies are in a valid state before proceeding',
                {
                    statusIssues,
                    graphState: this.getGraphState()
                }
            );
        }
    }

    /**
     * Gets or creates a dependency node
     */
    private getOrCreateNode(path: string): {
        path: string;
        dependencies: Set<string>;
        dependents: Set<string>;
        visited: boolean;
        inPath: boolean;
        ref: WeakRef<object>;
    } {
        let node = this.nodes.get(path);
        if (!node) {
            const obj = { path }; // Create object to track via WeakRef
            node = {
                path,
                dependencies: new Set(),
                dependents: new Set(),
                visited: false,
                inPath: false,
                ref: new WeakRef(obj)
            };
            this.nodes.set(path, node);
        }
        return node;
    }

    /**
     * Gets the current state of the dependency graph for debugging
     */
    private getGraphState(): Record<string, unknown> {
        return Object.fromEntries(
            Array.from(this.nodes.entries()).map(([path, node]) => [
                path,
                {
                    dependencies: Array.from(node.dependencies),
                    dependents: Array.from(node.dependents),
                    visited: node.visited,
                    inPath: node.inPath,
                    hasRef: node.ref.deref() !== undefined
                }
            ])
        );
    }
}

================
File: task/operations/index.ts
================
import { TaskOperations } from './task-operations.js';

export {
    TaskOperations
};

================
File: task/operations/task-operations.ts
================
import { Logger } from '../../logging/index.js';
import { EventManager } from '../../events/event-manager.js';
import { EventTypes } from '../../types/events.js';
import { TaskStorage } from '../../types/storage.js';
import { Task, TaskStatus, TaskType, CreateTaskInput, UpdateTaskInput } from '../../types/task.js';
import { TaskValidator } from '../validation/task-validator.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { TransactionManager } from '../core/transactions/transaction-manager.js';
import { StatusUpdateBatch } from '../core/batch/status-update-batch.js';

interface TaskEvent {
  type: EventTypes;
  timestamp: number;
  taskId: string;
  task: Task;
  metadata?: Record<string, any>;
  changes?: {
    before: Partial<Task>;
    after: Partial<Task>;
  };
}

export class TaskOperations {
  private readonly logger: Logger;
  private readonly eventManager: EventManager;
  private readonly transactionManager: TransactionManager;
  private readonly eventSubscriptions: Map<string, { unsubscribe: () => void }> = new Map();
  private readonly HIGH_MEMORY_THRESHOLD = 0.7; // 70% memory pressure threshold
  private readonly MEMORY_CHECK_INTERVAL = 10000; // 10 seconds
  private memoryCheckInterval?: NodeJS.Timeout;
  private isShuttingDown = false;
  private static instance: TaskOperations | null = null;
  private static initializationPromise: Promise<TaskOperations> | null = null;
  private initialized = false;
  private readonly statusUpdateBatch: StatusUpdateBatch;

    private constructor(
        private readonly storage: TaskStorage,
        private readonly validator: TaskValidator
    ) {
        this.logger = Logger.getInstance().child({ component: 'TaskOperations' });
        this.eventManager = EventManager.getInstance();
        this.transactionManager = TransactionManager.getInstance(storage);
        this.statusUpdateBatch = new StatusUpdateBatch(storage);
        
        // Setup event listeners
        this.setupEventListeners();

        // Setup memory monitoring
        this.startMemoryMonitoring();
        
        // Log initial memory state
        this.logMemoryUsage('Initialization');
    }

  /**
   * Gets the TaskOperations instance
   */
  static async getInstance(storage: TaskStorage, validator: TaskValidator): Promise<TaskOperations> {
    // Return existing instance if available
    if (TaskOperations.instance && TaskOperations.instance.initialized) {
      return TaskOperations.instance;
    }

    // If initialization is in progress, wait for it
    if (TaskOperations.initializationPromise) {
      return TaskOperations.initializationPromise;
    }

    // Start new initialization with mutex
    TaskOperations.initializationPromise = (async () => {
      try {
        // Double-check instance hasn't been created while waiting
        if (TaskOperations.instance && TaskOperations.instance.initialized) {
          return TaskOperations.instance;
        }

        TaskOperations.instance = new TaskOperations(storage, validator);
        await TaskOperations.instance.initialize();
        return TaskOperations.instance;
      } catch (error) {
        throw createError(
          ErrorCodes.STORAGE_INIT,
          `Failed to initialize TaskOperations: ${error instanceof Error ? error.message : String(error)}`
        );
      } finally {
        TaskOperations.initializationPromise = null;
      }
    })();

    return TaskOperations.initializationPromise;
  }

  private async initialize(): Promise<void> {
    if (this.initialized) {
      this.logger.debug('Task operations already initialized');
      return;
    }

    try {
      this.initialized = true;
      this.logger.debug('Task operations initialized');
    } catch (error) {
      this.logger.error('Failed to initialize task operations', { error });
      throw error;
    }
  }

  private setupEventListeners(): void {
    // Setup event listeners with strong references and explicit cleanup
    const setupListener = (type: EventTypes) => {
      const handler = (event: TaskEvent) => {
        this.logger.debug(`${type} event received`, { taskId: event.taskId });
      };
      const subscription = this.eventManager.on(type, handler);
      this.eventSubscriptions.set(type, subscription);
    };

    setupListener(EventTypes.TASK_CREATED);
    setupListener(EventTypes.TASK_UPDATED);
    setupListener(EventTypes.TASK_DELETED);
    setupListener(EventTypes.TASK_STATUS_CHANGED);
  }

  private startMemoryMonitoring(): void {
    // Monitor memory usage periodically
    this.memoryCheckInterval = setInterval(() => {
      const memoryUsage = process.memoryUsage();
      const heapUsed = memoryUsage.heapUsed / memoryUsage.heapTotal;

      this.logger.debug('Memory usage', {
        heapUsed: `${(heapUsed * 100).toFixed(1)}%`,
        heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
        rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
        external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
        arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`
      });

      if (heapUsed > this.HIGH_MEMORY_THRESHOLD) {
        this.logger.warn('High memory usage detected', {
          heapUsed: `${(heapUsed * 100).toFixed(1)}%`
        });
        
        // Force cleanup when memory pressure is high
        this.cleanupResources(true);
        
        // Force GC if available
        if (global.gc) {
          this.logger.info('Forcing garbage collection');
          global.gc();
        }
      }

      // Check for stale transactions
      this.cleanupStaleTransactions();
    }, this.MEMORY_CHECK_INTERVAL);

    // Ensure cleanup on process exit
    process.once('beforeExit', () => {
      if (this.memoryCheckInterval) {
        clearInterval(this.memoryCheckInterval);
        this.memoryCheckInterval = undefined;
      }
    });
  }

  private async cleanupResources(force: boolean = false): Promise<void> {
    try {
      const startTime = Date.now();
      let cleanedCount = 0;

      // Clean up event subscriptions
      if (force) {
        for (const [type, subscription] of this.eventSubscriptions.entries()) {
          subscription.unsubscribe();
          this.eventSubscriptions.delete(type);
          cleanedCount++;
        }
      }

      // Force garbage collection if available
      if (global.gc && (force || cleanedCount > 0)) {
        global.gc();
      }

      const endTime = Date.now();
      this.logger.info('Resource cleanup completed', {
        duration: endTime - startTime,
        cleanedCount,
        forced: force,
        remainingSubscriptions: this.eventSubscriptions.size,
        memoryUsage: this.getMemoryMetrics()
      });
    } catch (error) {
      this.logger.error('Error during resource cleanup', { error });
    }
  }

  private cleanupStaleTransactions(): void {
    // Transaction cleanup is now handled by TransactionManager
  }

  private getMemoryMetrics(): Record<string, string> {
    const memoryUsage = process.memoryUsage();
    return {
      heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,
      rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,
      external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`,
      arrayBuffers: `${Math.round(memoryUsage.arrayBuffers / 1024 / 1024)}MB`,
      heapUsedPercentage: `${((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100).toFixed(1)}%`
    };
  }

  private logMemoryUsage(context: string): void {
    this.logger.info(`Memory usage - ${context}`, this.getMemoryMetrics());
  }

  async cleanup(): Promise<void> {
    try {
      this.isShuttingDown = true;
      this.logMemoryUsage('Cleanup start');

      // Stop memory monitoring
      if (this.memoryCheckInterval) {
        clearInterval(this.memoryCheckInterval);
        this.memoryCheckInterval = undefined;
      }

      // Cleanup event subscriptions
      for (const [type, subscription] of this.eventSubscriptions.entries()) {
        subscription.unsubscribe();
        this.eventSubscriptions.delete(type);
      }

      // Force final cleanup
      await this.cleanupResources(true);

      // Final garbage collection
      if (global.gc) {
        this.logger.info('Forcing final garbage collection');
        global.gc();
      }

      this.logMemoryUsage('Cleanup end');
      this.logger.info('Task operations cleanup completed', {
        finalMetrics: {
          eventSubscriptions: this.eventSubscriptions.size,
          ...this.getMemoryMetrics()
        }
      });
    } catch (error) {
      this.logger.error('Error during task operations cleanup', { error });
      throw error;
    }
  }

  async createTask(input: CreateTaskInput): Promise<Task> {
    if (!this.initialized) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'Task operations not initialized');
    }
    if (this.isShuttingDown) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'System is shutting down');
    }

    // Set defaults
    const taskInput: CreateTaskInput = {
      ...input,
      type: input.type || TaskType.TASK // Default to TASK type if not provided
    };

    // Validate input
    await this.validator.validateCreate(taskInput);

    const transaction = await this.transactionManager.begin({
      timeout: 10000,
      requireLock: true
    });

    try {
      // Create task with processed input containing defaults
      const task = await this.storage.createTask(taskInput);

      // Add operation to transaction
      transaction.operations.push({
        id: `create-${Date.now()}`,
        type: 'create',
        timestamp: Date.now(),
        path: task.path,
        task
      });

      // Emit event
      this.eventManager.emit({
        type: EventTypes.TASK_CREATED,
        timestamp: Date.now(),
        taskId: task.path,
        task,
        metadata: { input }
      });

      await this.transactionManager.commit(transaction);
      return task;
    } catch (error) {
      await this.transactionManager.rollback(transaction);
      this.logger.error('Failed to create task', { error, input });
      throw error;
    }
  }

  async updateTask(path: string, updates: UpdateTaskInput): Promise<Task> {
    if (!this.initialized) {
      throw createError(
        ErrorCodes.OPERATION_FAILED,
        'Task operations not initialized'
      );
    }
    if (this.isShuttingDown) {
      throw createError(
        ErrorCodes.OPERATION_FAILED,
        'System is shutting down'
      );
    }

    // Get existing task
    const existingTask = await this.storage.getTask(path);
    if (!existingTask) {
      throw createError(ErrorCodes.TASK_NOT_FOUND, `Task not found: ${path}`);
    }

    // Validate updates
    await this.validator.validateUpdate(path, updates);

    const transaction = await this.transactionManager.begin({
      timeout: 10000,
      requireLock: true
    });

    try {
      // Update task with system fields
      const updatedTask = await this.storage.updateTask(path, {
        ...updates,
        version: existingTask.version + 1,
        updated: Date.now(),
        // Preserve other system fields
        created: existingTask.created,
        projectPath: existingTask.projectPath
      });

      // Add operation to transaction
      transaction.operations.push({
        id: `update-${Date.now()}`,
        type: 'update',
        timestamp: Date.now(),
        path: updatedTask.path,
        task: updatedTask,
        previousState: existingTask
      });

      // Handle status changes in batch
      if (updates.status && updates.status !== existingTask.status) {
        await this.handleStatusChange(existingTask, updatedTask);
        await this.statusUpdateBatch.execute();
      }

      // Emit update event
      this.eventManager.emit({
        type: EventTypes.TASK_UPDATED,
        timestamp: Date.now(),
        taskId: updatedTask.path,
        task: updatedTask,
        changes: {
          before: existingTask,
          after: updatedTask
        }
      });

      await this.transactionManager.commit(transaction);
      return updatedTask;
    } catch (error) {
      this.logger.error('Failed to update task', {
        error,
        path,
        updates
      });
      throw error;
    }
  }

  async deleteTask(path: string): Promise<void> {
    if (!this.initialized) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'Task operations not initialized');
    }
    if (this.isShuttingDown) {
      throw createError(ErrorCodes.OPERATION_FAILED, 'System is shutting down');
    }

    // Get existing task
    const existingTask = await this.storage.getTask(path);
    if (!existingTask) {
      throw createError(ErrorCodes.TASK_NOT_FOUND, `Task not found: ${path}`);
    }

    const transaction = await this.transactionManager.begin({
      timeout: 10000,
      requireLock: true
    });

    try {
      // Delete task
      await this.storage.deleteTask(path);

      // Add operation to transaction
      transaction.operations.push({
        id: `delete-${Date.now()}`,
        type: 'delete',
        timestamp: Date.now(),
        path: existingTask.path,
        tasks: [existingTask]
      });

      // Emit delete event
      this.eventManager.emit({
        type: EventTypes.TASK_DELETED,
        timestamp: Date.now(),
        taskId: existingTask.path,
        task: existingTask
      });

      await this.transactionManager.commit(transaction);
    } catch (error) {
      this.logger.error('Failed to delete task', {
        error,
        path
      });
      throw error;
    }
  }

  private async handleStatusChange(
    oldTask: Task,
    newTask: Task
  ): Promise<void> {
    try {
      // Clear cache before status updates
      if ('clearCache' in this.storage) {
        await (this.storage as any).clearCache();
      }

      // Emit status change event
      this.eventManager.emit({
        type: EventTypes.TASK_STATUS_CHANGED,
        timestamp: Date.now(),
        taskId: newTask.path,
        task: newTask,
        changes: {
          before: { status: oldTask.status },
          after: { status: newTask.status }
        }
      });

      // Update parent task status if needed
      if (newTask.parentPath) {
        const parent = await this.storage.getTask(newTask.parentPath);
        if (parent) {
          const siblings = await this.storage.getSubtasks(parent.path);
          const allCompleted = siblings.every(t => t.status === TaskStatus.COMPLETED);
          const anyFailed = siblings.some(t => t.status === TaskStatus.FAILED);
          const anyBlocked = siblings.some(t => t.status === TaskStatus.BLOCKED);
          const anyInProgress = siblings.some(t => t.status === TaskStatus.IN_PROGRESS);

          let newParentStatus = parent.status;
          if (allCompleted) {
            newParentStatus = TaskStatus.COMPLETED;
          } else if (anyFailed) {
            newParentStatus = TaskStatus.FAILED;
          } else if (anyBlocked) {
            newParentStatus = TaskStatus.BLOCKED;
          } else if (anyInProgress) {
            newParentStatus = TaskStatus.IN_PROGRESS;
          }

          if (newParentStatus !== parent.status) {
            await this.updateTask(parent.path, {
              status: newParentStatus,
              metadata: {
                ...parent.metadata,
                statusUpdatedAt: Date.now(),
                previousStatus: parent.status
              }
            });
          }
        }
      }

      // Handle blocked status
      if (newTask.status === TaskStatus.BLOCKED) {
        await this.handleBlockedStatus(newTask);
      }

      // Handle completed status
      if (newTask.status === TaskStatus.COMPLETED) {
        await this.handleCompletedStatus(newTask);
      }

      // Handle failed status
      if (newTask.status === TaskStatus.FAILED) {
        await this.handleFailedStatus(newTask);
      }
    } catch (error) {
      this.logger.error('Failed to handle status change', {
        error,
        oldStatus: oldTask.status,
        newStatus: newTask.status,
        taskPath: newTask.path
      });
      throw error;
    }
  }

  private async handleFailedStatus(task: Task): Promise<void> {
    // Block dependent tasks when a task fails
    const dependentTasks = await this.storage.getDependentTasks(task.path);
    
    for (const depTask of dependentTasks) {
      if (depTask.status !== TaskStatus.FAILED) {
        await this.updateTask(depTask.path, {
          status: TaskStatus.BLOCKED,
            metadata: {
              ...depTask.metadata,
              blockedBy: task.path,
              blockReason: `Dependency task ${task.path} failed`,
              blockTimestamp: Date.now()
            }
        });
      }
    }
  }

  private async handleBlockedStatus(task: Task): Promise<void> {
    // Update dependent tasks to blocked status
    const dependentTasks = await this.storage.getDependentTasks(task.path);
    
    for (const depTask of dependentTasks) {
      if (depTask.status !== TaskStatus.BLOCKED) {
        await this.updateTask(depTask.path, {
          status: TaskStatus.BLOCKED,
            metadata: {
              ...depTask.metadata,
              blockedBy: task.path,
              blockTimestamp: Date.now()
            }
        });
      }
    }
  }

  private async handleCompletedStatus(task: Task): Promise<void> {
    // Check if dependent tasks can be unblocked
    const dependentTasks = await this.storage.getDependentTasks(task.path);
    
    for (const depTask of dependentTasks) {
      if (depTask.status === TaskStatus.BLOCKED) {
        // Check if all dependencies are completed
        const allDepsCompleted = await this.areAllDependenciesCompleted(depTask);
        
        if (allDepsCompleted) {
          await this.updateTask(depTask.path, {
            status: TaskStatus.PENDING,
            metadata: {
              ...depTask.metadata,
              blockedBy: undefined,
              blockTimestamp: undefined,
              unblockTimestamp: Date.now()
            }
          });
        }
      }
    }
  }

  private async areAllDependenciesCompleted(task: Task): Promise<boolean> {
    for (const depPath of task.dependencies) {
      const depTask = await this.storage.getTask(depPath);
      if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
        return false;
      }
    }
    return true;
  }
}

================
File: task/validation/index.ts
================
/**
 * Task validation module exports
 * Provides a centralized point for all task validation functionality
 */

import { z } from 'zod';
import { ValidationResult } from '../../types/index.js';

/**
 * Convert Zod validation error to ValidationResult format
 */
export function formatZodError(error: z.ZodError): ValidationResult {
    return {
        success: false,
        errors: error.errors.map(err => ({
            path: err.path.map(String),
            message: err.message,
            received: err instanceof z.ZodError ? err.code : undefined,
            expected: getExpectedValue(err)
        }))
    };
}

/**
 * Get expected value from Zod error
 */
function getExpectedValue(error: z.ZodIssue): string | undefined {
    switch (error.code) {
        case z.ZodIssueCode.invalid_type:
            return error.expected;
        case z.ZodIssueCode.invalid_enum_value:
            return error.options.join(' | ');
        case z.ZodIssueCode.too_small:
            return `${error.type === 'string' ? 'length' : 'value'} >= ${error.minimum}`;
        case z.ZodIssueCode.too_big:
            return `${error.type === 'string' ? 'length' : 'value'} <= ${error.maximum}`;
        default:
            return undefined;
    }
}

/**
 * Create a safe validator function that returns ValidationResult
 */
export function createSafeValidator<T>(schema: z.ZodType<T>) {
    return (value: unknown): ValidationResult & { value?: T } => {
        const result = schema.safeParse(value);
        if (result.success) {
            return {
                success: true,
                data: result.data
            };
        } else {
            return formatZodError(result.error);
        }
    };
}

/**
 * Create a validator function that throws on invalid input
 */
export function createValidator<T>(schema: z.ZodType<T>) {
    return (value: unknown): T => schema.parse(value);
}

/**
 * Validation error messages
 */
export const ValidationErrorMessages = {
    INVALID_INPUT: 'Invalid input provided',
    VALIDATION_FAILED: 'Validation failed',
    TYPE_ERROR: 'Type validation failed',
    CONSTRAINT_ERROR: 'Constraint validation failed',
    REQUIRED_FIELD: 'Required field is missing',
    INVALID_FORMAT: 'Invalid format',
    INVALID_VALUE: 'Invalid value provided',
    OUT_OF_RANGE: 'Value is out of allowed range',
    PATTERN_MISMATCH: 'Value does not match required pattern',
    UNIQUE_VIOLATION: 'Value must be unique',
    REFERENCE_ERROR: 'Invalid reference',
    CUSTOM_ERROR: 'Custom validation failed'
} as const;

/**
 * Validation utilities
 */
export const ValidationUtils = {
    /**
     * Check if a value is defined (not null or undefined)
     */
    isDefined: <T>(value: T | null | undefined): value is T => {
        return value !== null && value !== undefined;
    },

    /**
     * Check if a value is a non-empty string
     */
    isNonEmptyString: (value: unknown): value is string => {
        return typeof value === 'string' && value.trim().length > 0;
    },

    /**
     * Check if a value is a valid number
     */
    isValidNumber: (value: unknown): value is number => {
        return typeof value === 'number' && !isNaN(value) && isFinite(value);
    },

    /**
     * Check if a value is a valid integer
     */
    isValidInteger: (value: unknown): value is number => {
        return ValidationUtils.isValidNumber(value) && Number.isInteger(value);
    },

    /**
     * Check if a value is a valid date string
     */
    isValidDateString: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const date = new Date(value);
        return !isNaN(date.getTime());
    },

    /**
     * Check if a value is a valid UUID
     */
    isValidUUID: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(value);
    },

    /**
     * Check if a value is a valid email
     */
    isValidEmail: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(value);
    },

    /**
     * Check if a value is a valid URL
     */
    isValidURL: (value: unknown): boolean => {
        if (typeof value !== 'string') return false;
        try {
            new URL(value);
            return true;
        } catch {
            return false;
        }
    },

    /**
     * Check if an array contains only unique values
     */
    hasUniqueValues: <T>(array: T[]): boolean => {
        return new Set(array).size === array.length;
    },

    /**
     * Check if an object has all required properties
     */
    hasRequiredProperties: (obj: unknown, properties: string[]): boolean => {
        if (typeof obj !== 'object' || obj === null) return false;
        return properties.every(prop => prop in obj);
    }
} as const;

export {
    TaskValidator,
    isValidTaskHierarchy,
    validateTaskStatusTransition,
    detectDependencyCycle,
    validateTask,
    validateCreateTaskInput,
    validateUpdateTaskInput,
    validateTaskResponse
} from './task-validator.js';

================
File: task/validation/task-validator.ts
================
import { Logger } from '../../logging/index.js';
import { TaskStorage } from '../../types/storage.js';
import { CreateTaskInput, UpdateTaskInput, TaskType, TaskStatus, CONSTRAINTS, Task } from '../../types/task.js';
import { ErrorCodes, createError } from '../../errors/index.js';
import { PathValidator } from '../../validation/index.js';
import { z } from 'zod';

// Task metadata schema (user-defined fields only)
const taskMetadataSchema = z.object({
    priority: z.enum(['low', 'medium', 'high']).optional(),
    tags: z.array(z.string().max(100)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    toolsUsed: z.array(z.string().max(100)).max(100).optional(),
    resourcesAccessed: z.array(z.string().max(100)).max(100).optional(),
    contextUsed: z.array(z.string().max(1000)).max(100).optional()
}).passthrough();

// Initialize path validator for schema validation
const pathValidator = new PathValidator({
    maxDepth: CONSTRAINTS.MAX_PATH_DEPTH,
    maxLength: 1000,
    allowedCharacters: /^[a-zA-Z0-9-_/]+$/,
    projectNamePattern: /^[a-zA-Z][a-zA-Z0-9-_]*$/,
    maxProjectNameLength: 100
});

// Base task schema with system fields at root level
const baseTaskSchema = z.object({
    // System fields
    path: z.string()
        .refine(
            (path) => {
                const result = pathValidator.validatePath(path);
                return result.isValid;
            },
            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid path format' })
        ),
    name: z.string().min(1).max(200),
    type: z.nativeEnum(TaskType),
    status: z.nativeEnum(TaskStatus),
    created: z.number(),
    updated: z.number(),
    version: z.number().positive(),
    projectPath: z.string().max(1000),

    // Optional fields
    description: z.string().max(2000).optional(),
    parentPath: z.string().optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50),
    subtasks: z.array(z.string()).max(100),

    // User-defined metadata
    metadata: taskMetadataSchema
});


/**
 * Validates parent-child task type relationships
 */
export function isValidTaskHierarchy(parentType: TaskType, childType: TaskType): { valid: boolean; reason?: string } {
    switch (parentType) {
        case TaskType.MILESTONE:
            // Milestones can contain tasks and groups
            return {
                valid: childType === TaskType.TASK || childType === TaskType.GROUP,
                reason: childType !== TaskType.TASK && childType !== TaskType.GROUP ?
                    `MILESTONE can only contain TASK or GROUP types, not ${childType}` : undefined
            };
        case TaskType.GROUP:
            // Groups can contain tasks
            return {
                valid: childType === TaskType.TASK,
                reason: childType !== TaskType.TASK ?
                    `GROUP can only contain TASK type, not ${childType}` : undefined
            };
        case TaskType.TASK:
            // Tasks cannot contain other tasks
            return {
                valid: false,
                reason: `TASK type cannot contain any subtasks (attempted to add ${childType})`
            };
        default:
            return {
                valid: false,
                reason: `Unknown task type: ${parentType}`
            };
    }
}

// Create task input schema
export const createTaskSchema = z.object({
    path: z.string()
        .refine(
            (path) => {
                const result = pathValidator.validatePath(path);
                return result.isValid;
            },
            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid path format' })
        ),
    name: z.string().min(1).max(200),
    parentPath: z.string()
        .refine(
            (path) => {
                const result = pathValidator.validatePath(path);
                return result.isValid;
            },
            (path) => ({ message: pathValidator.validatePath(path).error || 'Invalid parent path format' })
        )
        .optional(),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType).optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50).optional(),
    metadata: taskMetadataSchema.optional()
});

// Update task input schema
export const updateTaskSchema = z.object({
    name: z.string().min(1).max(200).optional(),
    description: z.string().max(2000).optional(),
    type: z.nativeEnum(TaskType).optional(),
    status: z.nativeEnum(TaskStatus).optional(),
    notes: z.array(z.string().max(1000)).max(100).optional(),
    reasoning: z.string().max(2000).optional(),
    dependencies: z.array(z.string()).max(50).optional(),
    metadata: taskMetadataSchema.optional()
});

// Task response schema
export const taskResponseSchema = z.object({
    success: z.boolean(),
    data: z.unknown().optional(),
    error: z.object({
        code: z.string(),
        message: z.string()
    }).optional(),
    metadata: z.object({
        timestamp: z.number(),
        requestId: z.string(),
        projectPath: z.string(),
        affectedPaths: z.array(z.string())
    })
});

// Export type-safe validation functions
export function validateTask(task: unknown) {
    return baseTaskSchema.parse(task);
}

export function validateCreateTaskInput(input: unknown) {
    return createTaskSchema.parse(input);
}

export function validateUpdateTaskInput(input: unknown) {
    return updateTaskSchema.parse(input);
}

export function validateTaskResponse(response: unknown) {
    return taskResponseSchema.parse(response);
}

/**
 * Validates task status transitions and dependencies
 */
export async function validateTaskStatusTransition(
    task: z.infer<typeof baseTaskSchema>,
    newStatus: TaskStatus,
    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
): Promise<void> {
    // Cannot transition from COMPLETED/FAILED back to IN_PROGRESS
    if ((task.status === TaskStatus.COMPLETED || task.status === TaskStatus.FAILED) &&
        newStatus === TaskStatus.IN_PROGRESS) {
        throw createError(
            ErrorCodes.TASK_STATUS,
            `Cannot transition from ${task.status} to ${newStatus}`,
            'validateTaskStatusTransition',
            undefined,
            {
                taskPath: task.path,
                currentStatus: task.status,
                newStatus
            }
        );
    }

    // Check dependencies for COMPLETED status
    if (newStatus === TaskStatus.COMPLETED) {
        for (const depPath of task.dependencies) {
            const depTask = await getTaskByPath(depPath);
            if (!depTask || depTask.status !== TaskStatus.COMPLETED) {
                throw createError(
                    ErrorCodes.TASK_DEPENDENCY,
                    `Cannot complete task: dependency ${depPath} is not completed`,
                    'validateTaskStatusTransition',
                    undefined,
                    {
                        taskPath: task.path,
                        dependencyPath: depPath,
                        dependencyStatus: depTask?.status
                    }
                );
            }
        }
    }

    // Check dependencies for IN_PROGRESS status
    if (newStatus === TaskStatus.IN_PROGRESS) {
        const blockedByDeps = await isBlockedByDependencies(task, getTaskByPath);
        if (blockedByDeps) {
            throw createError(
                ErrorCodes.TASK_DEPENDENCY,
                'Cannot start task: blocked by incomplete dependencies',
                'validateTaskStatusTransition',
                undefined,
                {
                    taskPath: task.path,
                    dependencies: task.dependencies
                }
            );
        }
    }
}

/**
 * Checks if a task is blocked by its dependencies
 */
async function isBlockedByDependencies(
    task: z.infer<typeof baseTaskSchema>,
    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
): Promise<boolean> {
    for (const depPath of task.dependencies) {
        const depTask = await getTaskByPath(depPath);
        if (!depTask || depTask.status === TaskStatus.FAILED || 
            depTask.status === TaskStatus.BLOCKED || 
            depTask.status === TaskStatus.PENDING) {
            return true;
        }
    }
    return false;
}

/**
 * Detects circular dependencies in task relationships
 */
export async function detectDependencyCycle(
    task: z.infer<typeof baseTaskSchema>,
    newDeps: string[],
    getTaskByPath: (path: string) => Promise<z.infer<typeof baseTaskSchema> | null>
): Promise<boolean> {
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    async function dfs(currentPath: string): Promise<boolean> {
        if (recursionStack.has(currentPath)) return true;
        if (visited.has(currentPath)) return false;

        visited.add(currentPath);
        recursionStack.add(currentPath);

        const current = await getTaskByPath(currentPath);
        if (!current) return false;

        // Check both existing and new dependencies
        const allDeps = currentPath === task.path ? newDeps : current.dependencies;
        for (const depPath of allDeps) {
            if (await dfs(depPath)) return true;
        }

        recursionStack.delete(currentPath);
        return false;
    }

    return await dfs(task.path);
}

export class TaskValidator {
  private readonly logger: Logger;
  private readonly pathValidator: PathValidator;

  constructor(private readonly storage: TaskStorage) {
    this.logger = Logger.getInstance().child({ component: 'TaskValidator' });
    this.pathValidator = new PathValidator({
      maxDepth: CONSTRAINTS.MAX_PATH_DEPTH,
      maxLength: 1000,
      allowedCharacters: /^[a-zA-Z0-9-_/]+$/,
      projectNamePattern: /^[a-zA-Z][a-zA-Z0-9-_]*$/,
      maxProjectNameLength: 100
    });
  }

  async validateCreate(input: CreateTaskInput): Promise<void> {
    try {
      // Validate required fields
      if (!input.name) {
        throw createError(
          ErrorCodes.INVALID_INPUT,
          'Task name is required'
        );
      }

      // Validate task type
      if (input.type && !Object.values(TaskType).includes(input.type)) {
        throw createError(
          ErrorCodes.INVALID_INPUT,
          `Invalid task type: ${input.type}`
        );
      }

      // Validate path and parent path
      const pathResult = input.parentPath ? 
        this.pathValidator.validateTaskPath(input.path, input.parentPath) :
        this.pathValidator.validatePath(input.path);

      if (!pathResult.isValid) {
        throw createError(
          ErrorCodes.INVALID_INPUT,
          pathResult.error || 'Invalid task path'
        );
      }

      // Validate parent path if provided
      if (input.parentPath) {
        const parent = await this.storage.getTask(input.parentPath);
        if (!parent) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            `Parent task not found: ${input.parentPath}`
          );
        }

        // Validate parent-child relationship
        if (parent.type === TaskType.TASK) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            'TASK type cannot have child tasks'
          );
        }
      }

      // Validate dependencies if provided
      if (input.dependencies?.length) {
        await this.validateDependencies(input.dependencies);
      }

      // Validate metadata if provided
      if (input.metadata) {
        this.validateMetadata(input.metadata);
      }
    } catch (error) {
      this.logger.error('Task creation validation failed', {
        error,
        input
      });
      throw error;
    }
  }

  async validateUpdate(path: string, updates: UpdateTaskInput): Promise<void> {
    try {
      const existingTask = await this.storage.getTask(path);
      if (!existingTask) {
        throw createError(
          ErrorCodes.TASK_NOT_FOUND,
          `Task not found: ${path}`
        );
      }

      // Validate task type change
      if (updates.type && updates.type !== existingTask.type) {
        // Check if task has children when changing to TASK type
        if (updates.type === TaskType.TASK) {
          const hasChildren = await this.storage.hasChildren(path);
          if (hasChildren) {
            throw createError(
              ErrorCodes.INVALID_INPUT,
              'Cannot change to TASK type when task has children'
            );
          }
        }
      }

      // Validate status value and change
      if (updates.status) {
        // Validate status enum value
        if (!Object.values(TaskStatus).includes(updates.status)) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            `Invalid status value: ${updates.status}`
          );
        }
        await this.validateStatusChange(updates.status, path);
      }

      // Validate dependencies change and check for cycles
      if (updates.dependencies) {
        await this.validateDependencies(updates.dependencies);
        const hasCycle = await detectDependencyCycle(
          existingTask,
          updates.dependencies,
          this.storage.getTask.bind(this.storage)
        );
        if (hasCycle) {
          throw createError(
            ErrorCodes.TASK_CYCLE,
            'Circular dependencies detected in task relationships'
          );
        }
      }

      // Validate metadata updates with schema
      if (updates.metadata) {
        try {
          taskMetadataSchema.parse(updates.metadata);
        } catch (error) {
          throw createError(
            ErrorCodes.INVALID_INPUT,
            `Invalid metadata: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
    } catch (error) {
      this.logger.error('Task update validation failed', {
        error,
        path,
        updates
      });
      throw error;
    }
  }

  private async validateDependencies(dependencies: string[]): Promise<void> {
    // Check for missing dependencies
    const missingDeps: string[] = [];
    for (const depPath of dependencies) {
      const depTask = await this.storage.getTask(depPath);
      if (!depTask) {
        missingDeps.push(depPath);
      }
    }

    if (missingDeps.length > 0) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        `Missing dependencies: ${missingDeps.join(', ')}`
      );
    }

    // Check for circular dependencies using shared utility
    const dummyTask: Task = {
      path: 'temp',
      name: 'Temporary Task',
      type: TaskType.TASK,
      status: TaskStatus.PENDING,
      created: Date.now(),
      updated: Date.now(),
      version: 1,
      projectPath: 'temp',
      dependencies: [],
      subtasks: [],
      metadata: {}
    };

    const hasCycle = await detectDependencyCycle(
      dummyTask,
      dependencies,
      this.storage.getTask.bind(this.storage)
    );

    if (hasCycle) {
      throw createError(
        ErrorCodes.TASK_CYCLE,
        'Circular dependencies detected in task relationships'
      );
    }
  }

  private async validateStatusChange(
    newStatus: TaskStatus,
    path: string
  ): Promise<void> {
    // Clear cache before validation
    if ('clearCache' in this.storage) {
      await (this.storage as any).clearCache();
    }

    const task = await this.storage.getTask(path);
    if (!task) {
      throw createError(
        ErrorCodes.TASK_NOT_FOUND,
        `Task not found: ${path}`
      );
    }

    // Validate version hasn't changed
    const currentTask = await this.storage.getTask(path);
    if (currentTask && currentTask.metadata.version !== task.metadata.version) {
      throw createError(
        ErrorCodes.CONCURRENT_MODIFICATION,
        'Task has been modified by another process'
      );
    }

    // Use shared validation utility
    await validateTaskStatusTransition(
      task,
      newStatus,
      this.storage.getTask.bind(this.storage)
    );

    // Check parent task constraints
    if (task.parentPath) {
      const parent = await this.storage.getTask(task.parentPath);
      if (parent) {
        const siblings = await this.storage.getSubtasks(parent.path);
        
        // Cannot complete if siblings are blocked
        if (newStatus === TaskStatus.COMPLETED && 
            siblings.some(s => s.status === TaskStatus.BLOCKED)) {
          throw createError(
            ErrorCodes.TASK_STATUS,
            'Cannot complete task while sibling tasks are blocked'
          );
        }

        // Cannot start if siblings have failed
        if (newStatus === TaskStatus.IN_PROGRESS && 
            siblings.some(s => s.status === TaskStatus.FAILED)) {
          throw createError(
            ErrorCodes.TASK_STATUS,
            'Cannot start task while sibling tasks have failed'
          );
        }
      }
    }
  }

  private validateMetadata(metadata: Record<string, unknown>): void {
    // Add any specific metadata validation rules here
    // For now, just ensure it's an object
    if (typeof metadata !== 'object' || metadata === null) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Metadata must be an object'
      );
    }
  }

}

================
File: tools/handler.ts
================
/**
 * Path-based task management tools
 */
import { TaskManager } from '../task-manager.js';
import { Logger } from '../logging/index.js';
import { ErrorCodes, createError } from '../errors/index.js';
import { TaskType, TaskStatus, CreateTaskInput, UpdateTaskInput } from '../types/task.js';
import {
    createTaskSchema,
    updateTaskSchema,
    getTasksByStatusSchema,
    getTasksByPathSchema,
    getSubtasksSchema,
    deleteTaskSchema,
    bulkTaskSchema,
    clearAllTasksSchema,
    vacuumDatabaseSchema,
    repairRelationshipsSchema
} from './schemas.js';
import { DependencyAwareBatchProcessor } from '../task/core/batch/dependency-aware-batch-processor.js';

interface BulkOperation {
    type: 'create' | 'update' | 'delete';
    path: string;
    data?: Record<string, unknown>;
    id?: string;
    dependencies?: string[];
}

export interface Tool {
    name: string;
    description?: string;
    inputSchema: {
        type: "object";
        properties: Record<string, unknown>;
        required?: string[];
        description?: string;
    };
}

export interface ToolResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

export class ToolHandler {
    private readonly logger: Logger;
    private readonly tools: Map<string, Tool> = new Map();
    private readonly toolHandlers: Map<string, (args: Record<string, unknown>) => Promise<ToolResponse>> = new Map();

    constructor(private readonly taskManager: TaskManager) {
        this.logger = Logger.getInstance().child({ component: 'ToolHandler' });
        this.registerDefaultTools();
    }

    /**
     * Validates task hierarchy rules
     */
    private async validateTaskHierarchy(args: Record<string, unknown>, operation: 'create' | 'update'): Promise<void> {
        const taskType = (args.type || 'TASK').toString().toUpperCase();
        const parentPath = args.parentPath as string | undefined;

        // Validate task type is uppercase
        if (taskType !== taskType.toUpperCase()) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Task type must be uppercase (TASK, GROUP, or MILESTONE)'
            );
        }

        // Validate task type is valid
        if (!['TASK', 'GROUP', 'MILESTONE'].includes(taskType)) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Invalid task type. Must be TASK, GROUP, or MILESTONE'
            );
        }

        // If parent path is provided, validate parent type compatibility
        if (parentPath) {
            const parent = await this.taskManager.getTaskByPath(parentPath);
            if (!parent) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    `Parent task '${parentPath}' not found`
                );
            }

            // Validate parent-child type relationships
            switch (parent.type) {
                case TaskType.MILESTONE:
                    if (!['TASK', 'GROUP'].includes(taskType)) {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'MILESTONE can only contain TASK or GROUP types'
                        );
                    }
                    break;
                case TaskType.GROUP:
                    if (taskType !== 'TASK') {
                        throw createError(
                            ErrorCodes.INVALID_INPUT,
                            'GROUP can only contain TASK types'
                        );
                    }
                    break;
                case TaskType.TASK:
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'TASK type cannot contain subtasks'
                    );
            }
        }

        // For updates, validate type changes don't break hierarchy
        if (operation === 'update' && taskType) {
            const path = args.path as string;
            const task = await this.taskManager.getTaskByPath(path);
            if (!task) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    `Task '${path}' not found`
                );
            }

            // Check if task has subtasks and is being changed to TASK type
            if (taskType === 'TASK') {
                const subtasks = await this.taskManager.getSubtasks(path);
                if (subtasks.length > 0) {
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'Cannot change to TASK type while having subtasks'
                    );
                }
            }

            // Check if changing to GROUP with non-TASK subtasks
            if (taskType === 'GROUP') {
                const subtasks = await this.taskManager.getSubtasks(path);
                const invalidSubtasks = subtasks.filter(s => s.type !== TaskType.TASK);
                if (invalidSubtasks.length > 0) {
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'GROUP can only contain TASK type subtasks'
                    );
                }
            }
        }
    }

    private registerDefaultTools(): void {
        const defaultTools: Array<Tool & { handler: (args: Record<string, unknown>) => Promise<ToolResponse> }> = [
            {
                name: 'create_task',
                description: createTaskSchema.properties.type.description,
                inputSchema: {
                    type: "object",
                    properties: createTaskSchema.properties,
                    required: createTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    // Validate hierarchy rules
                    await this.validateTaskHierarchy(args, 'create');
                    
                    // Create task input with proper type casting
                    const taskInput: CreateTaskInput = {
                        name: args.name as string,
                        path: args.path as string, // Path is now required
                        type: args.type ? (args.type as string).toUpperCase() as TaskType : undefined,
                        description: args.description as string | undefined,
                        parentPath: args.parentPath as string | undefined,
                        dependencies: Array.isArray(args.dependencies) ? args.dependencies as string[] : [],
                        notes: Array.isArray(args.notes) ? args.notes as string[] : undefined,
                        reasoning: args.reasoning as string | undefined,
                        metadata: args.metadata as Record<string, unknown> || {}
                    };
                    
                    const result = await this.taskManager.createTask(taskInput);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'update_task',
                description: updateTaskSchema.properties.updates.properties.type.description,
                inputSchema: {
                    type: "object",
                    properties: updateTaskSchema.properties,
                    required: updateTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const { path, updates } = args as { path: string; updates: Record<string, unknown> };
                    
                    // Validate hierarchy rules if type is being updated
                    if (updates.type) {
                        await this.validateTaskHierarchy({ ...updates, path }, 'update');
                    }
                    
                    // Create update input with proper type casting
                    const updateInput: UpdateTaskInput = {
                        name: updates.name as string | undefined,
                        type: updates.type ? (updates.type as string).toUpperCase() as TaskType : undefined,
                        description: updates.description as string | undefined,
                        status: updates.status as TaskStatus | undefined,
                        dependencies: Array.isArray(updates.dependencies) ? updates.dependencies as string[] : undefined,
                        notes: Array.isArray(updates.notes) ? updates.notes as string[] : undefined,
                        reasoning: updates.reasoning as string | undefined,
                        metadata: updates.metadata as Record<string, unknown> | undefined
                    };
                    
                    const result = await this.taskManager.updateTask(path, updateInput);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_tasks_by_status',
                description: getTasksByStatusSchema.properties.status.description,
                inputSchema: {
                    type: "object",
                    properties: getTasksByStatusSchema.properties,
                    required: getTasksByStatusSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.getTasksByStatus(args.status as unknown as TaskStatus);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_tasks_by_path',
                description: getTasksByPathSchema.properties.pathPattern.description,
                inputSchema: {
                    type: "object",
                    properties: getTasksByPathSchema.properties,
                    required: getTasksByPathSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.listTasks(args.pathPattern as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'get_subtasks',
                description: getSubtasksSchema.properties.path.description,
                inputSchema: {
                    type: "object",
                    properties: getSubtasksSchema.properties,
                    required: getSubtasksSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.getSubtasks(args.path as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'delete_task',
                description: deleteTaskSchema.properties.path.description,
                inputSchema: {
                    type: "object",
                    properties: deleteTaskSchema.properties,
                    required: deleteTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.deleteTask(args.path as string);
                    return this.formatResponse(result);
                }
            },
            {
                name: 'bulk_task_operations',
                description: bulkTaskSchema.properties.operations.description,
                inputSchema: {
                    type: "object",
                    properties: bulkTaskSchema.properties,
                    required: bulkTaskSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const { operations } = args as { operations: BulkOperation[] };

                    // Add dependencies based on operation order
                    const operationsWithDeps = operations.map((op, index) => ({
                        ...op,
                        id: op.path,
                        // Each operation depends on the previous one
                        dependencies: index > 0 ? [operations[index - 1].path] : []
                    }));

                    const batchProcessor = new DependencyAwareBatchProcessor({
                        validator: null,
                        logger: this.logger,
                        storage: this.taskManager.storage
                    }, {
                        maxBatchSize: 1,
                        concurrentBatches: 1,
                        maxRetries: 3,
                        retryDelay: 1000
                    });
                    
                    // Process operations sequentially with dependency ordering
                    const result = await batchProcessor.processInBatches(
                        operationsWithDeps.map(op => ({ id: op.path, data: op })),
                        1,
                        async (operation) => {
                            const op = operation.data as BulkOperation;
                        try {
                            switch (op.type) {
                                case 'create': {
                                    // Extract parent path from task path if not provided
                                    const pathSegments = op.path.split('/');
                                    const parentPath = op.data?.parentPath as string || 
                                        (pathSegments.length > 1 ? pathSegments.slice(0, -1).join('/') : undefined);

                                    const taskData: CreateTaskInput = {
                                        path: op.path,
                                        name: op.data?.name as string || pathSegments[pathSegments.length - 1] || 'Unnamed Task',
                                        type: (op.data?.type as string || 'TASK').toUpperCase() as TaskType,
                                        description: op.data?.description as string,
                                        dependencies: op.data?.dependencies as string[] || [],
                                        parentPath,
                                        metadata: {
                                            ...(op.data?.metadata || {}),
                                            created: Date.now(),
                                            updated: Date.now()
                                        }
                                    };

                                    // Validate hierarchy rules
                                    await this.validateTaskHierarchy(taskData, 'create');

                                    await this.taskManager.createTask(taskData);
                                    break;
                                }
                                case 'update': {
                                    const updateData: UpdateTaskInput = {
                                        status: op.data?.status as TaskStatus,
                                        metadata: op.data?.metadata as Record<string, unknown>,
                                        notes: op.data?.notes as string[],
                                        dependencies: op.data?.dependencies as string[],
                                        description: op.data?.description as string,
                                        name: op.data?.name as string,
                                        type: op.data?.type ? (op.data.type as string).toUpperCase() as TaskType : undefined
                                    };

                                    // Validate hierarchy rules if type is being updated
                                    if (updateData.type) {
                                        await this.validateTaskHierarchy({ ...updateData, path: op.path }, 'update');
                                    }

                                    await this.taskManager.updateTask(op.path, updateData);
                                    break;
                                }
                                case 'delete':
                                    await this.taskManager.deleteTask(op.path);
                                    break;
                                default:
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        `Invalid operation type: ${op.type}`
                                    );
                            }
                        } catch (error) {
                            this.logger.error('Operation failed', {
                                operation: op,
                                error
                            });
                            throw error;
                        }
                    });

                    return this.formatResponse({
                        success: result.metadata?.successCount === operationsWithDeps.length,
                        processedCount: result.metadata?.successCount || 0,
                        failedCount: result.metadata?.errorCount || 0,
                        errors: result.errors.map(err => ({
                            operation: err,
                            error: err.message,
                            context: undefined
                        }))
                    });
                }
            },
            {
                name: 'clear_all_tasks',
                description: clearAllTasksSchema.properties.confirm.description,
                inputSchema: {
                    type: "object",
                    properties: clearAllTasksSchema.properties,
                    required: clearAllTasksSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    await this.taskManager.clearAllTasks(args.confirm as boolean);
                    return this.formatResponse({ success: true, message: 'All tasks cleared' });
                }
            },
            {
                name: 'vacuum_database',
                description: vacuumDatabaseSchema.properties.analyze.description,
                inputSchema: {
                    type: "object",
                    properties: vacuumDatabaseSchema.properties,
                    required: vacuumDatabaseSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    await this.taskManager.vacuumDatabase(args.analyze as boolean);
                    return this.formatResponse({ success: true, message: 'Database optimized' });
                }
            },
            {
                name: 'repair_relationships',
                description: repairRelationshipsSchema.properties.dryRun.description,
                inputSchema: {
                    type: "object",
                    properties: repairRelationshipsSchema.properties,
                    required: repairRelationshipsSchema.required
                },
                handler: async (args: Record<string, unknown>) => {
                    const result = await this.taskManager.repairRelationships(
                        args.dryRun as boolean,
                        args.pathPattern as string | undefined
                    );
                    return this.formatResponse(result);
                }
            }
        ];

        for (const tool of defaultTools) {
            this.registerTool(tool);
        }
    }

    private registerTool(tool: Tool & { handler: (args: Record<string, unknown>) => Promise<ToolResponse> }): void {
        const { handler, ...toolDef } = tool;
        this.tools.set(tool.name, toolDef);
        this.toolHandlers.set(tool.name, handler);
        this.logger.debug('Registered tool', { name: tool.name });
    }

    async listTools(): Promise<{ tools: Tool[] }> {
        const tools = Array.from(this.tools.values());
        this.logger.info('Listed tools', { 
            count: tools.length,
            tools: tools.map(t => ({
                name: t.name,
                schema: t.inputSchema
            }))
        });
        return { tools };
    }

    async handleToolCall(request: { params: { name: string; arguments?: Record<string, unknown> } }): Promise<{
        _meta?: Record<string, unknown>;
        content: Array<{ type: string; text: string }>;
    }> {
        const { name, arguments: args = {} } = request.params;

        const tool = this.tools.get(name);
        if (!tool) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Unknown tool',
                'handleToolCall',
                undefined,
                { tool: name }
            );
        }

        const handler = this.toolHandlers.get(name);
        if (!handler) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Tool handler not found',
                'handleToolCall',
                undefined,
                { tool: name }
            );
        }

        try {
            // Validate dependencies are at root level
            if ((name === 'create_task' || name === 'update_task') && 
                (args as any).metadata?.dependencies) {
                throw createError(
                    ErrorCodes.INVALID_INPUT,
                    'Dependencies must be specified at root level, not in metadata'
                );
            }

            this.logger.debug('Executing tool', { name, args });
            const result = await handler(args);
            this.logger.debug('Tool execution completed', { name });
            return {
                _meta: {},
                ...result
            };
        } catch (error) {
            this.logger.error('Tool execution failed', {
                tool: name,
                error
            });
            throw error;
        }
    }

    async getStorageMetrics(): Promise<any> {
        return await this.taskManager.storage.getMetrics();
    }

    private formatResponse(result: unknown): ToolResponse {
        try {
            const sanitizedResult = JSON.parse(JSON.stringify(result, (key, value) => {
                if (typeof value === 'bigint') {
                    return value.toString();
                }
                if (key.toLowerCase().includes('secret') || 
                    key.toLowerCase().includes('password') ||
                    key.toLowerCase().includes('token')) {
                    return undefined;
                }
                return value;
            }));

            return {
                content: [{
                    type: 'text',
                    text: JSON.stringify(sanitizedResult, null, 2)
                }]
            };
        } catch (error) {
            this.logger.error('Failed to format response', { error });
            throw createError(
                ErrorCodes.INTERNAL_ERROR,
                'Failed to format response'
            );
        }
    }
}

================
File: tools/index.ts
================
/**
 * Tools module exports
 * Centralizes exports for tools-related functionality
 */

export * from './handler.js';
export * from './schemas.js';
export * from './utils.js';

================
File: tools/schemas.ts
================
/**
 * Path-based task management schemas for LLM agents
 */
import { TaskStatus, CONSTRAINTS } from '../types/task.js';

// Schema validation messages
const VALIDATION_MESSAGES = {
    PATH_FORMAT: 'Path can only contain alphanumeric characters, underscores, dots, and hyphens',
    PATH_DEPTH: `Path depth cannot exceed ${CONSTRAINTS.MAX_PATH_DEPTH} levels`,
    NAME_LENGTH: `Name cannot exceed ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
    DESC_LENGTH: `Description cannot exceed ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
    NOTE_LENGTH: `Notes cannot exceed ${CONSTRAINTS.NOTE_MAX_LENGTH} characters each`,
    REASONING_LENGTH: `Reasoning cannot exceed ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
    DEPENDENCIES_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_DEPENDENCIES} dependencies`,
    SUBTASKS_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_SUBTASKS} subtasks`,
    NOTES_SIZE: `Cannot have more than ${CONSTRAINTS.MAX_NOTES} notes`,
    METADATA_LENGTH: `Metadata string fields cannot exceed ${CONSTRAINTS.METADATA_STRING_MAX_LENGTH} characters`,
    METADATA_ARRAY: `Metadata arrays cannot exceed ${CONSTRAINTS.MAX_ARRAY_ITEMS} items`
};

/** Creates a new task with path-based hierarchy and validation */
export const createTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Hierarchical task path (e.g., "server/api/authentication"). Use paths to organize related tasks.\n' +
                        `Constraints:\n` +
                        `- ${VALIDATION_MESSAGES.PATH_FORMAT}\n` +
                        `- ${VALIDATION_MESSAGES.PATH_DEPTH}`,
            pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$',
            maxLength: CONSTRAINTS.MAX_PATH_DEPTH * 50 // Reasonable max length per segment
        },
        name: {
            type: 'string',
            description: 'Clear, action-oriented task name (e.g., "Implement JWT authentication", "Refactor database queries").\n' +
                        `Maximum length: ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
            maxLength: CONSTRAINTS.NAME_MAX_LENGTH
        },
        parentPath: {
            type: 'string',
            description: 'Path of the parent task. Parent must be MILESTONE or GROUP type.\n' +
                        'Examples:\n' +
                        '- "project/backend" (under project backend milestone)\n' +
                        '- "project/backend/auth" (under auth group)',
        },
        description: {
            type: 'string',
            description: 'Detailed task description including:\n' +
                        '- Objective: What needs to be accomplished\n' +
                        '- Context: Why this task is needed\n' +
                        '- Technical details: Implementation considerations\n' +
                        '- Success criteria: How to verify completion\n' +
                        `Maximum length: ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
            maxLength: CONSTRAINTS.DESCRIPTION_MAX_LENGTH
        },
        type: {
            type: 'string',
            enum: ['TASK', 'MILESTONE', 'GROUP'],
            description: ' Task Type Hierarchy Rules (MUST BE UPPERCASE):\n\n' +
                        '1. MILESTONE (Top Level Container):\n' +
                        '    CAN contain: TASK and GROUP types\n' +
                        '    Purpose: Project phases, major deliverables\n' +
                        '    Example: "Backend Development", "Security Hardening"\n' +
                        '    Status: Completed when all subtasks done\n\n' +
                        '2. GROUP (Middle Level Container):\n' +
                        '    CAN contain: Only TASK types\n' +
                        '    CANNOT contain: Other GROUPs or MILESTONEs\n' +
                        '    Purpose: Feature sets, related task collections\n' +
                        '    Example: "Authentication Features", "API Endpoints"\n' +
                        '    Status: Reflects aggregate of subtask states\n\n' +
                        '3. TASK (Leaf Level):\n' +
                        '    CANNOT contain any subtasks\n' +
                        '    Purpose: Atomic units of work\n' +
                        '    Example: "Implement JWT", "Add Rate Limiting"\n' +
                        '    Status: Independently managed\n\n' +
                        'Common Errors to Avoid:\n' +
                        '- Adding subtasks to TASK type\n' +
                        '- Adding non-TASK items under GROUP\n' +
                        '- Creating circular dependencies\n' +
                        '- Exceeding path depth limits',
        },
        dependencies: {
            type: 'array',
            items: { 
                type: 'string',
                pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$'
            },
            maxItems: CONSTRAINTS.MAX_DEPENDENCIES,
            description: 'Paths of tasks that must be completed first. Tasks will be automatically blocked if dependencies are not met.\n' +
                        `Maximum dependencies: ${CONSTRAINTS.MAX_DEPENDENCIES}\n` +
                        'Dependencies can be specified here (recommended) or in metadata.dependencies (legacy).',
            uniqueItems: true
        },
        metadata: {
            type: 'object',
            properties: {
                priority: {
                    type: 'string',
                    enum: ['low', 'medium', 'high'],
                    description: 'Task urgency and impact level. Affects task ordering and scheduling.'
                },
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    maxItems: CONSTRAINTS.MAX_ARRAY_ITEMS,
                    description: 'Keywords for categorization and filtering (e.g., ["api", "security", "optimization"]). Used in path pattern matching.\n' +
                                `Maximum tags: ${CONSTRAINTS.MAX_ARRAY_ITEMS}`,
                    uniqueItems: true
                },
                assignee: {
                    type: 'string',
                    description: 'System or component responsible for the task. Used for task distribution and filtering.'
                },
                reasoning: {
                    type: 'string',
                    description: 'LLM reasoning about task decisions, importance, and approach. Provides context for status changes and dependencies.\n' +
                                `Maximum length: ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.REASONING_MAX_LENGTH
                },
                notes: {
                    type: 'array',
                    items: { 
                        type: 'string',
                        maxLength: CONSTRAINTS.NOTE_MAX_LENGTH
                    },
                    maxItems: CONSTRAINTS.MAX_NOTES,
                    description: 'Additional context, observations, and planning notes. Used to track progress and document decisions.\n' +
                                `Maximum notes: ${CONSTRAINTS.MAX_NOTES}\n` +
                                `Maximum length per note: ${CONSTRAINTS.NOTE_MAX_LENGTH} characters`
                }
            },
            description: 'Additional task context and tracking information. Fields affect:\n' +
                        '- Task organization (priority, tags, assignee)\n' +
                        '- Progress tracking (notes)\n' +
                        '- Decision history (reasoning)\n\n' +
                        'Note: dependencies in metadata.dependencies will be migrated to the main dependencies array.',
        }
    },
    required: ['name', 'path'],
};

/** Updates an existing task */
export const updateTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Path of the task to update.',
        },
        updates: {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'Updated task name with current action focus.\n' +
                                `Maximum length: ${CONSTRAINTS.NAME_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.NAME_MAX_LENGTH
                },
                description: {
                    type: 'string',
                    description: 'Updated description with latest context, findings, and next steps.\n' +
                                `Maximum length: ${CONSTRAINTS.DESCRIPTION_MAX_LENGTH} characters`,
                    maxLength: CONSTRAINTS.DESCRIPTION_MAX_LENGTH
                },
                type: {
                    type: 'string',
                    enum: ['TASK', 'MILESTONE', 'GROUP'],
                    description: ' Task Type Rules (MUST BE UPPERCASE):\n' +
                                '- MILESTONE can contain TASK and GROUP\n' +
                                '- GROUP can only contain TASK\n' +
                                '- TASK cannot contain subtasks\n' +
                                'Changing type may require restructuring subtasks.',
                },
                status: {
                    type: 'string',
                    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                    description: 'Current execution state:\n' +
                               '- PENDING: Not yet started\n' +
                               '- IN_PROGRESS: Currently being processed\n' +
                               '- COMPLETED: Successfully finished\n' +
                               '- FAILED: Encountered unresolvable issues\n' +
                               '- BLOCKED: Waiting on dependencies or external factors\n\n' +
                               'Status Propagation Rules:\n' +
                               '- MILESTONE: Completed when all subtasks done\n' +
                               '- GROUP: Status based on subtask states\n' +
                               '- TASK: Independent status management',
                },
                dependencies: {
                    type: 'array',
                    items: { 
                        type: 'string',
                        pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$'
                    },
                    maxItems: CONSTRAINTS.MAX_DEPENDENCIES,
                    description: 'Updated task dependencies. Tasks will be automatically blocked if new dependencies are not met.\n' +
                                `Maximum dependencies: ${CONSTRAINTS.MAX_DEPENDENCIES}\n` +
                                'Status changes propagate through dependency chain.',
                    uniqueItems: true
                },
                metadata: {
                    type: 'object',
                    properties: {
                        priority: {
                            type: 'string',
                            enum: ['low', 'medium', 'high'],
                            description: 'Task urgency and impact level. Affects task ordering and scheduling.'
                        },
                        tags: {
                            type: 'array',
                            items: { type: 'string' },
                            maxItems: CONSTRAINTS.MAX_ARRAY_ITEMS,
                            description: 'Keywords for categorization and filtering (e.g., ["api", "security", "optimization"]). Used in path pattern matching.\n' +
                                      `Maximum tags: ${CONSTRAINTS.MAX_ARRAY_ITEMS}`,
                            uniqueItems: true
                        },
                        assignee: {
                            type: 'string',
                            description: 'Updated system/component assignment'
                        },
                        reasoning: {
                            type: 'string',
                            description: 'LLM reasoning about task decisions, importance, and approach. Provides context for status changes and dependencies.\n' +
                                      `Maximum length: ${CONSTRAINTS.REASONING_MAX_LENGTH} characters`,
                            maxLength: CONSTRAINTS.REASONING_MAX_LENGTH
                        },
                        notes: {
                            type: 'array',
                            items: { 
                                type: 'string',
                                maxLength: CONSTRAINTS.NOTE_MAX_LENGTH
                            },
                            maxItems: CONSTRAINTS.MAX_NOTES,
                            description: 'Additional context, observations, and planning notes. Used to track progress and document decisions.\n' +
                                      `Maximum notes: ${CONSTRAINTS.MAX_NOTES}\n` +
                                      `Maximum length per note: ${CONSTRAINTS.NOTE_MAX_LENGTH} characters`
                        }
                    },
                    description: 'Task metadata fields affect:\n' +
                                '- Task organization (priority, tags, assignee)\n' +
                                '- Progress tracking (notes)\n' +
                                '- Decision history (reasoning)',
                },
            },
            description: 'Fields to update. Available fields:\n' +
                        '- name: Update task name\n' +
                        '- description: Update task details\n' +
                        '- type: Change task type (task/milestone/group)\n' +
                        '- status: Update execution state with automatic dependency checks\n' +
                        '- dependencies: Add/remove dependencies with validation\n' +
                        '- metadata: Update task metadata (priority, tags, notes, etc.)\n\n' +
                        'Status changes trigger:\n' +
                        '- Automatic dependency validation\n' +
                        '- Status propagation to parent tasks\n' +
                        '- Dependent task blocking\n' +
                        '- Child task status updates',
        },
    },
    required: ['path', 'updates'],
};

/** Gets tasks by status */
export const getTasksByStatusSchema = {
    type: 'object',
    properties: {
        status: {
            type: 'string',
            enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'] as TaskStatus[],
            description: 'Filter tasks by their execution state. Use to find tasks needing attention or verify completion.',
        },
        pathPattern: {
            type: 'string',
            description: 'Optional glob pattern to filter by path (e.g., "server/api/*"). Use to focus on specific subsystems.',
        }
    },
    required: ['status'],
};

/** Gets tasks by path pattern */
export const getTasksByPathSchema = {
    type: 'object',
    properties: {
        pathPattern: {
            type: 'string',
            description: 'Glob pattern to match task paths. Use to analyze specific areas of work (e.g., "server/*/security/*").',
        }
    },
    required: ['pathPattern'],
};

/** Gets subtasks of a task */
export const getSubtasksSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Parent task path. Returns immediate subtasks to analyze task breakdown and progress.',
        }
    },
    required: ['path'],
};

/** Deletes a task */
export const deleteTaskSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string',
            description: 'Task path to delete. Will recursively remove all subtasks. Use with caution.',
        }
    },
    required: ['path'],
};

/** Clears all tasks from the database */
export const clearAllTasksSchema = {
    type: 'object',
    properties: {
        confirm: {
            type: 'boolean',
            description: 'Must be set to true to confirm deletion of all tasks. This operation cannot be undone.',
        }
    },
    required: ['confirm'],
};

/** Optimizes database storage and performance */
export const vacuumDatabaseSchema = {
    type: 'object',
    properties: {
        analyze: {
            type: 'boolean',
            description: 'Whether to analyze tables for query optimization after vacuum.',
            default: true
        }
    },
    required: [],
};

/** Repairs parent-child relationships and fixes inconsistencies */
export const repairRelationshipsSchema = {
    type: 'object',
    properties: {
        dryRun: {
            type: 'boolean',
            description: 'If true, only reports issues without fixing them.',
            default: false
        },
        pathPattern: {
            type: 'string',
            description: 'Optional glob pattern to limit repair scope (e.g., "project/*").'
        }
    },
    required: [],
};

/** Bulk task operations with validation */
export const bulkTaskSchema = {
    type: 'object',
    properties: {
        operations: {
            type: 'array',
            description: 'Sequence of atomic task operations. Use for coordinated updates and maintaining task relationships.',
            items: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['create', 'update', 'delete'],
                        description: 'Operation type:\n' +
                                   '- create: Add new task with full context\n' +
                                   '- update: Modify task with latest findings\n' +
                                   '- delete: Remove completed or obsolete task'
                    },
                    path: {
                        type: 'string',
                        description: 'Task path for the operation. For create, this sets the desired hierarchy.\n' +
                                   `Constraints:\n` +
                                   `- ${VALIDATION_MESSAGES.PATH_FORMAT}\n` +
                                   `- ${VALIDATION_MESSAGES.PATH_DEPTH}`,
                        pattern: '^[a-zA-Z0-9_.-]+(?:/[a-zA-Z0-9_.-]+)*$',
                        maxLength: CONSTRAINTS.MAX_PATH_DEPTH * 50
                    },
                    data: {
                        type: 'object',
                        description: 'Operation-specific data:\n' +
                                   '- create: Full task definition including dependencies and context\n' +
                                   '- update: Fields to modify including status and dependencies\n' +
                                   '- delete: Optional deletion context\n\n' +
                                   'Dependency handling:\n' +
                                   '- Dependencies are validated across all operations\n' +
                                   '- Status changes respect dependency constraints\n' +
                                   '- Circular dependencies are prevented\n' +
                                   '- Failed operations trigger rollback'
                    },
                },
                required: ['type', 'path'],
            },
        },
    },
    required: ['operations'],
};

================
File: tools/session-schemas.ts
================
/**
 * Session and Task List Management Schemas
 * Defines schemas for managing work sessions and task organization
 */

/** Creates a new task list in the current session. IMPORTANT: Requires an active session - use create_session first if you haven't already. Task lists organize related tasks and provide structure for task management. */
export const createTaskListSchema = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Name of the task list. Best practice: Use descriptive names that reflect the purpose or theme (e.g., "Q1 Feature Development", "Security Improvements").',
        },
        description: {
            type: 'string',
            description: 'Description of the task list. Best practice: Include goals, success criteria, and any relevant timelines or constraints.',
        },
        metadata: {
            type: 'object',
            properties: {
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags for categorizing the task list. Best practice: Use consistent prefixes (e.g., "project:", "team:", "quarter:") for better organization.',
                },
                context: {
                    type: 'string',
                    description: 'Additional context about the task list. Best practice: Include links to project documentation, milestones, or related resources.',
                }
            },
            description: 'Additional task list metadata. Best practice: Use for cross-referencing and organization.',
        },
        persistent: {
            type: 'boolean',
            description: 'Whether the task list should persist across sessions. Best practice: Use true for long-term projects, false for temporary task groupings.',
            default: true
        }
    },
    required: ['name'],
};

/** Switches to a different task list in the current session */
export const switchTaskListSchema = {
    type: 'object',
    properties: {
        taskListId: {
            type: 'string',
            description: 'ID of the task list to switch to. Best practice: Verify task list exists and contains active tasks before switching.',
        }
    },
    required: ['taskListId'],
};

/** Lists all task lists in the current session */
export const listTaskListsSchema = {
    type: 'object',
    properties: {
        includeArchived: {
            type: 'boolean',
            description: 'Whether to include archived task lists. Best practice: Use true when reviewing historical data or reactivating old projects.',
            default: false
        }
    }
};

/** Archives a task list */
export const archiveTaskListSchema = {
    type: 'object',
    properties: {
        taskListId: {
            type: 'string',
            description: 'ID of the task list to archive. Best practice: Ensure all tasks are completed or properly transferred before archiving.',
        }
    },
    required: ['taskListId'],
};

/** Creates a new session. IMPORTANT: This must be called first before any task operations can be performed. A session provides the required context for managing tasks and task lists. */
export const createSessionSchema = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Name of the session. Best practice: Use descriptive names that include purpose and date (e.g., "Feature Development - March 2024").',
        },
        metadata: {
            type: 'object',
            properties: {
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Tags for categorizing the session. Best practice: Include project phase, team, and priority indicators.',
                },
                context: {
                    type: 'string',
                    description: 'Additional context about the session. Best practice: Document goals, participants, and key decisions made during the session.',
                }
            },
            description: 'Additional session metadata. Best practice: Use for tracking session objectives and outcomes.',
        }
    },
    required: ['name'],
};

/** Switches to a different session */
export const switchSessionSchema = {
    type: 'object',
    properties: {
        sessionId: {
            type: 'string',
            description: 'ID of the session to switch to. Best practice: Save any pending changes in current session before switching.',
        }
    },
    required: ['sessionId'],
};

/** Lists all available sessions */
export const listSessionsSchema = {
    type: 'object',
    properties: {
        includeArchived: {
            type: 'boolean',
            description: 'Whether to include archived sessions. Best practice: Use for auditing or reviewing historical work patterns.',
            default: false
        }
    }
};

/** Archives a session */
export const archiveSessionSchema = {
    type: 'object',
    properties: {
        sessionId: {
            type: 'string',
            description: 'ID of the session to archive. Best practice: Document session outcomes and ensure all task lists are properly resolved before archiving.'
        }
    },
    required: ['sessionId']
};

/**
 * Best Practices for Session Management:
 * 
 * 1. Session Organization:
 *    - Create sessions for focused work periods or project phases
 *    - Use consistent naming conventions for better tracking
 *    - Document session goals and outcomes
 * 
 * 2. Task List Management:
 *    - Group related tasks into logical task lists
 *    - Keep task lists focused and manageable
 *    - Use metadata and tags for easy filtering
 * 
 * 3. Archiving Strategy:
 *    - Archive completed sessions with proper documentation
 *    - Ensure all tasks are resolved before archiving
 *    - Use archiving for maintaining clean workspace
 * 
 * 4. Metadata Usage:
 *    - Use consistent tag prefixes
 *    - Include relevant links and context
 *    - Track important decisions and rationale
 * 
 * 5. Session Switching:
 *    - Save work before switching sessions
 *    - Verify task list status when switching
 *    - Maintain context between sessions
 */

================
File: tools/utils.ts
================
/**
 * Utility functions for tool operations
 */

/**
 * Formats a response object for consistent output
 * @param response The response object to format
 * @returns Formatted response string
 */
export function formatResponse(response: unknown): string {
    return JSON.stringify(response, null, 2);
}

/**
 * Validates that required parameters are present in a request
 * @param params The parameters object to validate
 * @param required Array of required parameter names
 * @throws Error if any required parameter is missing
 */
export function validateRequiredParams(params: Record<string, unknown>, required: string[]): void {
    for (const param of required) {
        if (!(param in params)) {
            throw new Error(`Missing required parameter: ${param}`);
        }
    }
}

/**
 * Sanitizes a string for safe usage
 * @param input The string to sanitize
 * @returns Sanitized string
 */
export function sanitizeString(input: string): string {
    return input.trim();
}

/**
 * Validates string length is within limits
 * @param input The string to validate
 * @param maxLength Maximum allowed length
 * @param fieldName Name of the field for error message
 * @throws Error if string exceeds maximum length
 */
export function validateStringLength(input: string, maxLength: number, fieldName: string): void {
    if (input.length > maxLength) {
        throw new Error(`${fieldName} exceeds maximum length of ${maxLength} characters`);
    }
}

================
File: types/batch.ts
================
import { Task } from './task.js';

/**
 * Configuration for batch processing operations
 */
export interface BatchConfig {
    /** Maximum number of items per batch */
    batchSize: number;
    /** Maximum number of concurrent batch operations */
    concurrentBatches: number;
    /** Number of retry attempts for failed operations */
    retryCount: number;
    /** Delay between retry attempts in milliseconds */
    retryDelay: number;
}

/**
 * Result of a batch processing operation
 */
export interface BatchResult {
    /** Whether the batch operation was successful */
    success: boolean;
    /** Number of successfully processed items */
    processedCount: number;
    /** Number of failed items */
    failedCount: number;
    /** Detailed error information for failed items */
    errors: Array<BatchError>;
}

/**
 * Error information for a failed batch item
 */
export interface BatchError {
    /** The item that failed processing */
    item: unknown;
    /** The error that occurred */
    error: Error;
    /** Additional context about the failure */
    context?: BatchErrorContext;
}

/**
 * Context information for batch errors
 */
export interface BatchErrorContext {
    /** Size of the batch being processed */
    batchSize: number;
    /** Index of the current item in the batch */
    currentIndex: number;
    /** Number of items processed so far */
    processedCount: number;
    /** Reason for the failure */
    failureReason?: string;
    /** Additional context properties */
    [key: string]: unknown;
}

/**
 * Callbacks for tracking batch processing progress
 */
export interface BatchProgressCallback {
    /** Called when a batch starts processing */
    onBatchStart?: (batchIndex: number, totalBatches: number) => void;
    /** Called when a batch completes processing */
    onBatchComplete?: (batchIndex: number, result: BatchResult) => void;
    /** Called when an individual operation completes */
    onOperationComplete?: (itemIndex: number, totalItems: number) => void;
}

/**
 * Base interface for batch processors
 */
export interface BatchProcessor {
    processBatch<T>(
        batch: T[],
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;
    
    processInBatches<T>(
        items: T[],
        batchSize: number,
        operation: (item: T) => Promise<void>,
        progressCallback?: BatchProgressCallback
    ): Promise<BatchResult>;
}

/**
 * Interface for items with dependencies
 */
export interface DependentItem {
    /** Unique identifier for the item */
    id?: string;
    /** Path-based identifier for the item */
    path?: string;
    /** Dependencies that must be processed before this item */
    dependencies?: string[];
}

/**
 * Extended batch result for task operations
 */
export interface TaskBatchResult extends BatchResult {
    /** Paths of tasks affected by the operation */
    affectedTasks: string[];
    /** ID of the transaction if applicable */
    transactionId?: string;
    /** Validation errors encountered */
    validationErrors?: Array<{
        path: string;
        error: Error;
    }>;
}

/**
 * Configuration for task batch operations
 */
export interface TaskBatchOperation {
    /** Type of operation to perform */
    type: 'add' | 'update' | 'remove';
    /** Tasks to process */
    tasks: Task[];
    /** Additional options for the operation */
    options?: {
        /** Skip validation checks */
        skipValidation?: boolean;
        /** Force update even if conditions aren't met */
        forceUpdate?: boolean;
        /** Continue processing despite errors */
        ignoreErrors?: boolean;
    };
}

/**
 * Status update operation for tasks
 */
export interface StatusUpdate {
    /** Path of the task to update */
    taskPath: string;
    /** New status to apply */
    newStatus: Task['status'];
}

================
File: types/cache.ts
================
import { Task } from './task.js';

export interface CacheEntry<T> {
  value: T;
  expires: number;
  lastAccessed: number;
}

export interface CacheOptions {
  maxSize?: number;
  ttl?: number;
  cleanupInterval?: number;
  baseTTL?: number;
  maxTTL?: number;
}

export interface CacheMetricsData extends Record<string, unknown> {
  hits: number;
  misses: number;
  hitRatio: number;
  size: number;
  lastCleanup: number;
  invalidations: number;
  clears: number;
  memoryUsage: number;
}

export interface CacheCoordinatorOptions {
  maxMemory?: number;
  checkInterval?: number;
  pressureThreshold?: number;
  debugMode?: boolean;
}

export interface TaskCacheEntry extends CacheEntry<Task> {
  dependencies?: string[];
  dependents?: string[];
}

export interface CacheStats {
  size: number;
  hits: number;
  misses: number;
  hitRatio: number;
  memoryUsage: number;
  lastCleanup: number;
}

================
File: types/config.ts
================
/**
 * Configuration types
 */
import { LogLevel } from '../types/logging.js';

/**
 * Environment types
 */
export const Environments = {
    DEVELOPMENT: 'development',
    PRODUCTION: 'production',
    TEST: 'test'
} as const;

export type Environment = typeof Environments[keyof typeof Environments];

/**
 * Environment configuration
 */
export interface EnvironmentConfig {
    /** Node environment */
    NODE_ENV: Environment;
    /** Log level */
    LOG_LEVEL: LogLevel;
    /** Task storage directory */
    TASK_STORAGE_DIR: string;
}

/**
 * Logging configuration
 */
export interface LoggingConfig {
    /** Log level */
    level: LogLevel;
    /** Enable console logging */
    console: boolean;
    /** Enable file logging */
    file: boolean;
    /** Log directory */
    dir?: string;
    /** Maximum log files */
    maxFiles: number;
    /** Maximum log file size */
    maxSize: number;
}

/**
 * Storage configuration
 */
export interface StorageConfig {
    /** Base directory */
    baseDir: string;
    /** Storage name */
    name: string;
    /** Connection settings */
    connection?: {
        /** Maximum retries */
        maxRetries?: number;
        /** Retry delay in milliseconds */
        retryDelay?: number;
        /** Busy timeout in milliseconds */
        busyTimeout?: number;
    };
    /** Performance settings */
    performance?: {
        /** WAL mode checkpoint interval */
        checkpointInterval?: number;
        /** Cache size in pages */
        cacheSize?: number;
        /** Memory map size */
        mmapSize?: number;
        /** Page size */
        pageSize?: number;
    };
}

/**
 * Application configuration
 */
export interface Config {
    /** Environment */
    env: Environment;
    /** Logging configuration */
    logging: LoggingConfig;
    /** Storage configuration */
    storage: StorageConfig;
}

================
File: types/error.ts
================
/**
 * Error-related type definitions
 */

/**
 * Error codes enumeration
 * @description Defines all possible error codes in the system
 */
export const ErrorCodes = {
    // Task-related errors
    TASK_NOT_FOUND: 'TASK_NOT_FOUND',
    TASK_VALIDATION: 'TASK_VALIDATION',
    TASK_DEPENDENCY: 'TASK_DEPENDENCY',
    TASK_STATUS: 'TASK_STATUS',
    TASK_DUPLICATE: 'TASK_DUPLICATE',
    TASK_INVALID_TYPE: 'TASK_INVALID_TYPE',
    TASK_INVALID_STATUS: 'TASK_INVALID_STATUS',
    TASK_INVALID_PARENT: 'TASK_INVALID_PARENT',
    TASK_OPERATION_FAILED: 'TASK_OPERATION_FAILED',
    
    // Storage-related errors
    STORAGE_READ: 'STORAGE_READ',
    STORAGE_WRITE: 'STORAGE_WRITE',
    STORAGE_INIT: 'STORAGE_INIT',
    STORAGE_DELETE: 'STORAGE_DELETE',
    STORAGE_PERMISSION: 'STORAGE_PERMISSION',
    STORAGE_NOT_FOUND: 'STORAGE_NOT_FOUND',
    STORAGE_TRANSACTION: 'STORAGE_TRANSACTION',
    STORAGE_ROLLBACK: 'STORAGE_ROLLBACK',
    STORAGE_COMMIT: 'STORAGE_COMMIT',
    
    // Configuration errors
    CONFIG_MISSING: 'CONFIG_MISSING',
    CONFIG_INVALID: 'CONFIG_INVALID',
    CONFIG_TYPE: 'CONFIG_TYPE',
    CONFIG_VALIDATION: 'CONFIG_VALIDATION',
    CONFIG_REQUIRED: 'CONFIG_REQUIRED',
    
    // Server errors
    SERVER_INIT: 'SERVER_INIT',
    SERVER_SHUTDOWN: 'SERVER_SHUTDOWN',
    SERVER_CONNECTION: 'SERVER_CONNECTION',
    SERVER_TIMEOUT: 'SERVER_TIMEOUT',
    SERVER_OVERLOAD: 'SERVER_OVERLOAD',
    
    // Tool-related errors
    TOOL_NOT_FOUND: 'TOOL_NOT_FOUND',
    TOOL_EXECUTION: 'TOOL_EXECUTION',
    TOOL_VALIDATION: 'TOOL_VALIDATION',
    TOOL_TIMEOUT: 'TOOL_TIMEOUT',
    TOOL_PERMISSION: 'TOOL_PERMISSION',
    
    // General errors
    INTERNAL_ERROR: 'INTERNAL_ERROR',
    INVALID_INPUT: 'INVALID_INPUT',
    OPERATION_FAILED: 'OPERATION_FAILED',
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    PERMISSION_DENIED: 'PERMISSION_DENIED',
    NOT_IMPLEMENTED: 'NOT_IMPLEMENTED',
    TIMEOUT: 'TIMEOUT'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

/**
 * Base error interface
 * @description Common properties for all errors
 */
export interface BaseError {
    /** Error name/type */
    name: string;
    /** Error message */
    message: string;
    /** Error code */
    code: ErrorCode;
    /** Error stack trace */
    stack?: string;
    /** Additional error details */
    details?: unknown;
}

/**
 * Error severity levels
 * @description Defines the severity of errors for logging and handling
 */
export const ErrorSeverity = {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
    FATAL: 'fatal'
} as const;

export type ErrorSeverityLevel = typeof ErrorSeverity[keyof typeof ErrorSeverity];

/**
 * Extended error interface with severity
 * @description Error interface with additional severity information
 */
export interface ExtendedError extends BaseError {
    /** Error severity level */
    severity: ErrorSeverityLevel;
    /** Timestamp when the error occurred */
    timestamp: string;
    /** Request ID associated with the error */
    requestId?: string;
    /** Session ID associated with the error */
    sessionId?: string;
    /** User ID associated with the error */
    userId?: string;
    /** Additional context about the error */
    context?: Record<string, unknown>;
}

/**
 * Error response interface
 * @description Standard error response format
 */
export interface ErrorResponse {
    /** Operation success status (always false for errors) */
    success: false;
    /** Error information */
    error: {
        /** Error code */
        code: ErrorCode;
        /** Error message */
        message: string;
        /** Additional error details */
        details?: unknown;
    };
    /** Response metadata */
    metadata?: {
        /** Operation timestamp */
        timestamp: string;
        /** Request identifier */
        requestId: string;
        /** Session identifier */
        sessionId: string;
    };
}

/**
 * Error handler options interface
 * @description Configuration options for error handling
 */
export interface ErrorHandlerOptions {
    /** Whether to include stack traces in errors */
    includeStack?: boolean;
    /** Default error severity level */
    defaultSeverity?: ErrorSeverityLevel;
    /** Whether to log errors automatically */
    autoLog?: boolean;
    /** Custom error transformers */
    transformers?: {
        [key: string]: (error: unknown) => ErrorResponse;
    };
}

/**
 * Error category mapping
 * @description Maps error codes to their categories for better organization
 */
export const ErrorCategories = {
    TASK: [
        ErrorCodes.TASK_NOT_FOUND,
        ErrorCodes.TASK_VALIDATION,
        ErrorCodes.TASK_DEPENDENCY,
        ErrorCodes.TASK_STATUS,
        ErrorCodes.TASK_DUPLICATE,
        ErrorCodes.TASK_INVALID_TYPE,
        ErrorCodes.TASK_INVALID_STATUS,
        ErrorCodes.TASK_INVALID_PARENT,
        ErrorCodes.TASK_OPERATION_FAILED
    ],
    STORAGE: [
        ErrorCodes.STORAGE_READ,
        ErrorCodes.STORAGE_WRITE,
        ErrorCodes.STORAGE_INIT,
        ErrorCodes.STORAGE_DELETE,
        ErrorCodes.STORAGE_PERMISSION,
        ErrorCodes.STORAGE_NOT_FOUND,
        ErrorCodes.STORAGE_TRANSACTION,
        ErrorCodes.STORAGE_ROLLBACK,
        ErrorCodes.STORAGE_COMMIT
    ],
    CONFIG: [
        ErrorCodes.CONFIG_MISSING,
        ErrorCodes.CONFIG_INVALID,
        ErrorCodes.CONFIG_TYPE,
        ErrorCodes.CONFIG_VALIDATION,
        ErrorCodes.CONFIG_REQUIRED
    ],
    SERVER: [
        ErrorCodes.SERVER_INIT,
        ErrorCodes.SERVER_SHUTDOWN,
        ErrorCodes.SERVER_CONNECTION,
        ErrorCodes.SERVER_TIMEOUT,
        ErrorCodes.SERVER_OVERLOAD
    ],
    TOOL: [
        ErrorCodes.TOOL_NOT_FOUND,
        ErrorCodes.TOOL_EXECUTION,
        ErrorCodes.TOOL_VALIDATION,
        ErrorCodes.TOOL_TIMEOUT,
        ErrorCodes.TOOL_PERMISSION
    ],
    GENERAL: [
        ErrorCodes.INTERNAL_ERROR,
        ErrorCodes.INVALID_INPUT,
        ErrorCodes.OPERATION_FAILED,
        ErrorCodes.VALIDATION_ERROR,
        ErrorCodes.PERMISSION_DENIED,
        ErrorCodes.NOT_IMPLEMENTED,
        ErrorCodes.TIMEOUT
    ]
} as const;

export type ErrorCategory = keyof typeof ErrorCategories;

/**
 * Error metadata interface
 * @description Additional metadata for error tracking and analysis
 */
export interface ErrorMetadata {
    /** Error category */
    category: ErrorCategory;
    /** Error severity */
    severity: ErrorSeverityLevel;
    /** Whether the error is retryable */
    retryable: boolean;
    /** Suggested recovery action */
    recovery?: string;
    /** Related documentation link */
    docs?: string;
    /** Additional metadata */
    [key: string]: unknown;
}

/**
 * Error mapping type
 * @description Maps error codes to their metadata
 */
export type ErrorMapping = {
    [K in ErrorCode]: ErrorMetadata;
};

================
File: types/events.ts
================
/**
 * System event types and interfaces
 */
import { MonitoringMetrics } from './storage.js';

// Base event type
export type AtlasEvent = SystemEvent | TaskEvent | CacheEvent | ErrorEvent | TransactionEvent | BatchEvent;

// Event handler types
export type EventHandler<T extends AtlasEvent> = (event: T) => void | Promise<void>;

export interface EventSubscription {
    unsubscribe: () => void;
}

// Transaction event interface
export interface TransactionEvent {
    type: EventTypes;
    timestamp: number;
    transactionId: string;
    metadata?: Record<string, unknown>;
}

// Batch event interface
export interface BatchEvent {
    type: EventTypes;
    timestamp: number;
    batchId: string;
    metadata?: Record<string, unknown>;
}

export enum EventTypes {
    // System events
    SYSTEM_STARTUP = 'system_startup',
    SYSTEM_SHUTDOWN = 'system_shutdown',
    SYSTEM_ERROR = 'system_error',

    // Tool events
    TOOL_STARTED = 'tool_started',
    TOOL_COMPLETED = 'tool_completed',
    TOOL_FAILED = 'tool_failed',

    // Storage events
    STORAGE_WAL_ENABLED = 'storage_wal_enabled',
    STORAGE_WAL_CHECKPOINT = 'storage_wal_checkpoint',
    STORAGE_VACUUM = 'storage_vacuum',
    STORAGE_ANALYZE = 'storage_analyze',

    // Transaction events
    TRANSACTION_STARTED = 'transaction_started',
    TRANSACTION_COMMITTED = 'transaction_committed',
    TRANSACTION_ROLLED_BACK = 'transaction_rolled_back',
    TRANSACTION_TIMEOUT = 'transaction_timeout',
    TRANSACTION_ERROR = 'transaction_error',

    // Task events
    TASK_CREATED = 'task_created',
    TASK_UPDATED = 'task_updated',
    TASK_DELETED = 'task_deleted',
    TASK_STATUS_CHANGED = 'task_status_changed',

    // Cache events
    MEMORY_PRESSURE = 'memory_pressure',
    CACHE_CLEARED = 'cache_cleared',
    CACHE_INVALIDATED = 'cache_invalidated'
}

export interface SystemEventMetadata {
    // Tool execution
    tool?: string;
    args?: unknown;
    success?: boolean;
    error?: Error;

    // System info
    version?: string;
    environment?: string;
    component?: string;
    operation?: string;
    reason?: string;

    // Resource usage
    memoryUsage?: {
        heapUsed: number;
        heapTotal: number;
        rss: number;
    };
    threshold?: number;

    // Transaction info
    transactionId?: string;
    connectionId?: string;
    isolation?: string;
    duration?: number;

    // Storage info
    dbPath?: string;
    checkpointCount?: number;
    walMode?: boolean;
    metrics?: MonitoringMetrics;
    unhealthyConnections?: string[];
    healthStatus?: {
        isHealthy: boolean;
        errorCount: number;
        avgResponseTime: number;
    };
}

export interface SystemEvent {
    type: EventTypes;
    timestamp: number;
    metadata?: SystemEventMetadata;
}

export interface ErrorEvent {
    type: EventTypes.SYSTEM_ERROR;
    timestamp: number;
    error: Error;
    context?: {
        component: string;
        operation: string;
        args?: unknown;
    };
}

export interface TaskEvent {
    type: EventTypes;
    timestamp: number;
    taskId: string;
    task: unknown;
    metadata?: Record<string, unknown>;
    changes?: {
        before: unknown;
        after: unknown;
    };
}

export interface CacheEvent {
    type: EventTypes;
    timestamp: number;
    metadata: {
        memoryUsage: {
            heapUsed: number;
            heapTotal: number;
            rss: number;
        };
        threshold: number;
    };
}

================
File: types/index.ts
================
/**
 * Common type definitions
 */
export * from './indexing.js';

/**
 * Validation result interface
 */
export interface ValidationResult<T = unknown> {
    /** Whether validation succeeded */
    success: boolean;
    /** Validated data if successful */
    data?: T;
    /** Validation errors if failed */
    errors?: Array<{
        /** Field path */
        path: string[];
        /** Error message */
        message: string;
        /** Received value */
        received?: unknown;
        /** Expected type/value */
        expected?: string;
    }>;
}

/**
 * Utility type for making all properties optional recursively
 */
export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Utility type for making all properties required recursively
 */
export type DeepRequired<T> = {
    [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

/**
 * Utility type for making all properties readonly recursively
 */
export type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

/**
 * Utility type for extracting keys of type from object
 */
export type KeysOfType<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];

/**
 * Utility type for omitting properties by type
 */
export type OmitByType<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};

/**
 * Utility type for picking properties by type
 */
export type PickByType<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};

/**
 * Utility type for making properties mutable
 */
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

/**
 * Utility type for making properties immutable
 */
export type Immutable<T> = {
    readonly [P in keyof T]: T[P];
};

/**
 * Utility type for type predicate functions
 */
export type TypePredicate = (value: unknown) => boolean;

/**
 * Utility type for async functions
 */
export type AsyncFunction<T = void> = () => Promise<T>;

/**
 * Utility type for constructor functions
 */
export type Constructor<T = object> = new (...args: any[]) => T;

/**
 * Utility type for function parameters
 */
export type Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;

/**
 * Utility type for function return type
 */
export type ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never;

/**
 * Utility type for promise value type
 */
export type PromiseType<T extends Promise<any>> = T extends Promise<infer U> ? U : never;

/**
 * Utility type for array element type
 */
export type ArrayElement<T extends readonly any[]> = T extends readonly (infer U)[] ? U : never;

/**
 * Utility type for object values
 */
export type ObjectValues<T> = T[keyof T];

/**
 * Utility type for object keys
 */
export type ObjectKeys<T> = keyof T;

/**
 * Utility type for non-undefined values
 */
export type NonUndefined<T> = T extends undefined ? never : T;

/**
 * Utility type for non-null values
 */
export type NonNull<T> = T extends null ? never : T;

/**
 * Utility type for non-nullable values
 */
export type NonNullable<T> = T extends null | undefined ? never : T;

/**
 * Utility type for required keys
 */
export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

/**
 * Utility type for optional keys
 */
export type OptionalKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

================
File: types/indexing.ts
================
/**
 * Task indexing type definitions
 */

import { Task, TaskStatus } from './task.js';

/**
 * Task index structure
 */
export interface TaskIndex extends Task {
    path: string;
    status: TaskStatus;
    parentPath?: string;
    dependencies: string[];
    subtasks: string[];
}

/**
 * Index manager configuration
 */
export interface IndexConfig {
    batchSize: number;
    parallelOperations: boolean;
}

/**
 * Index operation result
 */
export interface IndexOperationResult {
    success: boolean;
    error?: Error;
}

/**
 * Index manager interface
 */
export interface IndexManager {
    /**
     * Indexes a task and its dependencies
     */
    indexTask(task: Task): Promise<void>;

    /**
     * Removes a task from all indexes
     */
    unindexTask(task: Task): Promise<void>;

    /**
     * Gets a task by its exact path
     */
    getTaskByPath(path: string): Promise<TaskIndex | null>;

    /**
     * Gets tasks by path pattern (supports * and ** wildcards)
     */
    getTasksByPattern(pattern: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks by status with optional pattern filtering
     */
    getTasksByStatus(status: TaskStatus, pattern?: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks by parent path
     */
    getTasksByParent(parentPath: string): Promise<TaskIndex[]>;

    /**
     * Gets tasks that depend on a task
     */
    getDependentTasks(path: string): Promise<TaskIndex[]>;

    /**
     * Gets project tasks by pattern
     */
    getProjectTasks(pattern: string): Promise<TaskIndex[]>;

    /**
     * Clears all indexes
     */
    clear(): void;

    /**
     * Gets index statistics
     */
    getStats(): IndexStats;
}

/**
 * Index statistics
 */
export interface IndexStats {
    totalTasks: number;
    byStatus: Record<TaskStatus, number>;
    byDepth: Record<number, number>;
    averageDepth: number;
}

================
File: types/logging.ts
================
/**
 * Logging-related type definitions
 */

/**
 * Log levels enumeration
 * @description Defines the possible log levels using Winston's standard levels
 */
export const LogLevels = {
    ERROR: 'error',   // 0
    WARN: 'warn',     // 1
    INFO: 'info',     // 2
    HTTP: 'http',     // 3
    VERBOSE: 'verbose', // 4
    DEBUG: 'debug',   // 5
    SILLY: 'silly'    // 6
} as const;

export type LogLevel = typeof LogLevels[keyof typeof LogLevels];

/**
 * Log entry interface
 * @description Represents a single log entry
 */
export interface LogEntry {
    /** Log timestamp */
    timestamp: string;
    /** Log level */
    level: LogLevel;
    /** Log message */
    message: string;
    /** Additional context */
    context?: Record<string, unknown>;
    /** Error information if applicable */
    error?: {
        /** Error name */
        name: string;
        /** Error message */
        message: string;
        /** Error stack trace */
        stack?: string;
        /** Error code */
        code?: string;
        /** Additional error details */
        details?: unknown;
    };
}

/**
 * Logger configuration interface
 * @description Configuration options for the logger
 */
export interface LoggerConfig {
    /** Minimum log level to record */
    minLevel: LogLevel;
    /** Log directory path */
    logDir?: string;
    /** Whether to log to console */
    console?: boolean;
    /** Whether to log to file */
    file?: boolean;
    /** Maximum number of log files */
    maxFiles?: number;
    /** Maximum size of each log file in bytes */
    maxFileSize?: number;
    /** Whether to disable colored console output */
    noColors?: boolean;
}

/**
 * Log formatter interface
 * @description Interface for log formatters
 */
export interface LogFormatter {
    /** Format a log entry */
    format(entry: LogEntry): string;
}

/**
 * Log transport interface
 * @description Interface for log transports (console, file, etc.)
 */
export interface LogTransport {
    /** Write a log entry */
    write(entry: LogEntry): Promise<void>;
    /** Initialize the transport */
    initialize?(): Promise<void>;
    /** Close the transport */
    close?(): Promise<void>;
}

/**
 * Child logger context interface
 * @description Context for child loggers
 */
export interface ChildLoggerContext {
    /** Component name */
    component?: string;
    /** Request ID */
    requestId?: string;
    /** Session ID */
    sessionId?: string;
    /** User ID */
    userId?: string;
    /** Additional context */
    [key: string]: unknown;
}

/**
 * Logger interface
 * @description Interface for logger instances
 */
export interface Logger {
    /** Log at DEBUG level */
    debug(message: string, context?: Record<string, unknown>): void;
    /** Log at INFO level */
    info(message: string, context?: Record<string, unknown>): void;
    /** Log at WARN level */
    warn(message: string, context?: Record<string, unknown>): void;
    /** Log at ERROR level */
    error(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
    /** Log at ERROR level (alias for error, maintains backward compatibility) */
    fatal(message: string, error?: Error | unknown, context?: Record<string, unknown>): void;
    /** Create a child logger with additional context */
    child(context: ChildLoggerContext): Logger;
    /** Initialize the logger */
    initialize(): Promise<void>;
}

/**
 * Log file info interface
 * @description Information about a log file
 */
export interface LogFileInfo {
    /** File name */
    name: string;
    /** File path */
    path: string;
    /** File size in bytes */
    size: number;
    /** Creation timestamp */
    created: string;
    /** Last modified timestamp */
    modified: string;
}

/**
 * Log rotation options interface
 * @description Options for log rotation
 */
export interface LogRotationOptions {
    /** Maximum file size in bytes */
    maxSize: number;
    /** Maximum number of files */
    maxFiles: number;
    /** Whether to compress old logs */
    compress?: boolean;
    /** Pattern for date in file names */
    datePattern?: string;
}

/**
 * Log query options interface
 * @description Options for querying logs
 */
export interface LogQueryOptions {
    /** Start timestamp */
    from?: string;
    /** End timestamp */
    to?: string;
    /** Log levels to include */
    levels?: LogLevel[];
    /** Search text */
    search?: string;
    /** Context filters */
    context?: Record<string, unknown>;
    /** Maximum number of entries */
    limit?: number;
    /** Number of entries to skip */
    offset?: number;
    /** Sort direction */
    order?: 'asc' | 'desc';
}

/**
 * Log query result interface
 * @description Result of a log query
 */
export interface LogQueryResult {
    /** Log entries */
    entries: LogEntry[];
    /** Total number of matching entries */
    total: number;
    /** Query metadata */
    metadata: {
        /** Query timestamp */
        timestamp: string;
        /** Query duration in milliseconds */
        duration: number;
        /** Applied filters */
        filters: Record<string, unknown>;
    };
}

================
File: types/project.ts
================
/**
 * Project-related type definitions
 */

/**
 * Project status enumeration
 */
export enum ProjectStatus {
    ACTIVE = 'active',
    ARCHIVED = 'archived',
    COMPLETED = 'completed'
}

/**
 * Project metadata interface
 */
export interface ProjectMetadata {
    created: number;
    updated: number;
    owner: string;
    tags?: string[];
    status: ProjectStatus;
    version: number;
    description?: string;
    category?: string;
    priority?: 'low' | 'medium' | 'high';
    dueDate?: number;
    customFields?: Record<string, unknown>;
}

/**
 * Project interface
 */
export interface Project {
    path: string;           // Unique project identifier (e.g., "auth-system")
    name: string;           // Display name
    description?: string;
    metadata: ProjectMetadata;
    rootTaskPaths: string[];  // Top-level task paths
}

/**
 * Project creation input
 */
export interface CreateProjectInput {
    path: string;
    name: string;
    description?: string;
    metadata?: {
        owner?: string;
        tags?: string[];
        category?: string;
        priority?: 'low' | 'medium' | 'high';
        dueDate?: number;
        customFields?: Record<string, unknown>;
    };
}

/**
 * Project update input
 */
export interface UpdateProjectInput {
    name?: string;
    description?: string;
    metadata?: Partial<Omit<ProjectMetadata, 'created' | 'updated' | 'version'>>;
}

/**
 * Project operation response
 */
export interface ProjectResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: unknown;
    };
    metadata?: {
        timestamp: number;
        requestId: string;
        projectPath: string;
        affectedTasks?: string[];
        transactionId?: string;
    };
}

/**
 * Project validation utilities
 */
export const PROJECT_PATH_REGEX = /^[a-z0-9][a-z0-9-]*[a-z0-9]$/;
export const MAX_PROJECT_PATH_LENGTH = 64;
export const MAX_PROJECT_NAME_LENGTH = 100;
export const MAX_PROJECT_DESCRIPTION_LENGTH = 1000;

export function validateProjectPath(path: string): boolean {
    return (
        PROJECT_PATH_REGEX.test(path) &&
        path.length <= MAX_PROJECT_PATH_LENGTH &&
        !path.includes('/')
    );
}

export function validateProjectName(name: string): boolean {
    return (
        name.trim().length > 0 &&
        name.length <= MAX_PROJECT_NAME_LENGTH
    );
}

export function validateProjectDescription(description?: string): boolean {
    return !description || description.length <= MAX_PROJECT_DESCRIPTION_LENGTH;
}

/**
 * Project error codes
 */
export enum ProjectErrorCode {
    INVALID_PATH = 'PROJECT_INVALID_PATH',
    INVALID_NAME = 'PROJECT_INVALID_NAME',
    INVALID_DESCRIPTION = 'PROJECT_INVALID_DESCRIPTION',
    DUPLICATE_PATH = 'PROJECT_DUPLICATE_PATH',
    NOT_FOUND = 'PROJECT_NOT_FOUND',
    ARCHIVED = 'PROJECT_ARCHIVED',
    INVALID_STATUS = 'PROJECT_INVALID_STATUS',
    INVALID_METADATA = 'PROJECT_INVALID_METADATA'
}

================
File: types/session.ts
================
/**
 * Session and Task List Types
 */

/**
 * Session metadata
 */
export interface SessionMetadata {
    /** Creation timestamp */
    created: number;
    /** Last update timestamp */
    updated: number;
    /** Session tags */
    tags?: string[];
    /** Additional context */
    context?: string;
    /** Whether the session is archived */
    archived?: boolean;
}

/**
 * Session storage interface
 */
export interface SessionStorage {
    /** Initialize storage */
    initialize(): Promise<void>;
    /** Save session */
    saveSession(session: Session): Promise<void>;
    /** Load session by ID */
    loadSession(sessionId: string): Promise<Session>;
    /** Load all sessions */
    loadAllSessions(): Promise<Session[]>;
    /** Delete session */
    deleteSession(sessionId: string): Promise<void>;
    /** Save task list */
    saveTaskList(taskList: TaskList): Promise<void>;
    /** Load task list by ID */
    loadTaskList(taskListId: string): Promise<TaskList>;
    /** Load all task lists */
    loadAllTaskLists(): Promise<TaskList[]>;
    /** Delete task list */
    deleteTaskList(taskListId: string): Promise<void>;
    /** Save active state */
    saveActiveState(state: {
        activeSessionId?: string;
        activeTaskListId?: string;
    }): Promise<void>;
    /** Load active state */
    loadActiveState(): Promise<{
        activeSessionId?: string;
        activeTaskListId?: string;
    }>;
    /** Close storage */
    close(): Promise<void>;
}

/**
 * Session manager interface
 */
export interface SessionManager {
    /** Initialize manager */
    initialize(): Promise<void>;
    /** Create new session */
    createSession(input: CreateSessionInput): Promise<Session>;
    /** Get session by ID */
    getSession(sessionId: string): Promise<Session>;
    /** List all sessions */
    listSessions(includeArchived?: boolean): Promise<Session[]>;
    /** Archive session */
    archiveSession(sessionId: string): Promise<void>;
    /** Create task list */
    createTaskList(input: CreateTaskListInput): Promise<TaskList>;
    /** Get task list by ID */
    getTaskList(taskListId: string): Promise<TaskList>;
    /** List all task lists */
    listTaskLists(includeArchived?: boolean): Promise<TaskList[]>;
    /** Archive task list */
    archiveTaskList(taskListId: string): Promise<void>;
    /** Switch active session */
    switchSession(sessionId: string): Promise<void>;
    /** Switch active task list */
    switchTaskList(taskListId: string): Promise<void>;
    /** Get active session */
    getActiveSession(): Promise<Session | null>;
    /** Get active task list */
    getActiveTaskList(): Promise<TaskList | null>;
}

/**
 * Session entity
 */
export interface Session {
    /** Unique session ID */
    id: string;
    /** Session name */
    name: string;
    /** Session metadata */
    metadata: SessionMetadata;
    /** Active task list ID */
    activeTaskListId?: string;
    /** Task list IDs in this session */
    taskListIds: string[];
}

/**
 * Task list metadata
 */
export interface TaskListMetadata {
    /** Creation timestamp */
    created: number;
    /** Last update timestamp */
    updated: number;
    /** Task list tags */
    tags?: string[];
    /** Additional context */
    context?: string;
    /** Whether the task list is archived */
    archived?: boolean;
    /** Whether the task list persists across sessions */
    persistent?: boolean;
}

/**
 * Task list entity
 */
export interface TaskList {
    /** Unique task list ID */
    id: string;
    /** Task list name */
    name: string;
    /** Task list description */
    description?: string;
    /** Task list metadata */
    metadata: TaskListMetadata;
    /** Root task IDs */
    rootTaskIds: string[];
}

/**
 * Session creation input
 */
export interface CreateSessionInput {
    /** Session name */
    name: string;
    /** Session metadata */
    metadata?: {
        /** Session tags */
        tags?: string[];
        /** Additional context */
        context?: string;
    };
}

/**
 * Task list creation input
 */
export interface CreateTaskListInput {
    /** Task list name */
    name: string;
    /** Task list description */
    description?: string;
    /** Task list metadata */
    metadata?: {
        /** Task list tags */
        tags?: string[];
        /** Additional context */
        context?: string;
    };
    /** Whether the task list should persist across sessions */
    persistent?: boolean;
}

/**
 * Session response wrapper
 */
export interface SessionResponse {
    /** Response data */
    data: Session;
    /** Response metadata */
    metadata: {
        /** Operation timestamp */
        timestamp: number;
        /** Operation type */
        operation: 'create' | 'update' | 'delete';
    };
}

/**
 * Task list response wrapper
 */
export interface TaskListResponse {
    /** Response data */
    data: TaskList;
    /** Response metadata */
    metadata: {
        /** Operation timestamp */
        timestamp: number;
        /** Operation type */
        operation: 'create' | 'update' | 'delete';
    };
}

/**
 * Session error codes
 */
export enum SessionErrorCode {
    /** Session not found */
    SESSION_NOT_FOUND = 'SESSION_NOT_FOUND',
    /** Session validation failed */
    SESSION_VALIDATION = 'SESSION_VALIDATION',
    /** Session already exists */
    SESSION_EXISTS = 'SESSION_EXISTS',
    /** Session limit exceeded */
    SESSION_LIMIT = 'SESSION_LIMIT',
    /** Invalid session operation */
    SESSION_INVALID_OP = 'SESSION_INVALID_OP'
}

/**
 * Task list error codes
 */
export enum TaskListErrorCode {
    /** Task list not found */
    TASK_LIST_NOT_FOUND = 'TASK_LIST_NOT_FOUND',
    /** Task list validation failed */
    TASK_LIST_VALIDATION = 'TASK_LIST_VALIDATION',
    /** Task list already exists */
    TASK_LIST_EXISTS = 'TASK_LIST_EXISTS',
    /** Task list limit exceeded */
    TASK_LIST_LIMIT = 'TASK_LIST_LIMIT',
    /** Invalid task list operation */
    TASK_LIST_INVALID_OP = 'TASK_LIST_INVALID_OP'
}

================
File: types/storage.ts
================
/**
 * Storage types and interfaces
 */
import { Task, TaskStatus, CreateTaskInput, UpdateTaskInput } from './task.js';
import { MonitoringConfig } from '../storage/monitoring/index.js';

export interface StorageConfig {
    baseDir: string;
    name: string;
    connection?: {
        maxConnections?: number;
        idleTimeout?: number;
        busyTimeout?: number;
    };
    performance?: {
        cacheSize?: number;
        pageSize?: number;
        mmapSize?: number;
    };
    monitoring?: MonitoringConfig;
}

export interface StorageMetrics {
    tasks: {
        total: number;
        byStatus: Record<TaskStatus, number>;
        noteCount: number;
        dependencyCount: number;
    };
    storage: {
        totalSize: number;
        pageSize: number;
        pageCount: number;
        walSize: number;
        cache: {
            hitRate: number;
            memoryUsage: number;
            entryCount: number;
        };
    };
}

export interface TaskStorage {
    initialize(): Promise<void>;
    close(): Promise<void>;
    
    // Transaction management
    beginTransaction(): Promise<void>;
    commitTransaction(): Promise<void>;
    rollbackTransaction(): Promise<void>;
    
    // Task operations
    createTask(input: CreateTaskInput): Promise<Task>;
    updateTask(path: string, updates: UpdateTaskInput): Promise<Task>;
    deleteTask(path: string): Promise<void>;
    getTask(path: string): Promise<Task | null>;
    getTasks(paths: string[]): Promise<Task[]>;
    getTasksByPattern(pattern: string): Promise<Task[]>;
    getTasksByStatus(status: string): Promise<Task[]>;
    getSubtasks(parentPath: string): Promise<Task[]>;
    hasChildren(path: string): Promise<boolean>;
    getDependentTasks(path: string): Promise<Task[]>;
    saveTasks(tasks: Task[]): Promise<void>;
    saveTask(task: Task): Promise<void>;
    deleteTasks(paths: string[]): Promise<void>;
    clearAllTasks(): Promise<void>;
    
    // Maintenance operations
    vacuum(): Promise<void>;
    analyze(): Promise<void>;
    checkpoint(): Promise<void>;
    clearCache(): Promise<void>;
    getMetrics(): Promise<StorageMetrics>;
    repairRelationships(dryRun?: boolean): Promise<{ fixed: number; issues: string[] }>;
}

export interface CacheStats {
    hits: number;
    misses: number;
    hitRate: number;
    size: number;
    memoryUsage: number;
}

export interface ConnectionStats {
    total: number;
    active: number;
    idle: number;
    errors: number;
    avgResponseTime: number;
}

export interface QueryStats {
    total: number;
    errors: number;
    avgExecutionTime: number;
    slowQueries: number;
}

export interface MonitoringMetrics {
    cache: CacheStats;
    connections: ConnectionStats;
    queries: QueryStats;
    timestamp: number;
}

================
File: types/task.ts
================
/**
 * Task type definitions
 */

export enum TaskType {
    TASK = 'TASK',
    MILESTONE = 'MILESTONE',
    GROUP = 'GROUP'
}

export enum TaskStatus {
    PENDING = 'PENDING',
    IN_PROGRESS = 'IN_PROGRESS',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED',
    BLOCKED = 'BLOCKED'
}

/**
 * User-defined metadata for tasks
 * All fields are optional and can be customized
 */
export interface TaskMetadata extends Record<string, unknown> {
    priority?: 'low' | 'medium' | 'high';
    tags?: string[];
    reasoning?: string;  // LLM's reasoning about task decisions
    toolsUsed?: string[];  // Tools used by LLM to accomplish task
    resourcesAccessed?: string[];  // Resources accessed by LLM
    contextUsed?: string[];  // Key context pieces used in decision making
    // Each string field max 1000 chars, arrays max 100 items
}

/**
 * Core task interface with system fields at root level
 */
export interface Task {
    // System fields (required)
    path: string;  // Max depth of 8 levels
    name: string;  // Max 200 chars
    type: TaskType;
    status: TaskStatus;
    created: number;  // Timestamp of creation
    updated: number;  // Timestamp of last update
    version: number;  // Incremental version number
    projectPath: string;  // Root project path

    // Optional fields
    description?: string;  // Max 2000 chars
    parentPath?: string;
    notes?: string[];  // Each note max 1000 chars
    reasoning?: string;  // Max 2000 chars - LLM's reasoning about the task
    dependencies: string[];  // Max 50 dependencies
    subtasks: string[];  // Max 100 subtasks
    
    // User-defined metadata (flexible)
    metadata: TaskMetadata;  // Custom fields defined by user
}

export interface CreateTaskInput extends Record<string, unknown> {
    path: string;  // Now required
    name: string;
    parentPath?: string;
    description?: string;
    type?: TaskType;
    notes?: string[];
    reasoning?: string;
    dependencies?: string[];
    metadata?: Partial<TaskMetadata>;
}

export interface UpdateTaskInput extends Record<string, unknown> {
    name?: string;
    description?: string;
    type?: TaskType;
    status?: TaskStatus;
    parentPath?: string;
    notes?: string[];
    reasoning?: string;
    dependencies?: string[];
    metadata?: Partial<TaskMetadata>;
}

export interface TaskResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
    };
    metadata: {
        timestamp: number;
        requestId: string;
        projectPath: string;
        affectedPaths: string[];
    };
}

// Field length constraints
export const CONSTRAINTS = {
    NAME_MAX_LENGTH: 200,
    DESCRIPTION_MAX_LENGTH: 2000,
    NOTE_MAX_LENGTH: 1000,
    REASONING_MAX_LENGTH: 2000,
    METADATA_STRING_MAX_LENGTH: 1000,
    MAX_DEPENDENCIES: 50,
    MAX_SUBTASKS: 100,
    MAX_NOTES: 100,
    MAX_ARRAY_ITEMS: 100,
    MAX_PATH_DEPTH: 8
} as const;

/**
 * Gets the task name from a path
 */
export function getTaskName(path: string): string {
    const segments = path.split('/');
    return segments[segments.length - 1];
}

/**
 * Gets the parent path from a task path
 */
export function getParentPath(path: string): string | undefined {
    const segments = path.split('/');
    return segments.length > 1 ? segments.slice(0, -1).join('/') : undefined;
}

================
File: types/transaction.ts
================
import { Task } from './task.js';

export type TransactionStatus = 'pending' | 'committed' | 'rolled_back';

export interface Transaction {
  id: string;
  operations: Operation[];
  timestamp: number;
  status: TransactionStatus;
  timeout?: number;
  metadata?: {
    retryCount?: number;
    parentTransaction?: string;
    initiator?: string;
  };
}

export interface Operation {
  id: string;
  type: 'create' | 'update' | 'delete';
  timestamp: number;
  path: string;
  task?: Task;
  tasks?: Task[];
  previousState?: Partial<Task>;
  metadata?: Record<string, any>;
}

export interface TransactionResult {
  success: boolean;
  transactionId: string;
  error?: Error;
  metadata?: {
    duration: number;
    retryCount?: number;
  };
}

export interface TransactionOptions {
  timeout?: number;
  retryLimit?: number;
  retryDelay?: number;
  requireLock?: boolean;
}

export const DEFAULT_TRANSACTION_OPTIONS: TransactionOptions = {
  timeout: 30000, // 30 seconds
  retryLimit: 3,
  retryDelay: 1000, // 1 second
  requireLock: true
};

================
File: utils/id-generator.ts
================
/**
 * ID Generator Utility
 * Generates short, unique identifiers for tasks, sessions, and other entities
 * 
 * Using 8 characters from a 62-character alphabet (a-z, A-Z, 0-9) gives:
 * - 62^8 = 218,340,105,584,896 possible combinations
 * - Collision probability of ~0.1% after 13.5 million IDs (birthday problem)
 * - At 1000 IDs/second, would take ~6.9 years to have a 1% collision probability
 */

import { customAlphabet } from 'nanoid';

// Constants
const ID_LENGTH = 8;
const ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

// Sequence counters for readable IDs
let sessionCounter = 1;
let taskCounter = 1;

// Create ID generator with specified alphabet and length
const generateId = customAlphabet(ALPHABET, ID_LENGTH);

/**
 * Generates a readable session ID
 * Format: session-XXX where XXX is a sequential number
 */
export function generateSessionId(): string {
    const id = `session-${sessionCounter.toString().padStart(3, '0')}`;
    sessionCounter++;
    return id;
}

/**
 * Generates a readable task ID
 * Format: task-XXX where XXX is a sequential number
 */
export function generateTaskId(): string {
    const id = `task-${taskCounter.toString().padStart(3, '0')}`;
    taskCounter++;
    return id;
}

/**
 * Generates a short, unique identifier (for other entities)
 * Format: 8 characters using [0-9A-Za-z]
 * Example: "xK7cPq2Z"
 */
export function generateShortId(): string {
    return generateId();
}

/**
 * Validates if a string matches any of the valid ID formats
 */
export function isValidShortId(value: string): boolean {
    if (!value) return false;
    return new RegExp(`^[${ALPHABET}]{${ID_LENGTH}}$`).test(value);
}

/**
 * Generates a deterministic ID for testing/development
 * @param prefix - Optional 2-character prefix
 * @param sequence - Sequence number (0-999999)
 */
export function generateTestId(prefix = 'ts', sequence = 0): string {
    const seq = sequence.toString().padStart(6, '0');
    return `${prefix}${seq}`.slice(0, ID_LENGTH);
}

// Export constants for use in validation schemas
export const ID_CONSTANTS = {
    LENGTH: ID_LENGTH,
    ALPHABET,
    PATTERN: new RegExp(`^[${ALPHABET}]{${ID_LENGTH}}$`)
} as const;

================
File: utils/path-utils.ts
================
import { createError, ErrorCodes } from '../errors/index.js';

/**
 * Utilities for handling task paths with validation and normalization
 */
export class PathUtils {
  /**
   * Normalizes a path string by:
   * - Converting to lowercase
   * - Replacing spaces with hyphens
   * - Removing invalid characters
   * - Normalizing slashes
   */
  static normalize(path: string): string {
    // First convert Windows backslashes to forward slashes
    const normalized = path.replace(/\\/g, '/');
    
    return normalized.toLowerCase()
      .trim()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-\/]/g, '')
      .replace(/\/+/g, '/') // Normalize multiple slashes to single
      .replace(/^\/+|\/+$/g, ''); // Trim leading/trailing slashes
  }

  /**
   * Extracts the project path (first segment) from a full path
   */
  static getProjectPath(path: string): string {
    const normalized = this.normalize(path);
    const segments = normalized.split('/');
    if (segments.length === 0) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Invalid path: empty path'
      );
    }
    return segments[0];
  }

  /**
   * Checks if a path is a valid subpath of another path
   */
  static isSubPath(parentPath: string, childPath: string): boolean {
    const normalizedParent = this.normalize(parentPath);
    const normalizedChild = this.normalize(childPath);
    return normalizedChild.startsWith(`${normalizedParent}/`);
  }

  /**
   * Generates a valid path from a name and optional parent path
   */
  static generatePath(name: string, parentPath?: string): string {
    const safeName = this.normalize(name);
    if (!safeName) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Invalid name: cannot generate path from empty name'
      );
    }
    return parentPath ? `${this.normalize(parentPath)}/${safeName}` : safeName;
  }

  /**
   * Validates a path string against path requirements
   * Throws an error if the path is invalid
   */
  static validatePath(path: string): void {
    if (!path) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path cannot be empty'
      );
    }

    const normalized = this.normalize(path);
    
    // Check for full path format
    if (!normalized.includes('/')) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path must be fully qualified (e.g., "project/feature/task")'
      );
    }

    // Validate path format (allow both forward and backslashes in input, but normalize to forward slashes)
    const pathRegex = /^[a-z0-9-]+(?:[\/\\][a-z0-9-]+)*$/;
    if (!pathRegex.test(normalized)) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path must contain only letters, numbers, hyphens, and forward slashes'
      );
    }

    // Check path depth (prevent excessive nesting)
    const depth = normalized.split('/').length;
    if (depth > 10) {
      throw createError(
        ErrorCodes.INVALID_INPUT,
        'Path depth exceeds maximum allowed (10 levels)'
      );
    }
  }

  /**
   * Gets the parent path of a given path
   * Returns null if the path has no parent (is a root path)
   */
  static getParentPath(path: string): string | null {
    const normalized = this.normalize(path);
    const lastSlashIndex = normalized.lastIndexOf('/');
    return lastSlashIndex === -1 ? null : normalized.substring(0, lastSlashIndex);
  }

  /**
   * Gets the name (last segment) of a path
   */
  static getName(path: string): string {
    const normalized = this.normalize(path);
    const segments = normalized.split('/');
    return segments[segments.length - 1];
  }
}

================
File: utils/pattern-matcher.ts
================
import { sep, posix } from 'path';

/**
 * Pattern matching utilities for task paths with cross-platform support
 */

/**
 * Normalizes path separators to forward slashes for consistent pattern matching
 */
function normalizePath(path: string): string {
    return path.split(sep).join(posix.sep);
}

/**
 * Converts a glob pattern to a regular expression with platform-agnostic path handling
 * Supports:
 * - * for single level matching
 * - ** for recursive matching
 * - ? for single character matching
 */
export function globToRegex(pattern: string): RegExp {
    // Normalize path separators first
    const normalizedPattern = normalizePath(pattern);
    
    const escapedPattern = normalizedPattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
        .replace(/\*\*/g, '{{RECURSIVE}}') // Temp placeholder for **
        .replace(/\*/g, `[^${posix.sep}]+`) // * matches anything except path separator
        .replace(/\?/g, '.') // ? matches single char
        .replace(/{{RECURSIVE}}/g, '.*'); // ** matches anything including path separator

    return new RegExp(`^${escapedPattern}$`);
}

/**
 * Converts a glob pattern to an SQL LIKE/GLOB pattern with platform-agnostic path handling
 */
export function globToSqlPattern(pattern: string): string {
    // Normalize path separators first
    const normalizedPattern = normalizePath(pattern);
    
    return normalizedPattern
        .replace(/\*\*/g, '%') // ** for recursive match
        .replace(/\*/g, '%') // * for single level match
        .replace(/\?/g, '_'); // ? for single character
}

/**
 * Generates all possible glob patterns for a given path with platform-agnostic handling
 * Example: "a/b/c" generates:
 * - "a/b/c"
 * - "a/b/*"
 * - "a/*\/c"
 * - "a/**"
 * - "*\/b/c"
 * - etc.
 */
export function generatePathPatterns(path: string): string[] {
    // Normalize path separators first
    const normalizedPath = normalizePath(path);
    const segments = normalizedPath.split(posix.sep);
    const patterns: Set<string> = new Set();

    // Add exact path
    patterns.add(normalizedPath);

    // Add single wildcard patterns
    for (let i = 0; i < segments.length; i++) {
        const pattern = [
            ...segments.slice(0, i),
            '*',
            ...segments.slice(i + 1)
        ].join(posix.sep);
        patterns.add(pattern);
    }

    // Add recursive patterns
    for (let i = 0; i < segments.length - 1; i++) {
        const pattern = [...segments.slice(0, i), '**'].join(posix.sep);
        patterns.add(pattern);
    }

    // Add combinations of * and **
    for (let i = 0; i < segments.length - 1; i++) {
        for (let j = i + 1; j < segments.length; j++) {
            const pattern = [
                ...segments.slice(0, i),
                '*',
                ...segments.slice(i + 1, j),
                '**'
            ].join(posix.sep);
            patterns.add(pattern);
        }
    }

    return Array.from(patterns);
}

/**
 * Tests if a path matches a glob pattern with platform-agnostic path handling
 */
export function matchesPattern(path: string, pattern: string): boolean {
    // Normalize both path and pattern before matching
    return globToRegex(pattern).test(normalizePath(path));
}

================
File: validation/config.ts
================
/**
 * Configuration validation schemas
 */
import { z } from 'zod';
import { LogLevels } from '../types/logging.js';
import { Environments } from '../types/config.js';

/**
 * Environment variables validation schema
 */
export const envVarsSchema = z.object({
    NODE_ENV: z.enum([
        Environments.DEVELOPMENT,
        Environments.PRODUCTION,
        Environments.TEST
    ]).optional(),
    LOG_LEVEL: z.enum([
        LogLevels.ERROR,
        LogLevels.WARN,
        LogLevels.INFO,
        LogLevels.HTTP,
        LogLevels.VERBOSE,
        LogLevels.DEBUG,
        LogLevels.SILLY
    ]).optional(),
    TASK_STORAGE_DIR: z.string().optional()
});

/**
 * Logging configuration validation schema
 */
export const loggingConfigSchema = z.object({
    level: z.enum([
        LogLevels.ERROR,
        LogLevels.WARN,
        LogLevels.INFO,
        LogLevels.HTTP,
        LogLevels.VERBOSE,
        LogLevels.DEBUG,
        LogLevels.SILLY
    ]),
    console: z.boolean().optional(),
    file: z.boolean().optional(),
    dir: z.string().optional(),
    maxFiles: z.number().int().positive().optional(),
    maxSize: z.number().int().positive().optional(),
    noColors: z.boolean().optional()
});

/**
 * Storage connection configuration validation schema
 */
export const storageConnectionConfigSchema = z.object({
    maxRetries: z.number().int().positive().optional(),
    retryDelay: z.number().int().nonnegative().optional(),
    busyTimeout: z.number().int().nonnegative().optional()
});

/**
 * Storage performance configuration validation schema
 */
export const storagePerformanceConfigSchema = z.object({
    checkpointInterval: z.number().int().nonnegative().optional(),
    cacheSize: z.number().int().nonnegative().optional(),
    mmapSize: z.number().int().nonnegative().optional(),
    pageSize: z.number().int().nonnegative().optional()
});

/**
 * Storage configuration validation schema
 */
export const storageConfigSchema = z.object({
    baseDir: z.string(),
    name: z.string(),
    connection: storageConnectionConfigSchema.optional(),
    performance: storagePerformanceConfigSchema.optional()
});

/**
 * Complete configuration validation schema
 */
export const configSchema = z.object({
    env: z.enum([
        Environments.DEVELOPMENT,
        Environments.PRODUCTION,
        Environments.TEST
    ]),
    logging: loggingConfigSchema,
    storage: storageConfigSchema
});

================
File: validation/id-schema.ts
================
/**
 * Shared ID validation schemas using the new short ID format
 */

import { z } from 'zod';
import { ID_CONSTANTS } from '../utils/id-generator.js';

// Legacy UUID pattern
const UUID_PATTERN = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

// Base ID schema for reuse across different entity types
export const baseIdSchema = z.string().regex(
    ID_CONSTANTS.PATTERN,
    `Task/Entity ID must be exactly ${ID_CONSTANTS.LENGTH} characters long and contain only alphanumeric characters [${ID_CONSTANTS.ALPHABET}]. Example: "xK7cPq2Z". You cannot use descriptive names like "Project Setup" as IDs.`
);

// Helper function to validate ID format
export function validateIdFormat(id: string, context: string = 'ID'): void {
    if (!ID_CONSTANTS.PATTERN.test(id)) {
        throw new Error(
            `Invalid ${context}: Must be exactly ${ID_CONSTANTS.LENGTH} characters long and contain only alphanumeric characters [${ID_CONSTANTS.ALPHABET}]. ` +
            `Received: "${id}". Example valid ID: "xK7cPq2Z"`
        );
    }
}

// Transitional schema that accepts both short IDs and UUIDs
export const transitionalIdSchema = z.string().refine(
    (val) => ID_CONSTANTS.PATTERN.test(val) || UUID_PATTERN.test(val),
    `ID must be either ${ID_CONSTANTS.LENGTH} characters long containing only [${ID_CONSTANTS.ALPHABET}] or a valid UUID`
);

// Specific entity ID schemas with custom error messages
export const taskIdSchema = baseIdSchema.describe('Task ID');
export const sessionIdSchema = transitionalIdSchema.describe('Session ID');
export const taskListIdSchema = baseIdSchema.describe('Task List ID');

// Array of IDs schema for dependencies, subtasks, etc.
export const idArraySchema = z.array(baseIdSchema);

// Optional ID schema for nullable fields
export const optionalIdSchema = baseIdSchema.optional();

// Example usage in a task schema:
export const taskReferenceSchema = z.object({
    id: taskIdSchema,
    parentId: optionalIdSchema,
    dependencies: idArraySchema.default([]),
    subtasks: idArraySchema.default([])
});

// Example usage in a session schema:
export const sessionReferenceSchema = z.object({
    id: sessionIdSchema,
    activeTaskListId: optionalIdSchema,
    taskListIds: idArraySchema.default([])
});

// Export types for use in other modules
export type TaskReference = z.infer<typeof taskReferenceSchema>;
export type SessionReference = z.infer<typeof sessionReferenceSchema>;

================
File: validation/index.ts
================
/**
 * Validation module exports
 * Provides a centralized point for configuration, logging, shared ID validation,
 * and path validation rules
 */

export * from './config.js';
export * from './logging.js';
export * from './id-schema.js';
export * from './path-validator.js';

================
File: validation/logging.ts
================
/**
 * Logging validation schemas
 */
import { z } from 'zod';
import { LogLevels } from '../types/logging.js';

/**
 * Log level validation schema
 */
export const logLevelSchema = z.enum([
    LogLevels.ERROR,
    LogLevels.WARN,
    LogLevels.INFO,
    LogLevels.HTTP,
    LogLevels.VERBOSE,
    LogLevels.DEBUG,
    LogLevels.SILLY
]);

/**
 * Log entry validation schema
 */
export const logEntrySchema = z.object({
    timestamp: z.string(),
    level: logLevelSchema,
    message: z.string(),
    context: z.record(z.unknown()).optional(),
    error: z.object({
        name: z.string(),
        message: z.string(),
        stack: z.string().optional(),
        code: z.string().optional(),
        details: z.unknown().optional()
    }).optional()
});

/**
 * Logger configuration validation schema
 */
export const loggerConfigSchema = z.object({
    minLevel: logLevelSchema,
    logDir: z.string().optional(),
    console: z.boolean().optional(),
    file: z.boolean().optional(),
    maxFiles: z.number().int().positive().optional(),
    maxFileSize: z.number().int().positive().optional(),
    noColors: z.boolean().optional()
});

/**
 * Log query options validation schema
 */
export const logQueryOptionsSchema = z.object({
    from: z.string().optional(),
    to: z.string().optional(),
    levels: z.array(logLevelSchema).optional(),
    search: z.string().optional(),
    context: z.record(z.unknown()).optional(),
    limit: z.number().int().positive().optional(),
    offset: z.number().int().nonnegative().optional(),
    order: z.enum(['asc', 'desc']).optional()
});

/**
 * Log rotation options validation schema
 */
export const logRotationOptionsSchema = z.object({
    maxSize: z.number().int().positive(),
    maxFiles: z.number().int().positive(),
    compress: z.boolean().optional(),
    datePattern: z.string().optional()
});

/**
 * Log file info validation schema
 */
export const logFileInfoSchema = z.object({
    name: z.string(),
    path: z.string(),
    size: z.number().int().nonnegative(),
    created: z.string(),
    modified: z.string()
});

================
File: validation/path-validator.ts
================
import { ErrorCodes, createError } from '../errors/index.js';
import { Logger } from '../logging/index.js';

/**
 * Rules for validating task paths and project names
 */
export interface PathValidationRules {
    maxDepth: number;
    maxLength: number;
    allowedCharacters: RegExp;
    projectNamePattern: RegExp;
    maxProjectNameLength: number;
}

/**
 * Result of path validation including sanitized path if valid
 */
export interface PathValidationResult {
    isValid: boolean;
    sanitizedPath?: string;
    error?: string;
}

/**
 * Validates and sanitizes task paths and project names
 * Enforces business rules for path structure and naming
 */
export class PathValidator {
    private static logger: Logger;

    private static getLogger(): Logger {
        if (!PathValidator.logger) {
            PathValidator.logger = Logger.getInstance().child({ component: 'PathValidator' });
        }
        return PathValidator.logger;
    }
    private rules: PathValidationRules;

    constructor(rules?: Partial<PathValidationRules>) {
        this.rules = {
            maxDepth: rules?.maxDepth ?? 5,
            maxLength: rules?.maxLength ?? 255,
            allowedCharacters: rules?.allowedCharacters ?? /^[a-zA-Z0-9-_/]+$/,
            projectNamePattern: rules?.projectNamePattern ?? /^[a-zA-Z][a-zA-Z0-9-_]*$/,
            maxProjectNameLength: rules?.maxProjectNameLength ?? 50
        };
    }

    /**
     * Validates a task path against all rules
     * Returns sanitized path if valid
     */
    validatePath(path: string): PathValidationResult {
        try {
            // Check for empty path
            if (!path) {
                return {
                    isValid: false,
                    error: 'Path cannot be empty'
                };
            }

            // Check for parent directory traversal
            if (path.includes('..')) {
                return {
                    isValid: false,
                    error: 'Path cannot contain parent directory traversal (..)'
                };
            }

            // Check path length
            if (path.length > this.rules.maxLength) {
                return {
                    isValid: false,
                    error: `Path length exceeds maximum of ${this.rules.maxLength} characters`
                };
            }

            // Check path depth
            const segments = path.split('/').filter(Boolean);
            if (segments.length > this.rules.maxDepth) {
                return {
                    isValid: false,
                    error: `Path depth exceeds maximum of ${this.rules.maxDepth} levels`
                };
            }

            // Validate project name (first segment)
            const projectName = segments[0];
            if (!this.validateProjectName(projectName)) {
                return {
                    isValid: false,
                    error: `Invalid project name: ${projectName}. Must match pattern ${this.rules.projectNamePattern} and be <= ${this.rules.maxProjectNameLength} characters`
                };
            }

            // Check for invalid characters
            if (!this.rules.allowedCharacters.test(path)) {
                return {
                    isValid: false,
                    error: 'Path contains invalid characters. Only alphanumeric, dash, and underscore allowed'
                };
            }

            // Sanitize path
            const sanitizedPath = this.sanitizePath(path);
            return {
                isValid: true,
                sanitizedPath
            };
        } catch (error) {
            PathValidator.getLogger().error('Path validation error', { error, path });
            throw createError(
                ErrorCodes.VALIDATION_ERROR,
                'Path validation failed',
                'validatePath',
                error instanceof Error ? error.message : String(error)
            );
        }
    }

    /**
     * Validates a project name against naming rules
     */
    validateProjectName(name: string): boolean {
        if (!name) return false;
        if (name.length > this.rules.maxProjectNameLength) return false;
        return this.rules.projectNamePattern.test(name);
    }

    /**
     * Sanitizes a path by normalizing slashes and removing redundant separators
     */
    private sanitizePath(path: string): string {
        // Normalize slashes
        let sanitized = path.replace(/\\/g, '/');
        
        // Remove leading/trailing slashes
        sanitized = sanitized.replace(/^\/+|\/+$/g, '');
        
        // Normalize multiple slashes
        sanitized = sanitized.replace(/\/+/g, '/');
        
        return sanitized;
    }

    /**
     * Validates a task path and its parent path together
     * Ensures parent-child relationship is valid
     */
    validateTaskPath(path: string, parentPath?: string): PathValidationResult {
        // First validate the task path
        const pathResult = this.validatePath(path);
        if (!pathResult.isValid) {
            return pathResult;
        }

        // If no parent path, task path is valid
        if (!parentPath) {
            return pathResult;
        }

        // Validate parent path
        const parentResult = this.validatePath(parentPath);
        if (!parentResult.isValid) {
            return {
                isValid: false,
                error: `Invalid parent path: ${parentResult.error}`
            };
        }

        // Ensure task is actually a child of the parent
        const sanitizedPath = pathResult.sanitizedPath!;
        const sanitizedParent = parentResult.sanitizedPath!;
        
        if (!sanitizedPath.startsWith(`${sanitizedParent}/`)) {
            return {
                isValid: false,
                error: `Task path ${sanitizedPath} is not a child of parent path ${sanitizedParent}`
            };
        }

        // Ensure only one level of nesting from parent
        const pathDepth = sanitizedPath.split('/').length;
        const parentDepth = sanitizedParent.split('/').length;
        if (pathDepth !== parentDepth + 1) {
            return {
                isValid: false,
                error: `Task must be direct child of parent. Path ${sanitizedPath} is nested too deeply under ${sanitizedParent}`
            };
        }

        return {
            isValid: true,
            sanitizedPath: pathResult.sanitizedPath
        };
    }
}

================
File: index.ts
================
import { Logger } from './logging/index.js';
import { TaskManager } from './task-manager.js';
import { createStorage } from './storage/index.js';
import { AtlasServer } from './server/index.js';
import { EventManager } from './events/event-manager.js';
import { EventTypes } from './types/events.js';
import { BaseError, ErrorCodes, createError } from './errors/index.js';
import { ConfigManager } from './config/index.js';
import { join } from 'path';
import { promises as fs } from 'fs';

import { TaskStorage } from './types/storage.js';
import { CreateTaskInput, UpdateTaskInput, TaskStatus } from './types/task.js';

let server: AtlasServer;
let storage: TaskStorage;
let taskManager: TaskManager;

async function main() {
    // Load environment variables from .env file if present
    try {
        const { config } = await import('dotenv');
        config();
    } catch (error) {
        // Ignore error if .env file doesn't exist
    }

    // Get home directory in a cross-platform way
    const homeDir = process.env.HOME || process.env.USERPROFILE || '';

    const logDir = process.env.ATLAS_STORAGE_DIR ? 
        join(process.env.ATLAS_STORAGE_DIR, 'logs') : 
        join(homeDir, 'Documents', 'Cline', 'mcp-workspace', 'ATLAS', 'logs');

    // Create log directory with proper permissions (mode is ignored on Windows)
    await fs.mkdir(logDir, { recursive: true, ...(process.platform !== 'win32' && { mode: 0o755 }) });

    // Initialize logger with explicit file permissions and await initialization
    const logger = await Logger.initialize({
        console: true,
        file: true,
        minLevel: 'debug',
        logDir: logDir,  // Ensure logDir is explicitly set
        maxFileSize: 5 * 1024 * 1024, // 5MB
        maxFiles: 5,
        noColors: false  // Enable colors for better readability
    });
    logger.info('Logger initialized', { logDir, permissions: '0755' });

    // Ensure logger is fully initialized before proceeding
    await new Promise(resolve => setTimeout(resolve, 100));

    // Increase event listener limits to prevent warnings
    process.setMaxListeners(20);

    // Initialize components in correct order
    const eventManager = await EventManager.initialize();
    const configManager = await ConfigManager.initialize({
        logging: {
            console: true,
            file: true,
            level: 'debug',
            maxFiles: 5,
            maxSize: 5242880, // 5MB
            dir: logDir
        },
        storage: {
            baseDir: process.env.ATLAS_STORAGE_DIR || 'atlas-tasks',
            name: process.env.ATLAS_STORAGE_NAME || 'atlas-tasks',
            connection: {
                maxRetries: 1,
                retryDelay: 500,
                busyTimeout: 2000
            },
            performance: {
                checkpointInterval: 60000,
                cacheSize: 1000,
                mmapSize: 1024 * 1024 * 1024, // 1GB
                pageSize: 4096
            }
        }
    });

    const config = configManager.getConfig();

    try {

        // Emit system startup event
        eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_STARTUP,
            timestamp: Date.now(),
            metadata: {
                version: '0.1.0',
                environment: process.env.NODE_ENV || 'development'
            }
        });

        // Initialize storage with mutex
        storage = await createStorage(config.storage!);
        
        // Initialize task manager with existing storage instance
        taskManager = await TaskManager.getInstance(storage);

        // Run maintenance after initialization
        await storage.vacuum();
        await storage.analyze();
        await storage.checkpoint();

        // Initialize server only if it doesn't exist
        if (!server) {
            server = await AtlasServer.getInstance(
            {
                name: 'atlas-mcp-server',
                version: '0.1.0',
                maxRequestsPerMinute: 600,
                requestTimeout: 30000,
                shutdownTimeout: 5000
            },
            {
                listTools: async () => ({
                    tools: [
                        // Task CRUD operations
                        {
                            name: 'create_task',
                            description: 'Create a new task in the hierarchical task structure. Tasks can be organized in a tree-like structure with parent-child relationships and dependencies. Each task has a unique path identifier, metadata, and status tracking.\n\nBest Practices:\n- Use descriptive path names that reflect the task hierarchy (e.g., "project/feature/subtask")\n- Set appropriate task types (TASK for work items, GROUP for organization, MILESTONE for major checkpoints)\n- Include detailed descriptions for better context\n- Use metadata for custom fields like priority, tags, or deadlines\n- Consider dependencies carefully to avoid circular references\n\nExample:\n{\n  "path": "website/auth/login-form",\n  "name": "Implement login form",\n  "description": "Create React component for user authentication",\n  "type": "TASK",\n  "parentPath": "website/auth",\n  "dependencies": ["website/auth/api-endpoints"],\n  "metadata": {\n    "priority": "high",\n    "estimatedHours": 4,\n    "tags": ["frontend", "security"]\n  }\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    path: { 
                                        type: 'string',
                                        description: 'Optional: Unique path identifier for the task (e.g., "project/feature/subtask"). If not provided, will be generated from name'
                                    },
                                    name: { 
                                        type: 'string',
                                        description: 'Required: Display name of the task. This is the only required field'
                                    },
                                    description: { 
                                        type: 'string',
                                        description: 'Optional: Detailed description of the task'
                                    },
                                    type: { 
                                        type: 'string', 
                                        enum: ['TASK', 'GROUP', 'MILESTONE'],
                                        description: 'Optional: Type of task: TASK (individual task), GROUP (container), or MILESTONE (major checkpoint). Defaults to TASK'
                                    },
                                    parentPath: { 
                                        type: 'string',
                                        description: 'Optional: Path of the parent task if this is a subtask. Used for hierarchical organization'
                                    },
                                    dependencies: { 
                                        type: 'array', 
                                        items: { type: 'string' },
                                        description: 'Optional: Array of task paths that must be completed before this task can start. Used for dependency tracking'
                                    },
                                    metadata: { 
                                        type: 'object',
                                        description: 'Optional: Additional task metadata like priority, tags, or custom fields. Can store any JSON-serializable data'
                                    }
                                },
                                required: ['name']
                            }
                        },
                        {
                            name: 'update_task',
                            description: 'Update an existing task\'s properties including status, dependencies, and metadata. All changes are validated for consistency and dependency cycles.\n\nBest Practices:\n- Update only the fields that need to change\n- Use appropriate status values to track progress\n- Validate dependencies before updating\n- Keep metadata consistent across updates\n- Consider impact on dependent tasks\n\nExample:\n{\n  "path": "website/auth/login-form",\n  "updates": {\n    "status": "IN_PROGRESS",\n    "description": "Updated implementation details...",\n    "metadata": {\n      "assignee": "john.doe",\n      "progress": 50\n    }\n  }\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    path: { 
                                        type: 'string',
                                        description: 'Required: Path of the task to update. Must be an existing task path'
                                    },
                                    updates: {
                                        type: 'object',
                                        description: 'Required: Fields to update on the task. At least one update field must be provided',
                                        properties: {
                                                name: { 
                                                    type: 'string',
                                                    description: 'Optional: New display name for the task'
                                                },
                                                description: { 
                                                    type: 'string',
                                                    description: 'Optional: New detailed description for the task'
                                                },
                                                status: { 
                                                    type: 'string', 
                                                    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                                                    description: 'Optional: New status for the task. Must be one of the defined status values'
                                                },
                                                dependencies: { 
                                                    type: 'array', 
                                                    items: { type: 'string' },
                                                    description: 'Optional: New list of dependency task paths. Replaces existing dependencies'
                                                },
                                                metadata: { 
                                                    type: 'object',
                                                    description: 'Optional: Updated task metadata. Merges with existing metadata'
                                                }
                                        }
                                    }
                                },
                                required: ['path', 'updates']
                            }
                        },
                        {
                            name: 'delete_task',
                            description: 'Delete a task and all its subtasks recursively. This operation cascades through the task hierarchy and cannot be undone.\n\nBest Practices:\n- Verify task path carefully before deletion\n- Check for dependent tasks that may be affected\n- Consider archiving important tasks instead of deletion\n- Back up task data if needed before deletion\n- Update dependent task references after deletion\n\nExample:\n{\n  "path": "website/auth"\n  // Will delete auth task and all subtasks like login-form, etc.\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    path: { 
                                        type: 'string',
                                        description: 'Required: Path of the task to delete. Will recursively delete this task and all its subtasks'
                                    }
                                },
                                required: ['path']
                            }
                        },
                        {
                            name: 'get_tasks_by_status',
                            description: 'Retrieve all tasks with a specific status. Useful for monitoring progress, finding blocked tasks, or generating status reports.\n\nStatus Values:\n- PENDING: Not started\n- IN_PROGRESS: Currently being worked on\n- COMPLETED: Finished successfully\n- FAILED: Encountered errors/issues\n- BLOCKED: Waiting on dependencies\n\nExample:\n{\n  "status": "BLOCKED"\n  // Returns all blocked tasks for investigation\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    status: { 
                                        type: 'string', 
                                        enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'BLOCKED'],
                                        description: 'Required: Status value to filter tasks by. Must be one of the defined status values'
                                    }
                                },
                                required: ['status']
                            }
                        },
                        {
                            name: 'get_tasks_by_path',
                            description: 'Retrieve tasks matching a glob pattern. Supports flexible path matching for finding related tasks.\n\nPattern Examples:\n- "project/*": Direct children of project\n- "project/**": All tasks under project (recursive)\n- "*/feature": Feature tasks in any project\n- "auth/login*": All login-related tasks in auth\n\nBest Practices:\n- Use specific patterns to limit results\n- Consider hierarchy depth when using **\n- Combine with status/metadata filtering\n\nExample:\n{\n  "pattern": "website/auth/**"\n  // Returns all tasks under auth hierarchy\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    pattern: { 
                                        type: 'string',
                                        description: 'Required: Glob pattern to match task paths. Supports * for single level and ** for recursive matching'
                                    }
                                },
                                required: ['pattern']
                            }
                        },
                        {
                            name: 'get_subtasks',
                            description: 'Retrieve all direct subtasks of a given task. Returns only immediate children, not the entire subtree.\n\nBest Practices:\n- Use for targeted task management\n- Combine with get_tasks_by_path for deep hierarchies\n- Check subtask status for progress tracking\n- Monitor subtask dependencies\n\nExample:\n{\n  "parentPath": "website/auth"\n  // Returns direct subtasks like login-form, signup-form, etc.\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    parentPath: { 
                                        type: 'string',
                                        description: 'Required: Path of the parent task to get subtasks for. Must be an existing task path'
                                    }
                                },
                                required: ['parentPath']
                            }
                        },
                        {
                            name: 'bulk_task_operations',
                            description: 'Execute multiple task operations atomically in a single transaction. Ensures data consistency by rolling back all changes if any operation fails.\n\nSupported Operations:\n- create: Add new tasks\n- update: Modify existing tasks\n- delete: Remove tasks and subtasks\n\nBest Practices:\n- Group related changes together\n- Order operations to handle dependencies\n- Keep transactions focused and minimal\n- Include proper error handling\n- Validate data before submission\n\nExample:\n{\n  "operations": [\n    {\n      "type": "create",\n      "path": "website/auth/oauth",\n      "data": {\n        "name": "OAuth Integration",\n        "type": "TASK"\n      }\n    },\n    {\n      "type": "update",\n      "path": "website/auth/login-form",\n      "data": {\n        "status": "COMPLETED"\n      }\n    }\n  ]\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    operations: {
                                        type: 'array',
                                        description: 'Required: Array of task operations to execute atomically. Must contain at least one operation. All operations are executed in a single transaction - if any operation fails, all changes are rolled back',
                                        items: {
                                            type: 'object',
                                            properties: {
                                                type: { 
                                                    type: 'string', 
                                                    enum: ['create', 'update', 'delete'],
                                                    description: 'Type of operation to perform'
                                                },
                                                path: { 
                                                    type: 'string',
                                                    description: 'Task path the operation applies to'
                                                },
                                                data: { 
                                                    type: 'object',
                                                    description: 'Operation data (CreateTaskInput for create, UpdateTaskInput for update)'
                                                }
                                            },
                                            required: ['type', 'path']
                                        }
                                    }
                                },
                                required: ['operations']
                            }
                        },
                        // Database maintenance operations
                        {
                            name: 'clear_all_tasks',
                            description: 'Clear all tasks from the database and reset all caches. This is a destructive operation that requires explicit confirmation.\n\nBest Practices:\n- Use only for complete system reset\n- Backup data before clearing\n- Verify confirmation requirement\n- Plan for cache rebuild time\n- Consider selective deletion instead\n\nExample:\n{\n  "confirm": true\n  // Must be explicitly set to true\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    confirm: { 
                                        type: 'boolean',
                                        description: 'Required: Must be explicitly set to true to confirm deletion. This is a safety measure for this destructive operation'
                                    }
                                },
                                required: ['confirm']
                            }
                        },
                        {
                            name: 'vacuum_database',
                            description: 'Optimize database storage and performance by cleaning up unused space and updating statistics.\n\nBest Practices:\n- Run during low-usage periods\n- Schedule regular maintenance\n- Monitor space reclamation\n- Update statistics for query optimization\n- Back up before major operations\n\nExample:\n{\n  "analyze": true\n  // Also updates query statistics\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    analyze: { 
                                        type: 'boolean',
                                        description: 'Optional: Whether to run ANALYZE after VACUUM to update database statistics. Defaults to false'
                                    }
                                }
                            }
                        },
                        {
                            name: 'repair_relationships',
                            description: 'Repair parent-child relationships and fix inconsistencies in the task hierarchy. Validates and corrects task relationships, orphaned tasks, and broken dependencies.\n\nBest Practices:\n- Run in dry-run mode first\n- Fix critical paths immediately\n- Schedule regular validation\n- Monitor repair results\n- Back up before repairs\n\nExample:\n{\n  "dryRun": true,\n  "pathPattern": "website/**"\n  // Check website hierarchy without making changes\n}',
                            inputSchema: {
                                type: 'object',
                                properties: {
                                    dryRun: { 
                                        type: 'boolean',
                                        description: 'Optional: If true, only report issues without fixing them. Useful for safely checking what would be repaired. Defaults to false'
                                    },
                                    pathPattern: { 
                                        type: 'string',
                                        description: 'Optional: Pattern to limit which tasks to check relationships for. If not provided, checks all tasks'
                                    }
                                }
                            }
                        }
                    ]
                }),
                handleToolCall: async (request) => {
                    const name = request.params?.name as string;
                    const args = request.params?.arguments as Record<string, any>;
                    const eventManager = EventManager.getInstance();
                    let result;

                    try {
                        // Emit tool start event
                        eventManager.emitSystemEvent({
                            type: EventTypes.TOOL_STARTED,
                            timestamp: Date.now(),
                            metadata: {
                                tool: name,
                                args
                            }
                        });

                        switch (name) {
                        case 'create_task':
                            result = await taskManager.createTask(args as CreateTaskInput);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'update_task':
                            result = await taskManager.updateTask(args.path as string, args.updates as UpdateTaskInput);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'delete_task':
                            await taskManager.deleteTask(args.path as string);
                            return {
                                content: [{
                                    type: 'text',
                                    text: 'Task deleted successfully'
                                }]
                            };
                        case 'get_tasks_by_status':
                            result = await taskManager.getTasksByStatus(args.status as TaskStatus);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'get_tasks_by_path':
                            result = await taskManager.listTasks(args.pattern as string);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'get_subtasks':
                            result = await taskManager.getSubtasks(args.parentPath as string);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'bulk_task_operations':
                            result = await taskManager.bulkTaskOperations(args.operations as Array<{ type: 'create' | 'update' | 'delete', path: string, data?: CreateTaskInput | UpdateTaskInput }>);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        case 'clear_all_tasks':
                            await taskManager.clearAllTasks(args.confirm as boolean);
                            return {
                                content: [{
                                    type: 'text',
                                    text: 'All tasks cleared successfully'
                                }]
                            };
                        case 'vacuum_database':
                            await taskManager.vacuumDatabase(args.analyze as boolean);
                            return {
                                content: [{
                                    type: 'text',
                                    text: 'Database vacuumed successfully'
                                }]
                            };
                        case 'repair_relationships':
                            result = await taskManager.repairRelationships(args.dryRun as boolean, args.pathPattern as string | undefined);
                            return {
                                content: [{
                                    type: 'text',
                                    text: JSON.stringify(result, null, 2)
                                }]
                            };
                        default:
                            throw createError(
                                ErrorCodes.INVALID_INPUT,
                                `Unknown tool: ${name}`,
                                'handleToolCall'
                            );
                    }
                } catch (error) {
                    // Emit tool error event
                    eventManager.emitErrorEvent({
                        type: EventTypes.SYSTEM_ERROR,
                        timestamp: Date.now(),
                        error: error instanceof Error ? error : new Error(String(error)),
                        context: {
                            component: 'ToolHandler',
                            operation: name,
                            args
                        }
                    });

                    // Format error response
                    const errorMessage = error instanceof BaseError 
                        ? error.getUserMessage()
                        : String(error);

                    return {
                        content: [{
                            type: 'text',
                            text: JSON.stringify({
                                error: errorMessage,
                                code: error instanceof BaseError ? error.code : ErrorCodes.INTERNAL_ERROR
                            }, null, 2)
                        }],
                        isError: true
                    };
                }
                },
                getStorageMetrics: async () => await storage.getMetrics(),
                clearCaches: async () => {
                    await taskManager.clearCaches();
                },
                cleanup: async () => {
                    await taskManager.close();
                }
            }
        );
        }
    } catch (error) {
        // Emit system error event
        eventManager.emitSystemEvent({
            type: EventTypes.SYSTEM_ERROR,
            timestamp: Date.now(),
            metadata: {
                error: error instanceof Error ? error : new Error(String(error))
            }
        });

        logger.error('Failed to start server', error);
        process.exit(1);
    }

    // Handle graceful shutdown
    const shutdown = async (reason: string = 'graceful_shutdown') => {
        try {
            // Emit system shutdown event
            eventManager.emitSystemEvent({
                type: EventTypes.SYSTEM_SHUTDOWN,
                timestamp: Date.now(),
                metadata: { reason }
            });

            // Cleanup in specific order to ensure proper shutdown
            try {
                // First stop accepting new requests
                if (server) {
                    await server.shutdown();
                }

                // Then cleanup task manager and its resources
                if (taskManager) {
                    await taskManager.cleanup();
                }

                // Finally close storage
                if (storage) {
                    await storage.close();
                }

                // Clear event manager
                eventManager.removeAllListeners();

                // Force final cleanup
                if (global.gc) {
                    global.gc();
                }

                // Remove process event listeners
                process.removeAllListeners();
            } catch (cleanupError) {
                logger.error('Error during component cleanup', cleanupError);
                // Continue with shutdown despite cleanup errors
            }

            // Final logging before exit
            logger.info('Server shutdown completed', { reason });
            
            // Exit after cleanup
            process.nextTick(() => process.exit(0));
        } catch (error) {
            logger.error('Error during shutdown', error);
            process.nextTick(() => process.exit(1));
        }
    };

    // Handle various shutdown signals with Windows compatibility
    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('beforeExit', () => shutdown('beforeExit'));
    
    // Windows-specific handling for CTRL+C and other termination signals
    if (process.platform === 'win32') {
        const readline = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        
        readline.on('SIGINT', () => {
            process.emit('SIGINT');
        });

        // Handle Windows-specific process termination
        process.on('SIGHUP', () => shutdown('SIGHUP'));
        process.on('SIGBREAK', () => shutdown('SIGBREAK'));
    }

    process.on('exit', () => {
        try {
            // Synchronous cleanup for exit event
            if (global.gc) {
                global.gc();
            }
        } catch (error) {
            console.error('Error during final cleanup:', error);
        }
    });
}

main().catch((error) => {
    // Get logger instance if available, otherwise fallback to console
    try {
        const logger = Logger.getInstance();
        logger.fatal('Fatal error during startup', error);
    } catch {
        // If logger isn't initialized, fallback to console
        console.error('Fatal error:', error);
    }
    process.exit(1);
});

================
File: task-manager.ts
================
/**
 * Path-based task manager implementation
 * Coordinates task operations, batch processing, validation, and resource management
 */
import { Task, TaskStatus, CreateTaskInput, UpdateTaskInput, TaskResponse } from './types/task.js';
import { TaskStorage } from './types/storage.js';
import { Logger } from './logging/index.js';
import { ErrorCodes, createError } from './errors/index.js';
import { EventManager } from './events/event-manager.js';
import { EventTypes } from './types/events.js';
import { TaskOperations } from './task/operations/task-operations.js';
import { TaskStatusBatchProcessor } from './task/core/batch/task-status-batch-processor.js';
import { DependencyAwareBatchProcessor } from './task/core/batch/dependency-aware-batch-processor.js';
import { TaskValidator } from './task/validation/task-validator.js';
import { CacheManager } from './task/core/cache/cache-manager.js';
import { CacheOptions } from './types/cache.js';
import { TaskIndexManager } from './task/core/indexing/index-manager.js';

export class TaskManager {
    private static logger: Logger;
    private operations!: TaskOperations;

    private static initLogger(): void {
        if (!TaskManager.logger) {
            TaskManager.logger = Logger.getInstance().child({ component: 'TaskManager' });
        }
    }
    private readonly validator: TaskValidator;
    private readonly statusBatchProcessor: TaskStatusBatchProcessor;
    private readonly dependencyBatchProcessor: DependencyAwareBatchProcessor;
    private readonly cacheManager: CacheManager;
    private readonly indexManager: TaskIndexManager;
    private memoryMonitor?: NodeJS.Timeout;
    private readonly MAX_CACHE_MEMORY = 1024 * 1024 * 1024; // 1GB cache limit
    private readonly MEMORY_CHECK_INTERVAL = 60000; // 60 seconds
    private readonly MEMORY_PRESSURE_THRESHOLD = 0.9; // 90% of max before cleanup

    private readonly eventManager: EventManager;

    private static instance: TaskManager | null = null;
    private static initializationPromise: Promise<TaskManager> | null = null;
    private initialized = false;

    private constructor(readonly storage: TaskStorage) {
        // Initialize basic components that don't require async operations
        TaskManager.initLogger();
        this.eventManager = EventManager.getInstance();
        this.validator = new TaskValidator(storage);
        
        // Initialize cache management
        const cacheOptions: CacheOptions = {
            maxSize: this.MAX_CACHE_MEMORY,
            ttl: 15 * 60 * 1000, // 15 minutes
            cleanupInterval: 5 * 60 * 1000 // 5 minutes
        };
        this.cacheManager = new CacheManager(cacheOptions);
        this.indexManager = new TaskIndexManager();

        // Initialize batch processors
        const batchDeps = {
            storage,
            validator: this.validator,
            logger: TaskManager.logger,
            cacheManager: this.cacheManager
        };
        this.statusBatchProcessor = new TaskStatusBatchProcessor(batchDeps);
        this.dependencyBatchProcessor = new DependencyAwareBatchProcessor(batchDeps);

        // Setup memory monitoring
        this.setupMemoryMonitoring();
    }

    /**
     * Initializes components that require async operations
     */
    private async initializeComponents(): Promise<void> {
        // Initialize task operations
        this.operations = await TaskOperations.getInstance(this.storage, this.validator);
    }

    /**
     * Gets the TaskManager instance
     */
    static async getInstance(storage: TaskStorage): Promise<TaskManager> {
        // Return existing instance if available
        if (TaskManager.instance && TaskManager.instance.initialized) {
            return TaskManager.instance;
        }

        // If initialization is in progress, wait for it
        if (TaskManager.initializationPromise) {
            return TaskManager.initializationPromise;
        }

        // Start new initialization with mutex
        TaskManager.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (TaskManager.instance && TaskManager.instance.initialized) {
                    return TaskManager.instance;
                }

                TaskManager.instance = new TaskManager(storage);
                await TaskManager.instance.initialize();
                return TaskManager.instance;
            } catch (error) {
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    `Failed to initialize TaskManager: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                TaskManager.initializationPromise = null;
            }
        })();

        return TaskManager.initializationPromise;
    }

    /**
     * Initializes task indexes from storage
     */
    private async initialize(): Promise<void> {
        if (this.initialized) {
            TaskManager.logger.debug('Task manager already initialized');
            return;
        }

        try {
            // Initialize async components first
            await this.initializeComponents();
            // Get all tasks and build indexes
            const tasks = await this.storage.getTasksByPattern('*');
            
            // Initialize indexes in batches to avoid memory pressure
            const batchSize = 100;
            for (let i = 0; i < tasks.length; i += batchSize) {
                const batch = tasks.slice(i, i + batchSize);
                for (const task of batch) {
                    await this.indexManager.indexTask(task);
                }
                // Allow GC between batches
                if (global.gc) {
                    global.gc();
                }
            }
            
            this.initialized = true;
            TaskManager.logger.info('Task indexes initialized', { taskCount: tasks.length });
        } catch (error) {
            TaskManager.logger.error('Failed to initialize task indexes', { error });
            throw error;
        }
    }

    /**
     * Creates a new task with path-based hierarchy
     */
    async createTask(input: CreateTaskInput): Promise<TaskResponse<Task>> {
        try {
            // Validate input
            if (!input.name) {
                throw createError(
                    ErrorCodes.VALIDATION_ERROR,
                    'Task name is required'
                );
            }

            const result = await this.operations.createTask(input);
            await this.indexManager.indexTask(result);

            TaskManager.logger.info('Task created successfully', {
                taskId: result.path,
                type: result.type,
                parentPath: input.parentPath
            });

            // Emit task created event
            this.eventManager.emitTaskEvent({
                type: EventTypes.TASK_CREATED,
                timestamp: Date.now(),
                taskId: result.path,
                task: result,
                metadata: { input }
            });
            return {
                success: true,
                data: result,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: result.projectPath,
                    affectedPaths: [result.path]
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to create task', {
                error,
                input,
                context: {
                    path: input.path,
                    parentPath: input.parentPath,
                    type: input.type
                }
            });
            throw error;
        }
    }

    /**
     * Updates an existing task
     */
    async updateTask(path: string, updates: UpdateTaskInput): Promise<TaskResponse<Task>> {
        try {
            const oldTask = await this.getTaskByPath(path);
            if (!oldTask) {
                throw createError(
                    ErrorCodes.TASK_NOT_FOUND,
                    `Task not found: ${path}`
                );
            }

            const result = await this.operations.updateTask(path, updates);
            await this.indexManager.indexTask(result);

            TaskManager.logger.info('Task updated successfully', {
                taskId: result.path,
                updates,
                oldStatus: oldTask.status,
                newStatus: result.status
            });

            // Emit task updated event
            this.eventManager.emitTaskEvent({
                type: EventTypes.TASK_UPDATED,
                timestamp: Date.now(),
                taskId: result.path,
                task: result,
                changes: {
                    before: oldTask,
                    after: result
                }
            });

            // Emit status change event if status was updated
            if (updates.status && oldTask.status !== updates.status) {
                this.eventManager.emitTaskEvent({
                    type: EventTypes.TASK_STATUS_CHANGED,
                    timestamp: Date.now(),
                    taskId: result.path,
                    task: result,
                    changes: {
                        before: { status: oldTask.status },
                        after: { status: updates.status }
                    }
                });
            }
            return {
                success: true,
                data: result,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: result.projectPath,
                    affectedPaths: [result.path]
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to update task', {
                error,
                context: {
                    path,
                    updates,
                    operation: 'updateTask'
                }
            });
            throw error;
        }
    }

    /**
     * Updates task statuses in bulk with dependency validation
     */
    async updateTaskStatuses(updates: { path: string; status: TaskStatus }[]): Promise<TaskResponse<Task[]>> {
        try {
            const batch = updates.map(update => ({
                id: update.path,
                data: {
                    path: update.path,
                    metadata: { newStatus: update.status }
                }
            }));

            const result = await this.statusBatchProcessor.execute(batch);
            
            if (result.errors.length > 0) {
                throw createError(
                    ErrorCodes.TASK_STATUS,
                    'Failed to update task statuses',
                    'updateTaskStatuses',
                    undefined,
                    {
                        errors: result.errors,
                        updates
                    }
                );
            }

            const tasks = result.results as Task[];
            
            // Update indexes
            for (const task of tasks) {
                await this.indexManager.indexTask(task);
            }

            return {
                success: true,
                data: tasks,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: tasks[0]?.projectPath || 'unknown',
                    affectedPaths: updates.map(u => u.path)
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to update task statuses', {
                error,
                updates
            });
            throw error;
        }
    }

    /**
     * Updates task dependencies in bulk with cycle detection
     */
    async updateTaskDependencies(updates: { path: string; dependencies: string[] }[]): Promise<TaskResponse<Task[]>> {
        try {
            const batch = updates.map(update => ({
                id: update.path,
                data: {
                    path: update.path,
                    dependencies: update.dependencies
                }
            }));

            const result = await this.dependencyBatchProcessor.execute(batch);

            if (result.errors.length > 0) {
                throw createError(
                    ErrorCodes.TASK_DEPENDENCY,
                    'Failed to update task dependencies',
                    'updateTaskDependencies',
                    undefined,
                    {
                        errors: result.errors,
                        updates
                    }
                );
            }

            const tasks = result.results as Task[];
            
            // Update indexes
            for (const task of tasks) {
                await this.indexManager.indexTask(task);
            }

            return {
                success: true,
                data: tasks,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: tasks[0]?.projectPath || 'unknown',
                    affectedPaths: updates.map(u => u.path)
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to update task dependencies', {
                error,
                updates
            });
            throw error;
        }
    }

    /**
     * Retrieves a task by its path
     */
    async getTaskByPath(path: string): Promise<Task | null> {
        try {
            const indexedTask = await this.indexManager.getTaskByPath(path);
            if (!indexedTask) {
                return null;
            }
            return {
                ...indexedTask,
                metadata: indexedTask.metadata || {},
                dependencies: indexedTask.dependencies || [],
                subtasks: indexedTask.subtasks || []
            };
        } catch (error) {
            TaskManager.logger.error('Failed to get task by path', { error, path });
            throw error;
        }
    }

    /**
     * Lists tasks matching a path pattern
     */
    async listTasks(pathPattern: string): Promise<Task[]> {
        try {
            const indexedTasks = await this.indexManager.getTasksByPattern(pathPattern);
            return indexedTasks.map(t => ({
                ...t,
                metadata: t.metadata || {},
                dependencies: t.dependencies || [],
                subtasks: t.subtasks || []
            }));
        } catch (error) {
            TaskManager.logger.error('Failed to list tasks', { error, pathPattern });
            throw error;
        }
    }

    /**
     * Gets tasks by status
     */
    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        try {
            const indexedTasks = await this.indexManager.getTasksByStatus(status);
            return indexedTasks.map(t => ({
                ...t,
                metadata: t.metadata || {},
                dependencies: t.dependencies || [],
                subtasks: t.subtasks || []
            }));
        } catch (error) {
            TaskManager.logger.error('Failed to get tasks by status', { error, status });
            throw error;
        }
    }

    /**
     * Gets subtasks of a task
     */
    async getSubtasks(parentPath: string): Promise<Task[]> {
        try {
            const indexedTasks = await this.indexManager.getTasksByParent(parentPath);
            return indexedTasks.map(t => ({
                ...t,
                metadata: t.metadata || {},
                dependencies: t.dependencies || [],
                subtasks: t.subtasks || []
            }));
        } catch (error) {
            TaskManager.logger.error('Failed to get subtasks', { error, parentPath });
            throw error;
        }
    }

    /**
     * Deletes a task and its subtasks
     */
    async deleteTask(path: string): Promise<TaskResponse<void>> {
        try {
            const task = await this.storage.getTask(path);
            if (task) {
                // Emit task deleted event before deletion
                this.eventManager.emitTaskEvent({
                    type: EventTypes.TASK_DELETED,
                    timestamp: Date.now(),
                    taskId: task.path,
                    task: task
                });
                await this.indexManager.unindexTask(task);
            }
            await this.operations.deleteTask(path);
            return {
                success: true,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: path.split('/')[0],
                    affectedPaths: [path]
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to delete task', {
                error,
                context: {
                    path,
                    operation: 'deleteTask'
                }
            });
            throw error;
        }
    }

    /**
     * Clears all tasks from the database and resets all caches
     */
    async clearAllTasks(confirm: boolean): Promise<void> {
        if (!confirm) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Must explicitly confirm task deletion',
                'clearAllTasks',
                'Set confirm parameter to true to proceed with clearing all tasks. This operation cannot be undone.',
                {
                    context: 'Clear all tasks',
                    required: 'explicit confirmation'
                }
            );
        }

        try {
            // Get count of tasks before deletion for logging
            const tasks = await this.storage.getTasksByPattern('*');
            const taskCount = tasks.length;

            // Start transaction for clearing all tasks
            await this.storage.beginTransaction();

            try {
                // Clear all tasks and reset database
                await this.storage.clearAllTasks();
                this.indexManager.clear();

                // Clear all caches and force cleanup
                await this.clearCaches();

                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }

                await this.storage.commitTransaction();
                
                // Optimize database after transaction is complete
                try {
                    await this.storage.vacuum();
                    await this.storage.analyze();
                    await this.storage.checkpoint();
                } catch (optimizeError) {
                    // Log but don't fail if optimization fails
                    TaskManager.logger.warn('Failed to optimize database after clearing tasks', { 
                        error: optimizeError,
                        operation: 'clearAllTasks'
                    });
                }

                TaskManager.logger.info('Database and caches reset', {
                    tasksCleared: taskCount,
                    operation: 'clearAllTasks'
                });
            } catch (error) {
                // Rollback transaction on error
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            TaskManager.logger.error('Failed to clear tasks', {
                error,
                context: {
                    operation: 'clearAllTasks',
                    confirm
                }
            });
            throw error;
        }
    }

    /**
     * Optimizes database storage and performance
     */
    async vacuumDatabase(analyze: boolean = true): Promise<void> {
        try {
            await this.storage.vacuum();
            if (analyze) {
                await this.storage.analyze();
            }
            await this.storage.checkpoint();
            TaskManager.logger.info('Database optimized', { analyzed: analyze });
        } catch (error) {
            TaskManager.logger.error('Failed to optimize database', { error });
            throw error;
        }
    }

    /**
     * Repairs parent-child relationships and fixes inconsistencies
     */
    async repairRelationships(dryRun: boolean = false, pathPattern?: string): Promise<{ fixed: number, issues: string[] }> {
        try {
            const result = await this.storage.repairRelationships(dryRun);
            if (!dryRun) {
                // Reinitialize indexes after repair
                await this.initialize();
            }
            TaskManager.logger.info('Relationship repair completed', { 
                dryRun,
                pathPattern,
                fixed: result.fixed,
                issueCount: result.issues.length
            });
            return result;
        } catch (error) {
            TaskManager.logger.error('Failed to repair relationships', { error });
            throw error;
        }
    }

    /**
     * Sets up memory monitoring for cache management
     */
    private setupMemoryMonitoring(): void {
        // Clear any existing monitor
        if (this.memoryMonitor) {
            clearInterval(this.memoryMonitor);
        }

        // Set up new monitor with weak reference to this
        const weakThis = new WeakRef(this);
        
        this.memoryMonitor = setInterval(async () => {
            const instance = weakThis.deref();
            if (!instance) {
                // If instance is garbage collected, stop monitoring
                clearInterval(this.memoryMonitor);
                return;
            }

            const memUsage = process.memoryUsage();
            
            // Log memory stats with Windows-specific handling
            const stats = {
                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
                // Windows can have different memory reporting
                platform: process.platform
            };
            
            TaskManager.logger.debug('Task manager memory usage:', stats);

            // Check if memory usage is approaching threshold
            const memoryUsageRatio = memUsage.heapUsed / instance.MAX_CACHE_MEMORY;
            
            if (memoryUsageRatio > instance.MEMORY_PRESSURE_THRESHOLD) {
                // Emit memory pressure event
                instance.eventManager.emitCacheEvent({
                    type: EventTypes.MEMORY_PRESSURE,
                    timestamp: Date.now(),
                    metadata: {
                        memoryUsage: memUsage,
                        threshold: instance.MAX_CACHE_MEMORY
                    }
                });

                TaskManager.logger.warn('Cache memory threshold exceeded, clearing caches', {
                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                    threshold: `${Math.round(instance.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
                });
                
                await instance.clearCaches(true);
            }
        }, this.MEMORY_CHECK_INTERVAL);

        // Ensure interval is cleaned up if process exits
        process.on('beforeExit', () => {
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
            }
        });
    }

    /**
     * Clears all caches to free memory
     */
    async clearCaches(forceClean: boolean = false): Promise<void> {
        try {
            // Clear storage and manager caches
            await this.cacheManager.clear();
            this.indexManager.clear();

            // Force garbage collection if available
            if (global.gc) {
                global.gc();
                
                // Check if GC helped
                const afterGC = process.memoryUsage();
                if (forceClean && afterGC.heapUsed > (this.MAX_CACHE_MEMORY * this.MEMORY_PRESSURE_THRESHOLD)) {
                    // If memory is still high after aggressive cleanup, log warning
                    TaskManager.logger.warn('Memory usage remains high after cleanup', {
                        heapUsed: `${Math.round(afterGC.heapUsed / 1024 / 1024)}MB`,
                        threshold: `${Math.round(this.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
                    });
                }
            }

            TaskManager.logger.info('Caches cleared successfully');
        } catch (error) {
            TaskManager.logger.error('Failed to clear caches', { error });
            throw error;
        }
    }

    /**
     * Gets current memory usage statistics
     */
    getMemoryStats(): { heapUsed: number; heapTotal: number; rss: number } {
        const memUsage = process.memoryUsage();
        return {
            heapUsed: memUsage.heapUsed,
            heapTotal: memUsage.heapTotal,
            rss: memUsage.rss
        };
    }

    /**
     * Cleans up resources and closes connections
     */
    async cleanup(): Promise<void> {
        try {
            // Stop memory monitoring first
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
                this.memoryMonitor = undefined;
            }

            // Clear caches with force clean
            await this.clearCaches(true);

            // Cleanup batch processors
            try {
                if (this.statusBatchProcessor) {
                    await (this.statusBatchProcessor as any).cleanup?.();
                }
                if (this.dependencyBatchProcessor) {
                    await (this.dependencyBatchProcessor as any).cleanup?.();
                }
            } catch (batchError) {
                TaskManager.logger.warn('Error cleaning up batch processors', { error: batchError });
            }

            // Cleanup operations
            try {
                if (this.operations) {
                    await (this.operations as any).cleanup?.();
                }
            } catch (opsError) {
                TaskManager.logger.warn('Error cleaning up operations', { error: opsError });
            }

            // Remove event listeners
            try {
                this.eventManager.removeAllListeners();
            } catch (eventError) {
                TaskManager.logger.warn('Error cleaning up event listeners', { error: eventError });
            }

            // Cleanup index manager
            try {
                await this.indexManager.clear();
            } catch (indexError) {
                TaskManager.logger.warn('Error cleaning up index manager', { error: indexError });
            }

            // Close storage last
            if (this.storage) {
                await this.storage.close();
            }

            // Force final GC if available
            if (global.gc) {
                global.gc();
            }

            TaskManager.logger.info('Task manager cleanup completed');
        } catch (error) {
            TaskManager.logger.error('Failed to cleanup task manager', { error });
            throw error;
        } finally {
            // Ensure memory monitor is cleared even if cleanup fails
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
                this.memoryMonitor = undefined;
            }
        }
    }

    /**
     * Closes the task manager and releases resources
     */
    async close(): Promise<void> {
        await this.cleanup();
    }

    /**
     * Executes multiple task operations in a single transaction
     * Handles create, update, and delete operations with proper validation
     * and dependency management through TaskOperations
     */
    async bulkTaskOperations(operations: { type: 'create' | 'update' | 'delete', path: string, data?: CreateTaskInput | UpdateTaskInput }[]): Promise<TaskResponse<Task[]>> {
        try {
            const results: Task[] = [];
            const errors: Error[] = [];

            // Start transaction
            await this.storage.beginTransaction();

            try {
                for (const op of operations) {
                    try {
                        switch (op.type) {
                            case 'create':
                                if (!op.data || !('type' in op.data)) {
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        'Create operation requires valid task input'
                                    );
                                }
                                const created = await this.operations.createTask(op.data as CreateTaskInput);
                                await this.indexManager.indexTask(created);
                                results.push(created);

                                // Emit task created event
                                this.eventManager.emitTaskEvent({
                                    type: EventTypes.TASK_CREATED,
                                    timestamp: Date.now(),
                                    taskId: created.path,
                                    task: created,
                                    metadata: { input: op.data }
                                });

                                TaskManager.logger.info('Task created in bulk operation', {
                                    taskId: created.path,
                                    type: created.type
                                });
                                break;

                            case 'update':
                                if (!op.data) {
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        'Update operation requires task updates'
                                    );
                                }
                                const oldTask = await this.getTaskByPath(op.path);
                                if (!oldTask) {
                                    throw createError(
                                        ErrorCodes.TASK_NOT_FOUND,
                                        `Task not found: ${op.path}`
                                    );
                                }

                                const updated = await this.operations.updateTask(op.path, op.data as UpdateTaskInput);
                                await this.indexManager.indexTask(updated);
                                results.push(updated);

                                // Emit task updated event
                                this.eventManager.emitTaskEvent({
                                    type: EventTypes.TASK_UPDATED,
                                    timestamp: Date.now(),
                                    taskId: updated.path,
                                    task: updated,
                                    changes: {
                                        before: oldTask,
                                        after: updated
                                    }
                                });

                                TaskManager.logger.info('Task updated in bulk operation', {
                                    taskId: updated.path,
                                    updates: op.data
                                });
                                break;

                            case 'delete':
                                const task = await this.storage.getTask(op.path);
                                if (task) {
                                    // Emit task deleted event before deletion
                                    this.eventManager.emitTaskEvent({
                                        type: EventTypes.TASK_DELETED,
                                        timestamp: Date.now(),
                                        taskId: task.path,
                                        task: task
                                    });

                                    await this.indexManager.unindexTask(task);
                                    TaskManager.logger.info('Task deleted in bulk operation', {
                                        taskId: task.path
                                    });
                                }
                                await this.operations.deleteTask(op.path);
                                break;
                        }
                    } catch (error) {
                        errors.push(error as Error);
                        TaskManager.logger.error('Failed to execute bulk operation', {
                            error,
                            operation: op
                        });
                    }
                }

                // Commit transaction if no errors
                if (errors.length === 0) {
                    await this.storage.commitTransaction();
                } else {
                    await this.storage.rollbackTransaction();
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'Failed to execute bulk operations',
                        'bulkTaskOperations',
                        undefined,
                        {
                            errors,
                            operations
                        }
                    );
                }

                return {
                    success: true,
                    data: results,
                    metadata: {
                        timestamp: Date.now(),
                        requestId: Math.random().toString(36).substring(7),
                        projectPath: results[0]?.projectPath || 'unknown',
                        affectedPaths: operations.map(op => op.path)
                    }
                };
            } catch (error) {
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            TaskManager.logger.error('Failed to execute bulk operations', { error });
            throw error;
        }
    }
}

================
File: src/task-manager.ts
================
/**
 * Path-based task manager implementation
 * Coordinates task operations, batch processing, validation, and resource management
 */
import { Task, TaskStatus, CreateTaskInput, UpdateTaskInput, TaskResponse } from './types/task.js';
import { TaskStorage } from './types/storage.js';
import { Logger } from './logging/index.js';
import { ErrorCodes, createError } from './errors/index.js';
import { EventManager } from './events/event-manager.js';
import { EventTypes } from './types/events.js';
import { TaskOperations } from './task/operations/task-operations.js';
import { TaskStatusBatchProcessor } from './task/core/batch/task-status-batch-processor.js';
import { DependencyAwareBatchProcessor } from './task/core/batch/dependency-aware-batch-processor.js';
import { TaskValidator } from './task/validation/task-validator.js';
import { CacheManager } from './task/core/cache/cache-manager.js';
import { CacheOptions } from './types/cache.js';
import { TaskIndexManager } from './task/core/indexing/index-manager.js';

export class TaskManager {
    private static logger: Logger;
    private operations!: TaskOperations;

    private static initLogger(): void {
        if (!TaskManager.logger) {
            TaskManager.logger = Logger.getInstance().child({ component: 'TaskManager' });
        }
    }
    private readonly validator: TaskValidator;
    private readonly statusBatchProcessor: TaskStatusBatchProcessor;
    private readonly dependencyBatchProcessor: DependencyAwareBatchProcessor;
    private readonly cacheManager: CacheManager;
    private readonly indexManager: TaskIndexManager;
    private memoryMonitor?: NodeJS.Timeout;
    private readonly MAX_CACHE_MEMORY = 1024 * 1024 * 1024; // 1GB cache limit
    private readonly MEMORY_CHECK_INTERVAL = 60000; // 60 seconds
    private readonly MEMORY_PRESSURE_THRESHOLD = 0.9; // 90% of max before cleanup

    private readonly eventManager: EventManager;

    private static instance: TaskManager | null = null;
    private static initializationPromise: Promise<TaskManager> | null = null;
    private initialized = false;

    private constructor(readonly storage: TaskStorage) {
        // Initialize basic components that don't require async operations
        TaskManager.initLogger();
        this.eventManager = EventManager.getInstance();
        this.validator = new TaskValidator(storage);
        
        // Initialize cache management
        const cacheOptions: CacheOptions = {
            maxSize: this.MAX_CACHE_MEMORY,
            ttl: 15 * 60 * 1000, // 15 minutes
            cleanupInterval: 5 * 60 * 1000 // 5 minutes
        };
        this.cacheManager = new CacheManager(cacheOptions);
        this.indexManager = new TaskIndexManager();

        // Initialize batch processors
        const batchDeps = {
            storage,
            validator: this.validator,
            logger: TaskManager.logger,
            cacheManager: this.cacheManager
        };
        this.statusBatchProcessor = new TaskStatusBatchProcessor(batchDeps);
        this.dependencyBatchProcessor = new DependencyAwareBatchProcessor(batchDeps);

        // Setup memory monitoring
        this.setupMemoryMonitoring();
    }

    /**
     * Initializes components that require async operations
     */
    private async initializeComponents(): Promise<void> {
        // Initialize task operations
        this.operations = await TaskOperations.getInstance(this.storage, this.validator);
    }

    /**
     * Gets the TaskManager instance
     */
    static async getInstance(storage: TaskStorage): Promise<TaskManager> {
        // Return existing instance if available
        if (TaskManager.instance && TaskManager.instance.initialized) {
            return TaskManager.instance;
        }

        // If initialization is in progress, wait for it
        if (TaskManager.initializationPromise) {
            return TaskManager.initializationPromise;
        }

        // Start new initialization with mutex
        TaskManager.initializationPromise = (async () => {
            try {
                // Double-check instance hasn't been created while waiting
                if (TaskManager.instance && TaskManager.instance.initialized) {
                    return TaskManager.instance;
                }

                TaskManager.instance = new TaskManager(storage);
                await TaskManager.instance.initialize();
                return TaskManager.instance;
            } catch (error) {
                throw createError(
                    ErrorCodes.STORAGE_INIT,
                    `Failed to initialize TaskManager: ${error instanceof Error ? error.message : String(error)}`
                );
            } finally {
                TaskManager.initializationPromise = null;
            }
        })();

        return TaskManager.initializationPromise;
    }

    /**
     * Initializes task indexes from storage
     */
    private async initialize(): Promise<void> {
        if (this.initialized) {
            TaskManager.logger.debug('Task manager already initialized');
            return;
        }

        try {
            // Initialize async components first
            await this.initializeComponents();
            // Get all tasks and build indexes
            const tasks = await this.storage.getTasksByPattern('*');
            
            // Initialize indexes in batches to avoid memory pressure
            const batchSize = 100;
            for (let i = 0; i < tasks.length; i += batchSize) {
                const batch = tasks.slice(i, i + batchSize);
                for (const task of batch) {
                    await this.indexManager.indexTask(task);
                }
                // Allow GC between batches
                if (global.gc) {
                    global.gc();
                }
            }
            
            this.initialized = true;
            TaskManager.logger.info('Task indexes initialized', { taskCount: tasks.length });
        } catch (error) {
            TaskManager.logger.error('Failed to initialize task indexes', { error });
            throw error;
        }
    }

    /**
     * Creates a new task with path-based hierarchy
     */
    async createTask(input: CreateTaskInput): Promise<TaskResponse<Task>> {
        try {
            // Validate input
            if (!input.name) {
                throw createError(
                    ErrorCodes.VALIDATION_ERROR,
                    'Task name is required'
                );
            }

            const result = await this.operations.createTask(input);
            await this.indexManager.indexTask(result);

            TaskManager.logger.info('Task created successfully', {
                taskId: result.path,
                type: result.type,
                parentPath: input.parentPath
            });

            // Emit task created event
            this.eventManager.emitTaskEvent({
                type: EventTypes.TASK_CREATED,
                timestamp: Date.now(),
                taskId: result.path,
                task: result,
                metadata: { input }
            });
            return {
                success: true,
                data: result,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: result.projectPath,
                    affectedPaths: [result.path]
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to create task', {
                error,
                input,
                context: {
                    path: input.path,
                    parentPath: input.parentPath,
                    type: input.type
                }
            });
            throw error;
        }
    }

    /**
     * Updates an existing task
     */
    async updateTask(path: string, updates: UpdateTaskInput): Promise<TaskResponse<Task>> {
        try {
            const oldTask = await this.getTaskByPath(path);
            if (!oldTask) {
                throw createError(
                    ErrorCodes.TASK_NOT_FOUND,
                    `Task not found: ${path}`
                );
            }

            const result = await this.operations.updateTask(path, updates);
            await this.indexManager.indexTask(result);

            TaskManager.logger.info('Task updated successfully', {
                taskId: result.path,
                updates,
                oldStatus: oldTask.status,
                newStatus: result.status
            });

            // Emit task updated event
            this.eventManager.emitTaskEvent({
                type: EventTypes.TASK_UPDATED,
                timestamp: Date.now(),
                taskId: result.path,
                task: result,
                changes: {
                    before: oldTask,
                    after: result
                }
            });

            // Emit status change event if status was updated
            if (updates.status && oldTask.status !== updates.status) {
                this.eventManager.emitTaskEvent({
                    type: EventTypes.TASK_STATUS_CHANGED,
                    timestamp: Date.now(),
                    taskId: result.path,
                    task: result,
                    changes: {
                        before: { status: oldTask.status },
                        after: { status: updates.status }
                    }
                });
            }
            return {
                success: true,
                data: result,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: result.projectPath,
                    affectedPaths: [result.path]
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to update task', {
                error,
                context: {
                    path,
                    updates,
                    operation: 'updateTask'
                }
            });
            throw error;
        }
    }

    /**
     * Updates task statuses in bulk with dependency validation
     */
    async updateTaskStatuses(updates: { path: string; status: TaskStatus }[]): Promise<TaskResponse<Task[]>> {
        try {
            const batch = updates.map(update => ({
                id: update.path,
                data: {
                    path: update.path,
                    metadata: { newStatus: update.status }
                }
            }));

            const result = await this.statusBatchProcessor.execute(batch);
            
            if (result.errors.length > 0) {
                throw createError(
                    ErrorCodes.TASK_STATUS,
                    'Failed to update task statuses',
                    'updateTaskStatuses',
                    undefined,
                    {
                        errors: result.errors,
                        updates
                    }
                );
            }

            const tasks = result.results as Task[];
            
            // Update indexes
            for (const task of tasks) {
                await this.indexManager.indexTask(task);
            }

            return {
                success: true,
                data: tasks,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: tasks[0]?.projectPath || 'unknown',
                    affectedPaths: updates.map(u => u.path)
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to update task statuses', {
                error,
                updates
            });
            throw error;
        }
    }

    /**
     * Updates task dependencies in bulk with cycle detection
     */
    async updateTaskDependencies(updates: { path: string; dependencies: string[] }[]): Promise<TaskResponse<Task[]>> {
        try {
            const batch = updates.map(update => ({
                id: update.path,
                data: {
                    path: update.path,
                    dependencies: update.dependencies
                }
            }));

            const result = await this.dependencyBatchProcessor.execute(batch);

            if (result.errors.length > 0) {
                throw createError(
                    ErrorCodes.TASK_DEPENDENCY,
                    'Failed to update task dependencies',
                    'updateTaskDependencies',
                    undefined,
                    {
                        errors: result.errors,
                        updates
                    }
                );
            }

            const tasks = result.results as Task[];
            
            // Update indexes
            for (const task of tasks) {
                await this.indexManager.indexTask(task);
            }

            return {
                success: true,
                data: tasks,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: tasks[0]?.projectPath || 'unknown',
                    affectedPaths: updates.map(u => u.path)
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to update task dependencies', {
                error,
                updates
            });
            throw error;
        }
    }

    /**
     * Retrieves a task by its path
     */
    async getTaskByPath(path: string): Promise<Task | null> {
        try {
            const indexedTask = await this.indexManager.getTaskByPath(path);
            if (!indexedTask) {
                return null;
            }
            return {
                ...indexedTask,
                metadata: indexedTask.metadata || {},
                dependencies: indexedTask.dependencies || [],
                subtasks: indexedTask.subtasks || []
            };
        } catch (error) {
            TaskManager.logger.error('Failed to get task by path', { error, path });
            throw error;
        }
    }

    /**
     * Lists tasks matching a path pattern
     */
    async listTasks(pathPattern: string): Promise<Task[]> {
        try {
            const indexedTasks = await this.indexManager.getTasksByPattern(pathPattern);
            return indexedTasks.map(t => ({
                ...t,
                metadata: t.metadata || {},
                dependencies: t.dependencies || [],
                subtasks: t.subtasks || []
            }));
        } catch (error) {
            TaskManager.logger.error('Failed to list tasks', { error, pathPattern });
            throw error;
        }
    }

    /**
     * Gets tasks by status
     */
    async getTasksByStatus(status: TaskStatus): Promise<Task[]> {
        try {
            const indexedTasks = await this.indexManager.getTasksByStatus(status);
            return indexedTasks.map(t => ({
                ...t,
                metadata: t.metadata || {},
                dependencies: t.dependencies || [],
                subtasks: t.subtasks || []
            }));
        } catch (error) {
            TaskManager.logger.error('Failed to get tasks by status', { error, status });
            throw error;
        }
    }

    /**
     * Gets subtasks of a task
     */
    async getSubtasks(parentPath: string): Promise<Task[]> {
        try {
            const indexedTasks = await this.indexManager.getTasksByParent(parentPath);
            return indexedTasks.map(t => ({
                ...t,
                metadata: t.metadata || {},
                dependencies: t.dependencies || [],
                subtasks: t.subtasks || []
            }));
        } catch (error) {
            TaskManager.logger.error('Failed to get subtasks', { error, parentPath });
            throw error;
        }
    }

    /**
     * Deletes a task and its subtasks
     */
    async deleteTask(path: string): Promise<TaskResponse<void>> {
        try {
            const task = await this.storage.getTask(path);
            if (task) {
                // Emit task deleted event before deletion
                this.eventManager.emitTaskEvent({
                    type: EventTypes.TASK_DELETED,
                    timestamp: Date.now(),
                    taskId: task.path,
                    task: task
                });
                await this.indexManager.unindexTask(task);
            }
            await this.operations.deleteTask(path);
            return {
                success: true,
                metadata: {
                    timestamp: Date.now(),
                    requestId: Math.random().toString(36).substring(7),
                    projectPath: path.split('/')[0],
                    affectedPaths: [path]
                }
            };
        } catch (error) {
            TaskManager.logger.error('Failed to delete task', {
                error,
                context: {
                    path,
                    operation: 'deleteTask'
                }
            });
            throw error;
        }
    }

    /**
     * Clears all tasks from the database and resets all caches
     */
    async clearAllTasks(confirm: boolean): Promise<void> {
        if (!confirm) {
            throw createError(
                ErrorCodes.INVALID_INPUT,
                'Must explicitly confirm task deletion',
                'clearAllTasks',
                'Set confirm parameter to true to proceed with clearing all tasks. This operation cannot be undone.',
                {
                    context: 'Clear all tasks',
                    required: 'explicit confirmation'
                }
            );
        }

        try {
            // Get count of tasks before deletion for logging
            const tasks = await this.storage.getTasksByPattern('*');
            const taskCount = tasks.length;

            // Start transaction for clearing all tasks
            await this.storage.beginTransaction();

            try {
                // Clear all tasks and reset database
                await this.storage.clearAllTasks();
                this.indexManager.clear();

                // Clear all caches and force cleanup
                await this.clearCaches();

                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }

                await this.storage.commitTransaction();
                
                // Optimize database after transaction is complete
                try {
                    await this.storage.vacuum();
                    await this.storage.analyze();
                    await this.storage.checkpoint();
                } catch (optimizeError) {
                    // Log but don't fail if optimization fails
                    TaskManager.logger.warn('Failed to optimize database after clearing tasks', { 
                        error: optimizeError,
                        operation: 'clearAllTasks'
                    });
                }

                TaskManager.logger.info('Database and caches reset', {
                    tasksCleared: taskCount,
                    operation: 'clearAllTasks'
                });
            } catch (error) {
                // Rollback transaction on error
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            TaskManager.logger.error('Failed to clear tasks', {
                error,
                context: {
                    operation: 'clearAllTasks',
                    confirm
                }
            });
            throw error;
        }
    }

    /**
     * Optimizes database storage and performance
     */
    async vacuumDatabase(analyze: boolean = true): Promise<void> {
        try {
            await this.storage.vacuum();
            if (analyze) {
                await this.storage.analyze();
            }
            await this.storage.checkpoint();
            TaskManager.logger.info('Database optimized', { analyzed: analyze });
        } catch (error) {
            TaskManager.logger.error('Failed to optimize database', { error });
            throw error;
        }
    }

    /**
     * Repairs parent-child relationships and fixes inconsistencies
     */
    async repairRelationships(dryRun: boolean = false, pathPattern?: string): Promise<{ fixed: number, issues: string[] }> {
        try {
            const result = await this.storage.repairRelationships(dryRun);
            if (!dryRun) {
                // Reinitialize indexes after repair
                await this.initialize();
            }
            TaskManager.logger.info('Relationship repair completed', { 
                dryRun,
                pathPattern,
                fixed: result.fixed,
                issueCount: result.issues.length
            });
            return result;
        } catch (error) {
            TaskManager.logger.error('Failed to repair relationships', { error });
            throw error;
        }
    }

    /**
     * Sets up memory monitoring for cache management
     */
    private setupMemoryMonitoring(): void {
        // Clear any existing monitor
        if (this.memoryMonitor) {
            clearInterval(this.memoryMonitor);
        }

        // Set up new monitor with weak reference to this
        const weakThis = new WeakRef(this);
        
        this.memoryMonitor = setInterval(async () => {
            const instance = weakThis.deref();
            if (!instance) {
                // If instance is garbage collected, stop monitoring
                clearInterval(this.memoryMonitor);
                return;
            }

            const memUsage = process.memoryUsage();
            
            // Log memory stats with Windows-specific handling
            const stats = {
                heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
                rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
                // Windows can have different memory reporting
                platform: process.platform
            };
            
            TaskManager.logger.debug('Task manager memory usage:', stats);

            // Check if memory usage is approaching threshold
            const memoryUsageRatio = memUsage.heapUsed / instance.MAX_CACHE_MEMORY;
            
            if (memoryUsageRatio > instance.MEMORY_PRESSURE_THRESHOLD) {
                // Emit memory pressure event
                instance.eventManager.emitCacheEvent({
                    type: EventTypes.MEMORY_PRESSURE,
                    timestamp: Date.now(),
                    metadata: {
                        memoryUsage: memUsage,
                        threshold: instance.MAX_CACHE_MEMORY
                    }
                });

                TaskManager.logger.warn('Cache memory threshold exceeded, clearing caches', {
                    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
                    threshold: `${Math.round(instance.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
                });
                
                await instance.clearCaches(true);
            }
        }, this.MEMORY_CHECK_INTERVAL);

        // Ensure interval is cleaned up if process exits
        process.on('beforeExit', () => {
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
            }
        });
    }

    /**
     * Clears all caches to free memory
     */
    async clearCaches(forceClean: boolean = false): Promise<void> {
        try {
            // Clear storage and manager caches
            await this.cacheManager.clear();
            this.indexManager.clear();

            // Force garbage collection if available
            if (global.gc) {
                global.gc();
                
                // Check if GC helped
                const afterGC = process.memoryUsage();
                if (forceClean && afterGC.heapUsed > (this.MAX_CACHE_MEMORY * this.MEMORY_PRESSURE_THRESHOLD)) {
                    // If memory is still high after aggressive cleanup, log warning
                    TaskManager.logger.warn('Memory usage remains high after cleanup', {
                        heapUsed: `${Math.round(afterGC.heapUsed / 1024 / 1024)}MB`,
                        threshold: `${Math.round(this.MAX_CACHE_MEMORY / 1024 / 1024)}MB`
                    });
                }
            }

            TaskManager.logger.info('Caches cleared successfully');
        } catch (error) {
            TaskManager.logger.error('Failed to clear caches', { error });
            throw error;
        }
    }

    /**
     * Gets current memory usage statistics
     */
    getMemoryStats(): { heapUsed: number; heapTotal: number; rss: number } {
        const memUsage = process.memoryUsage();
        return {
            heapUsed: memUsage.heapUsed,
            heapTotal: memUsage.heapTotal,
            rss: memUsage.rss
        };
    }

    /**
     * Cleans up resources and closes connections
     */
    async cleanup(): Promise<void> {
        try {
            // Stop memory monitoring first
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
                this.memoryMonitor = undefined;
            }

            // Clear caches with force clean
            await this.clearCaches(true);

            // Cleanup batch processors
            try {
                if (this.statusBatchProcessor) {
                    await (this.statusBatchProcessor as any).cleanup?.();
                }
                if (this.dependencyBatchProcessor) {
                    await (this.dependencyBatchProcessor as any).cleanup?.();
                }
            } catch (batchError) {
                TaskManager.logger.warn('Error cleaning up batch processors', { error: batchError });
            }

            // Cleanup operations
            try {
                if (this.operations) {
                    await (this.operations as any).cleanup?.();
                }
            } catch (opsError) {
                TaskManager.logger.warn('Error cleaning up operations', { error: opsError });
            }

            // Remove event listeners
            try {
                this.eventManager.removeAllListeners();
            } catch (eventError) {
                TaskManager.logger.warn('Error cleaning up event listeners', { error: eventError });
            }

            // Cleanup index manager
            try {
                await this.indexManager.clear();
            } catch (indexError) {
                TaskManager.logger.warn('Error cleaning up index manager', { error: indexError });
            }

            // Close storage last
            if (this.storage) {
                await this.storage.close();
            }

            // Force final GC if available
            if (global.gc) {
                global.gc();
            }

            TaskManager.logger.info('Task manager cleanup completed');
        } catch (error) {
            TaskManager.logger.error('Failed to cleanup task manager', { error });
            throw error;
        } finally {
            // Ensure memory monitor is cleared even if cleanup fails
            if (this.memoryMonitor) {
                clearInterval(this.memoryMonitor);
                this.memoryMonitor = undefined;
            }
        }
    }

    /**
     * Closes the task manager and releases resources
     */
    async close(): Promise<void> {
        await this.cleanup();
    }

    /**
     * Executes multiple task operations in a single transaction
     * Handles create, update, and delete operations with proper validation
     * and dependency management through TaskOperations
     */
    async bulkTaskOperations(operations: { type: 'create' | 'update' | 'delete', path: string, data?: CreateTaskInput | UpdateTaskInput }[]): Promise<TaskResponse<Task[]>> {
        try {
            const results: Task[] = [];
            const errors: Error[] = [];

            // Start transaction
            await this.storage.beginTransaction();

            try {
                for (const op of operations) {
                    try {
                        switch (op.type) {
                            case 'create':
                                if (!op.data || !('type' in op.data)) {
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        'Create operation requires valid task input'
                                    );
                                }
                                const created = await this.operations.createTask(op.data as CreateTaskInput);
                                await this.indexManager.indexTask(created);
                                results.push(created);

                                // Emit task created event
                                this.eventManager.emitTaskEvent({
                                    type: EventTypes.TASK_CREATED,
                                    timestamp: Date.now(),
                                    taskId: created.path,
                                    task: created,
                                    metadata: { input: op.data }
                                });

                                TaskManager.logger.info('Task created in bulk operation', {
                                    taskId: created.path,
                                    type: created.type
                                });
                                break;

                            case 'update':
                                if (!op.data) {
                                    throw createError(
                                        ErrorCodes.INVALID_INPUT,
                                        'Update operation requires task updates'
                                    );
                                }
                                const oldTask = await this.getTaskByPath(op.path);
                                if (!oldTask) {
                                    throw createError(
                                        ErrorCodes.TASK_NOT_FOUND,
                                        `Task not found: ${op.path}`
                                    );
                                }

                                const updated = await this.operations.updateTask(op.path, op.data as UpdateTaskInput);
                                await this.indexManager.indexTask(updated);
                                results.push(updated);

                                // Emit task updated event
                                this.eventManager.emitTaskEvent({
                                    type: EventTypes.TASK_UPDATED,
                                    timestamp: Date.now(),
                                    taskId: updated.path,
                                    task: updated,
                                    changes: {
                                        before: oldTask,
                                        after: updated
                                    }
                                });

                                TaskManager.logger.info('Task updated in bulk operation', {
                                    taskId: updated.path,
                                    updates: op.data
                                });
                                break;

                            case 'delete':
                                const task = await this.storage.getTask(op.path);
                                if (task) {
                                    // Emit task deleted event before deletion
                                    this.eventManager.emitTaskEvent({
                                        type: EventTypes.TASK_DELETED,
                                        timestamp: Date.now(),
                                        taskId: task.path,
                                        task: task
                                    });

                                    await this.indexManager.unindexTask(task);
                                    TaskManager.logger.info('Task deleted in bulk operation', {
                                        taskId: task.path
                                    });
                                }
                                await this.operations.deleteTask(op.path);
                                break;
                        }
                    } catch (error) {
                        errors.push(error as Error);
                        TaskManager.logger.error('Failed to execute bulk operation', {
                            error,
                            operation: op
                        });
                    }
                }

                // Commit transaction if no errors
                if (errors.length === 0) {
                    await this.storage.commitTransaction();
                } else {
                    await this.storage.rollbackTransaction();
                    throw createError(
                        ErrorCodes.INVALID_INPUT,
                        'Failed to execute bulk operations',
                        'bulkTaskOperations',
                        undefined,
                        {
                            errors,
                            operations
                        }
                    );
                }

                return {
                    success: true,
                    data: results,
                    metadata: {
                        timestamp: Date.now(),
                        requestId: Math.random().toString(36).substring(7),
                        projectPath: results[0]?.projectPath || 'unknown',
                        affectedPaths: operations.map(op => op.path)
                    }
                };
            } catch (error) {
                await this.storage.rollbackTransaction();
                throw error;
            }
        } catch (error) {
            TaskManager.logger.error('Failed to execute bulk operations', { error });
            throw error;
        }
    }
}

================
File: .eslintrc.json
================
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": "./tsconfig.json",
    "ecmaVersion": 2022,
    "sourceType": "module"
  },
  "plugins": [
    "@typescript-eslint",
    "jest",
    "import"
  ],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "plugin:jest/recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript"
  ],
  "env": {
    "node": true,
    "jest": true,
    "es2022": true
  },
  "rules": {
    "@typescript-eslint/explicit-function-return-type": ["error", {
      "allowExpressions": true,
      "allowTypedFunctionExpressions": true
    }],
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": ["error", {
      "argsIgnorePattern": "^_",
      "varsIgnorePattern": "^_"
    }],
    "@typescript-eslint/require-await": "error",
    "@typescript-eslint/no-floating-promises": "error",
    "@typescript-eslint/no-misused-promises": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error",
    "@typescript-eslint/strict-boolean-expressions": "error",
    "import/no-unresolved": "error",
    "import/order": ["error", {
      "groups": [
        ["builtin", "external"],
        "internal",
        ["parent", "sibling", "index"]
      ],
      "newlines-between": "always",
      "alphabetize": {
        "order": "asc",
        "caseInsensitive": true
      }
    }],
    "no-console": ["error", {
      "allow": ["warn", "error"]
    }],
    "no-return-await": "error",
    "prefer-const": "error",
    "eqeqeq": ["error", "always"],
    "curly": ["error", "all"],
    "no-var": "error",
    "require-await": "error"
  },
  "settings": {
    "import/parsers": {
      "@typescript-eslint/parser": [".ts", ".tsx"]
    },
    "import/resolver": {
      "typescript": {
        "alwaysTryTypes": true,
        "project": "./tsconfig.json"
      }
    }
  },
  "overrides": [
    {
      "files": ["**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)"],
      "extends": ["plugin:jest/recommended"],
      "rules": {
        "@typescript-eslint/no-explicit-any": "off",
        "@typescript-eslint/no-non-null-assertion": "off"
      }
    }
  ]
}

================
File: .gitignore
================
# Operating System Files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE and Editor Files
.idea/
.vscode/
*.swp
*.swo
*~
*.sublime-workspace
*.sublime-project

# TypeScript
*.tsbuildinfo
.tscache/
*.js.map
*.tgz
.npm
.eslintcache
.rollup.cache
*.mjs.map
*.cjs.map
*.d.ts.map
*.d.ts
!*.d.ts.template
package-lock.json
yarn.lock
.pnp.js
.pnp.cjs
.pnp.mjs
.pnp.json
.pnp.ts

# Demo and Example Directories
demo/
demos/
example/
examples/
samples/
.sample-env
sample.*
!sample.template.*

# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
.pytest_cache/
.coverage
htmlcov/
.tox/
.venv
venv/
ENV/

# Java
*.class
*.log
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar
hs_err_pid*
target/
.gradle/
build/

# Ruby
*.gem
*.rbc
/.config
/coverage/
/InstalledFiles
/pkg/
/spec/reports/
/spec/examples.txt
/test/tmp/
/test/version_tmp/
/tmp/
.byebug_history

# Compiled Files
*.com
*.class
*.dll
*.exe
*.o
*.so

# Package Files
*.7z
*.dmg
*.gz
*.iso
*.rar
*.tar
*.zip

# Logs and Databases
*.log
*.sql
*.sqlite
*.sqlite3

# Build and Distribution
dist/
build/
out/

# Documentation
docs/_build/
doc/api/

# Dependency Directories
jspm_packages/
bower_components/

# Testing
coverage/
.nyc_output/

# Cache
.cache/
.parcel-cache/

# Misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local
*.bak
*.swp
*.swo
*~
.history/
build/

================
File: jest.config.js
================
/** @type {import('@jest/types').Config.InitialOptions} */
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  setupFilesAfterEnv: ['<rootDir>/tests/jest.setup.ts'],
  testMatch: [
    '<rootDir>/tests/**/*.test.ts',
  ],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/',
    '/build/',
  ],
  globals: {
    'ts-jest': {
      useESM: true,
    },
  },
  verbose: true,
  testTimeout: 10000,
  roots: ['<rootDir>/src/', '<rootDir>/tests/'],
  moduleDirectories: ['node_modules', 'src'],
  testPathIgnorePatterns: ['/node_modules/', '/build/'],
};

================
File: LICENSE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: package.json
================
{
  "name": "atlas-mcp-server",
  "version": "1.1.0",
  "description": "A Model Context Protocol server that enables LLMs to manage complex task hierarchies with dependency tracking, status management, and rich metadata support. Provides ACID-compliant storage with caching and batch processing capabilities.",
  "private": true,
  "type": "module",
  "bin": {
    "atlas-mcp-server": "./build/index.js"
  },
  "files": [
    "build"
  ],
  "scripts": {
    "build": "tsc && node --eval \"import('fs').then(fs => fs.promises.chmod('build/index.js', '755'))\" && (echo '# atlas-mcp-server\n' && tree -I 'node_modules|.git|.DS_Store|build' --dirsfirst -F --charset ascii) > repo-tree.md",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspector": "npx @modelcontextprotocol/inspector build/index.js",
    "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js",
    "prestart": "npm run build",
    "start": "node build/index.js",
    "dev": "npm run build && concurrently \"npm run watch\" \"npm run start\""
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cyanheads/atlas-mcp-server.git"
  },
  "author": "cyanheads",
  "bugs": {
    "url": "https://github.com/cyanheads/atlas-mcp-server/issues"
  },
  "homepage": "https://github.com/cyanheads/atlas-mcp-server#readme",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.4",
    "@types/uuid": "^9.0.7",
    "@types/winston": "^2.4.4",
    "dotenv": "^16.4.1",
    "nanoid": "^5.0.4",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "uuid": "^11.0.0",
    "winston": "^3.11.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@jest/types": "^29.6.3",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.17.10",
    "@types/sqlite3": "^3.1.11",
    "concurrently": "^8.2.2",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.2",
    "typescript": "^5.3.3"
  }
}

================
File: README.md
================
# ATLAS MCP Server

[![TypeScript](https://img.shields.io/badge/TypeScript-5.3-blue.svg)](https://www.typescriptlang.org/)
[![Model Context Protocol](https://img.shields.io/badge/MCP-1.0.4-green.svg)](https://modelcontextprotocol.io/)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Status](https://img.shields.io/badge/Status-Beta-yellow.svg)]()
[![GitHub](https://img.shields.io/github/stars/cyanheads/atlas-mcp-server?style=social)](https://github.com/cyanheads/atlas-mcp-server)

ATLAS (Adaptive Task & Logic Automation System) is a Model Context Protocol server that provides hierarchical task management capabilities to Large Language Models. This tool provides LLMs with the structure and context needed to manage complex tasks and dependencies.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Installation](#installation)
- [Configuration](#configuration)
- [Task Structure](#task-structure)
- [Tools](#tools)
- [Best Practices](#best-practices)
- [Known Issues](#known-issues)
- [Development](#development)
- [Contributing](#contributing)
- [License](#license)

## Overview

ATLAS implements the Model Context Protocol (MCP), created by Anthropic, which enables standardized communication between LLMs and external systems through:
- **Clients** (Claude Desktop, IDEs) that maintain server connections
- **Servers** that provide tools and resources
- **LLMs** that interact with servers through client applications

#### Dev Note:
- This project is in active development and may have breaking changes.
- This is my first time working with TypeScript and I'm learning as I go.

### Core Components

- **TaskManager**: Centralized task coordination with validation and event handling
- **TaskOperations**: ACID-compliant task operations with transaction support
- **TaskValidator**: Comprehensive validation with Zod schemas and path validation
- **PathValidator**: Robust path validation and sanitization
- **TransactionScope**: Improved transaction management with isolation levels
- **StorageManager**: SQLite-based persistence with WAL mode
- **EventManager**: System-wide event tracking and notification
- **BatchProcessors**: Optimized bulk operations for status and dependency updates

## Features

### Task Organization
- Hierarchical task structure with parent-child relationships
- Strong type validation (TASK, GROUP, MILESTONE)
- Status management (PENDING, IN_PROGRESS, COMPLETED, FAILED, BLOCKED)
- Dependency tracking with cycle detection
- Rich metadata support with schema validation

### Path Validation & Safety
- Directory traversal prevention
- Special character validation
- Parent-child path validation
- Path depth limits
- Project name validation
- Path sanitization
- Consistent path formatting

### Transaction Management
- Isolation level support
- Nested transaction handling
- Savepoint management
- Automatic rollback
- Transaction-safe operations
- Vacuum operation support

### Storage & Performance
- SQLite backend with Write-Ahead Logging (WAL)
- LRU caching with memory pressure monitoring
- Transaction-based operations with rollback
- Batch processing for bulk updates
- Index-based fast retrieval
- Automatic cache management

### Validation & Safety
- Zod schema validation for all inputs
- Circular dependency prevention
- Status transition validation
- Metadata schema enforcement
- Parent-child relationship validation
- Version tracking for concurrency

### Monitoring & Maintenance
- Comprehensive event system
- Memory usage monitoring
- Database optimization tools
- Relationship repair utilities
- Cache statistics tracking
- Health monitoring

### Error Handling
- Detailed error codes and messages
- Transaction safety with rollback
- Retryable operation support
- Rich error context
- Event-based error tracking

## Installation

1. Clone the repository:
```bash
git clone https://github.com/cyanheads/atlas-mcp-server.git
cd atlas-mcp-server
npm install
```

## Configuration

Add to your MCP client settings:

```json
{
  "mcpServers": {
    "atlas": {
      "command": "node",
      "args": ["/path/to/atlas-mcp-server/build/index.js"],
      "env": {
        "ATLAS_STORAGE_DIR": "/path/to/storage/directory",
        "ATLAS_STORAGE_NAME": "atlas-tasks",
        "NODE_ENV": "production"
      }
    }
  }
}
```

Advanced configuration options:
```json
{
  "storage": {
    "connection": {
      "maxRetries": 3,
      "retryDelay": 500,
      "busyTimeout": 2000
    },
    "performance": {
      "checkpointInterval": 60000,
      "cacheSize": 1000,
      "mmapSize": 1073741824,
      "pageSize": 4096
    }
  },
  "logging": {
    "console": true,
    "file": true,
    "level": "debug"
  }
}
```

## Task Structure

Tasks support rich content and metadata within a hierarchical structure:

```typescript
{
  // Path must follow validation rules:
  // - No parent directory traversal (..)
  // - Only alphanumeric, dash, underscore
  // - Max depth of 5 levels
  // - Valid project name as first segment
  "path": "project/feature/task",
  
  "name": "Implementation Task",
  "description": "Implement core functionality",
  "type": "TASK", // TASK, GROUP, or MILESTONE
  "status": "PENDING",
  
  // Parent path must exist and follow same rules
  "parentPath": "project/feature",
  
  // Dependencies are validated for:
  // - Existence
  // - No circular references
  // - Status transitions
  "dependencies": ["project/feature/design"],
  
  "notes": [
    "# Requirements\n- Feature A\n- Feature B",
    "interface Feature {\n  name: string;\n  enabled: boolean;\n}"
  ],
  
  "metadata": {
    "priority": "high",
    "tags": ["core", "implementation"],
    "estimatedHours": 8,
    "assignee": "john.doe",
    "customField": {
      "nested": {
        "value": 123
      }
    }
  },

  // System fields
  "created": 1703094689310,
  "updated": 1703094734316,
  "projectPath": "project",
  "version": 1
}
```

## Tools

### Task Management

#### create_task
Creates tasks with validation and dependency checks:
```typescript
{
  "path": "project/backend", // Must follow path rules
  "name": "Backend Development",
  "type": "GROUP",
  "description": "Implement core backend services",
  "metadata": {
    "priority": "high",
    "tags": ["backend", "api"]
  }
}
```

#### update_task
Updates tasks with status and dependency validation:
```typescript
{
  "path": "project/backend/api",
  "updates": {
    "status": "IN_PROGRESS", // Validates dependencies
    "dependencies": ["project/backend/database"],
    "metadata": {
      "progress": 50,
      "assignee": "team-member"
    }
  }
}
```

#### bulk_task_operations
Executes multiple operations atomically:
```typescript
{
  "operations": [
    {
      "type": "create",
      "path": "project/frontend",
      "data": {
        "name": "Frontend Development",
        "type": "GROUP"
      }
    },
    {
      "type": "update",
      "path": "project/backend",
      "data": {
        "status": "COMPLETED"
      }
    }
  ]
}
```

### Task Queries

#### get_tasks_by_status
Retrieve tasks by execution state:
```typescript
{
  "status": "IN_PROGRESS"
}
```

#### get_tasks_by_path
Search using glob patterns:
```typescript
{
  "pattern": "project/backend/**"
}
```

#### get_subtasks
List immediate child tasks:
```typescript
{
  "parentPath": "project/backend"
}
```

### Maintenance Tools

#### vacuum_database
Optimize database storage and performance:
```typescript
{
  "analyze": true // Also updates statistics
}
```

#### repair_relationships
Fix task relationship inconsistencies:
```typescript
{
  "dryRun": true, // Preview changes
  "pathPattern": "project/**"
}
```

#### clear_all_tasks
Reset database with confirmation:
```typescript
{
  "confirm": true
}
```

## Best Practices

### Task Management
- Use descriptive path names reflecting hierarchy
- Set appropriate task types (TASK, GROUP, MILESTONE)
- Include detailed descriptions for context
- Use metadata for custom fields
- Consider dependencies carefully
- Maintain clean parent-child relationships

### Path Naming
- Use alphanumeric characters, dash, underscore
- Keep paths short and meaningful
- Start with valid project name
- Avoid special characters
- Use forward slashes
- Keep depth under 5 levels

### Performance
- Use bulk operations for multiple updates
- Keep task hierarchies shallow
- Clean up completed tasks regularly
- Monitor memory usage
- Use appropriate batch sizes
- Maintain proper indexes

### Data Integrity
- Validate inputs before operations
- Handle status transitions properly
- Check for circular dependencies
- Maintain metadata consistency
- Use transactions for related changes
- Regular database maintenance

## Known Issues

1. Path Depth Validation
   - Deep paths (>5 levels) may be accepted
   - Need stricter enforcement

2. Cascading Deletion
   - Some deep path tasks may survive parent deletion
   - Needs improved recursive deletion

3. Transaction Management
   - Bulk operations may fail with nested transactions
   - clear_all_tasks has transaction issues
   - Needs proper nested transaction support

## Development

```bash
npm run build    # Build project
npm run watch    # Watch for changes
npm test        # Run tests
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

For bugs and feature requests, please create an issue.

## License

Apache License 2.0

---

<div align="center">
Built with the Model Context Protocol
</div>

================
File: repo-tree.md
================
# atlas-mcp-server

./
|-- src/
|   |-- config/
|   |   `-- index.ts
|   |-- errors/
|   |   `-- index.ts
|   |-- events/
|   |   `-- event-manager.ts
|   |-- logging/
|   |   `-- index.ts
|   |-- server/
|   |   |-- health-monitor.ts
|   |   |-- index.ts
|   |   |-- metrics-collector.ts
|   |   |-- rate-limiter.ts
|   |   `-- request-tracer.ts
|   |-- storage/
|   |   |-- core/
|   |   |   |-- connection/
|   |   |   |   |-- health.ts
|   |   |   |   |-- manager.ts
|   |   |   |   |-- pool.ts
|   |   |   |   `-- state.ts
|   |   |   |-- query/
|   |   |   |   |-- builder.ts
|   |   |   |   |-- executor.ts
|   |   |   |   `-- optimizer.ts
|   |   |   |-- schema/
|   |   |   |   |-- backup.ts
|   |   |   |   |-- migrations.ts
|   |   |   |   `-- validator.ts
|   |   |   |-- transactions/
|   |   |   |   |-- manager.ts
|   |   |   |   `-- scope.ts
|   |   |   |-- wal/
|   |   |   |   `-- manager.ts
|   |   |   `-- index.ts
|   |   |-- monitoring/
|   |   |   |-- health.ts
|   |   |   |-- index.ts
|   |   |   `-- metrics.ts
|   |   |-- sqlite/
|   |   |   |-- index.ts
|   |   |   |-- init.ts
|   |   |   `-- storage.ts
|   |   |-- connection-manager.ts
|   |   |-- factory.ts
|   |   |-- index.ts
|   |   `-- sqlite-storage.ts
|   |-- task/
|   |   |-- core/
|   |   |   |-- batch/
|   |   |   |   |-- common/
|   |   |   |   |   `-- batch-utils.ts
|   |   |   |   |-- base-batch-processor.ts
|   |   |   |   |-- dependency-aware-batch-processor.ts
|   |   |   |   |-- generic-batch-processor.ts
|   |   |   |   |-- index.ts
|   |   |   |   |-- status-update-batch.ts
|   |   |   |   `-- task-status-batch-processor.ts
|   |   |   |-- cache/
|   |   |   |   |-- cache-coordinator.ts
|   |   |   |   |-- cache-manager.ts
|   |   |   |   |-- cache-metrics.ts
|   |   |   |   `-- index.ts
|   |   |   |-- indexing/
|   |   |   |   |-- index-manager.ts
|   |   |   |   `-- index.ts
|   |   |   |-- transactions/
|   |   |   |   |-- index.ts
|   |   |   |   `-- transaction-manager.ts
|   |   |   |-- index.ts
|   |   |   `-- task-store.ts
|   |   |-- operations/
|   |   |   |-- index.ts
|   |   |   `-- task-operations.ts
|   |   `-- validation/
|   |       |-- index.ts
|   |       `-- task-validator.ts
|   |-- tools/
|   |   |-- handler.ts
|   |   |-- index.ts
|   |   |-- schemas.ts
|   |   |-- session-schemas.ts
|   |   `-- utils.ts
|   |-- types/
|   |   |-- batch.ts
|   |   |-- cache.ts
|   |   |-- config.ts
|   |   |-- error.ts
|   |   |-- events.ts
|   |   |-- index.ts
|   |   |-- indexing.ts
|   |   |-- logging.ts
|   |   |-- project.ts
|   |   |-- session.ts
|   |   |-- storage.ts
|   |   |-- task.ts
|   |   `-- transaction.ts
|   |-- utils/
|   |   |-- id-generator.ts
|   |   |-- path-utils.ts
|   |   `-- pattern-matcher.ts
|   |-- validation/
|   |   |-- config.ts
|   |   |-- id-schema.ts
|   |   |-- index.ts
|   |   |-- logging.ts
|   |   `-- path-validator.ts
|   |-- index.ts
|   `-- task-manager.ts
|-- LICENSE
|-- README.md
|-- jest.config.js
|-- package.json
|-- repo-tree.md
`-- tsconfig.json

29 directories, 88 files

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "lib": ["ES2022"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "build",
    "declaration": true,
    "sourceMap": true,
    "inlineSources": true,
    "resolveJsonModule": true,
    "rootDir": "src",
    "noImplicitAny": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "removeComments": false,
    "preserveConstEnums": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "build", "**/*.test.ts"]
}
